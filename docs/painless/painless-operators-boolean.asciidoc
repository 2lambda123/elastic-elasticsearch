[[painless-operators-boolean]]
=== Operators: Boolean

[[boolean-not-operator]]
==== Boolean Not

Use the *boolean not operator* to flip a `boolean` type value from `true` to
`false` or `false` to `true`.

*Errors*

* If a value other than a `boolean` type value or a value that is castable to a
  `boolean` type value is given.

*Truth*

[options="header",cols="<1,<1"]
|====
| original | result
| true     | false
| false    | true
|====

*Grammar*

[source,ANTLR4]
----
boolean_not: '!' expression;
----

*Examples*

* Uses of the *boolean not operator*.
+
[source,Painless]
----
<1> boolean x = !false;
<2> boolean y = !x;
----
<1> declare `boolean x`;
    boolean not `boolean false` -> `boolean true`;
    store `boolean true` to `x`
<2> declare `boolean y`;
    load from `x` -> `boolean true`;
    boolean not `boolean true` -> `boolean false`;
    store `boolean false` to `y`
+
* Uses of the *boolean not operator* with the `def` type.
+
[source,Painless]
----
<1> def y = true;
<2> def z = !y;
----
+
<1> declare `def y`;
    implicit cast `boolean true` to `def` -> `def`;
    store `true` to `y`
<2> declare `def z`;
    load from `y` -> `def`;
    implicit cast `def` to `boolean true` -> boolean `true`;
    boolean not `boolean true` -> `boolean false`;
    implicit cast `boolean false` to `def` -> `def`;
    store `def` to `z`

[[greater-than-operator]]
==== Greater Than

Use the *greater than operator* to compare two numeric type values where a
resultant `boolean` type value is `true` if the left-hand side value is greater
than to the right-hand side value and `false` otherwise.

*Errors*

* If either the evaluated left-hand side or the evaluated right-hand side is a
  non-numeric value.

*Grammar*

[source,ANTLR4]
----
greater_than: expression '>' expression;
----

*Promotion*

[cols="<1,^1,^1,^1,^1,^1,^1,^1,^1"]
|====
|        | byte   | short  | char   | int    | long   | float  | double | def
| byte   | int    | int    | int    | int    | long   | float  | double | def
| short  | int    | int    | int    | int    | long   | float  | double | def
| char   | int    | int    | int    | int    | long   | float  | double | def
| int    | int    | int    | int    | int    | long   | float  | double | def
| long   | long   | long   | long   | long   | long   | float  | double | def
| float  | float  | float  | float  | float  | float  | float  | double | def
| double | double | double | double | double | double | double | double | def
| def    | def    | def    | def    | def    | def    | def    | def    | def
|====

*Examples*

* Uses of the *greater than operator*.
+
[source,Painless]
----
<1> boolean x = 5 > 4;
<2> double y = 6.0;
<3> x = 6 > y;
----
+
<1> declare `boolean x`;
    greater than `int 5` and `int 4` -> `boolean true`;
    store `boolean true` to `x`;
<2> declare `double y`;
    store `double 6.0` to `y`;
<3> load from `y` -> `double 6.0 @0`;
    promote `int 6` and `double 6.0`: result `double`;
    implicit cast `int 6` to `double 6.0 @1` -> `double 6.0 @1`;
    greater than `double 6.0 @1` and `double 6.0 @0` -> `boolean false`;
    store `boolean false` to `x`
+
* Uses of the *greater than operator* with the `def` type.
+
[source,Painless]
----
<1> int x = 5;
<2> def y = 7.0;
<3> def z = y > 6.5;
<4> def a = x > y;
----
+
<1> declare `int x`;
    store `int 5` to `x`
<2> declare `def y`;
    implicit cast `double 7.0` to `def` -> `def`;
    store `def` to `y`
<3> declare `def z`;
    load from `y` -> `def`;
    implicit cast `def` to `double 7.0` -> `double 7.0`;
    greater than `double 7.0` and `double 6.5` -> `boolean true`;
    implicit cast `boolean true` to `def` -> `def`;
    store `def` to `z`
<4> declare `def a`;
    load from `y` -> `def`;
    implicit cast `def` to `double 7.0` -> `double 7.0`;
    load from `x` -> `int 5`;
    promote `int 5` and `double 7.0`: result `double`;
    implicit cast `int 5` to `double 5.0` -> `double 5.0`;
    greater than `double 5.0` and `double 7.0` -> `boolean false`;
    implicit cast `boolean false` to `def` -> `def`;
    store `def` to `z`

[[greater-than-or-equal-operator]]
==== Greater Than Or Equal

Use the *greater than or equal operator* to compare two numeric type values
where a resultant `boolean` type value is `true` if the left-hand side value is
greater than or equal to the right-hand side value and `false` otherwise.

*Errors*

* If either the evaluated left-hand side or the evaluated right-hand side is a
  non-numeric value.

*Grammar*

[source,ANTLR4]
----
greater_than_or_equal: expression '>=' expression;
----

*Promotion*

[cols="<1,^1,^1,^1,^1,^1,^1,^1,^1"]
|====
|        | byte   | short  | char   | int    | long   | float  | double | def
| byte   | int    | int    | int    | int    | long   | float  | double | def
| short  | int    | int    | int    | int    | long   | float  | double | def
| char   | int    | int    | int    | int    | long   | float  | double | def
| int    | int    | int    | int    | int    | long   | float  | double | def
| long   | long   | long   | long   | long   | long   | float  | double | def
| float  | float  | float  | float  | float  | float  | float  | double | def
| double | double | double | double | double | double | double | double | def
| def    | def    | def    | def    | def    | def    | def    | def    | def
|====

*Examples*

* Uses of the *greater than or equal operator*.
+
[source,Painless]
----
<1> boolean x = 5 >= 4;
<2> double y = 6.0;
<3> x = 6 >= y;
----
+
<1> declare `boolean x`;
    greater than or equal `int 5` and `int 4` -> `boolean true`;
    store `boolean true` to `x`
<2> declare `double y`;
    store `double 6.0` to `y`
<3> load from `y` -> `double 6.0 @0`;
    promote `int 6` and `double 6.0`: result `double`;
    implicit cast `int 6` to `double 6.0 @1` -> `double 6.0 @1`;
    greater than or equal `double 6.0 @1` and `double 6.0 @0` -> `boolean true`;
    store `boolean true` to `x`
+
* Uses of the *greater than operator or equal* with the `def` type.
+
[source,Painless]
----
<1> int x = 5;
<2> def y = 7.0;
<3> def z = y >= 7.0;
<4> def a = x >= y;
----
+
<1> declare `int x`;
    store `int 5` to `x`;
<2> declare `def y`
    implicit cast `double 7.0` to `def` -> `def`;
    store `def` to `y`
<3> declare `def z`;
    load from `y` -> `def`;
    implicit cast `def` to `double 7.0 @0` -> `double 7.0 @0`;
    greater than or equal `double 7.0 @0` and `double 7.0 @1` -> `boolean true`;
    implicit cast `boolean true` to `def` -> `def`;
    store `def` to `z`
<4> declare `def a`;
    load from `y` -> `def`;
    implicit cast `def` to `double 7.0` -> `double 7.0`;
    load from `x` -> `int 5`;
    promote `int 5` and `double 7.0`: result `double`;
    implicit cast `int 5` to `double 5.0` -> `double 5.0`;
    greater than or equal `double 5.0` and `double 7.0` -> `boolean false`;
    implicit cast `boolean false` to `def` -> `def`;
    store `def` to `z`

[[less-than-operator]]
==== Less Than

Use the *less than operator* to compare two numeric type values where a
resultant `boolean` type value is `true` if the left-hand side value is less
than to the right-hand side value and `false` otherwise.

*Errors*

* If either the evaluated left-hand side or the evaluated right-hand side is a
  non-numeric value.

*Grammar*

[source,ANTLR4]
----
less_than: expression '<' expression;
----

*Promotion*

[cols="<1,^1,^1,^1,^1,^1,^1,^1,^1"]
|====
|        | byte   | short  | char   | int    | long   | float  | double | def
| byte   | int    | int    | int    | int    | long   | float  | double | def
| short  | int    | int    | int    | int    | long   | float  | double | def
| char   | int    | int    | int    | int    | long   | float  | double | def
| int    | int    | int    | int    | int    | long   | float  | double | def
| long   | long   | long   | long   | long   | long   | float  | double | def
| float  | float  | float  | float  | float  | float  | float  | double | def
| double | double | double | double | double | double | double | double | def
| def    | def    | def    | def    | def    | def    | def    | def    | def
|====

*Examples*

* Uses of the *less than operator*.
+
[source,Painless]
----
<1> boolean x = 5 < 4;
<2> double y = 6.0;
<3> x = 6 < y;
----
+
<1> declare `boolean x`;
    less than `int 5` and `int 4` -> `boolean false`;
    store `boolean false` to `x`
<2> declare `double y`;
    store `double 6.0` to `y`
<3> load from `y` -> `double 6.0 @0`;
    promote `int 6` and `double 6.0`: result `double`;
    implicit cast `int 6` to `double 6.0 @1` -> `double 6.0 @1`;
    less than `double 6.0 @1` and `double 6.0 @0` -> `boolean false`;
    store `boolean false` to `x`
+
* Uses of the *less than operator* with the `def` type.
+
[source,Painless]
----
<1> int x = 5;
<2> def y = 7.0;
<3> def z = y < 6.5;
<4> def a = x < y;
----
+
<1> declare `int x`;
    store `int 5` to `x`
<2> declare `def y`;
    implicit cast `double 7.0` to `def` -> `def`;
    store `def` to `y`
<3> declare `def z`;
    load from `y` -> `def`;
    implicit cast `def` to `double 7.0` -> `double 7.0`;
    less than `double 7.0` and `double 6.5` -> `boolean false`;
    implicit cast `boolean false` to `def` -> `def`;
    store `def` to `z`
<4> declare `def a`;
    load from `y` -> `def`;
    implicit cast `def` to `double 7.0` -> `double 7.0`;
    load from `x` -> `int 5`;
    promote `int 5` and `double 7.0`: result `double`;
    implicit cast `int 5` to `double 5.0` -> `double 5.0`;
    less than `double 5.0` and `double 7.0` -> `boolean true`;
    implicit cast `boolean true` to `def` -> `def`;
    store `def` to `z`

[[less-than-or-equal-operator]]
==== Less Than Or Equal

Use the *less than or equal operator* to compare two numeric type values
where a resultant `boolean` type value is `true` if the left-hand side value is
less than or equal to the right-hand side value and `false` otherwise.

*Errors*

* If either the evaluated left-hand side or the evaluated right-hand side is a
  non-numeric value.

*Grammar*

[source,ANTLR4]
----
greater_than_or_equal: expression '<=' expression;
----

*Promotion*

[cols="<1,^1,^1,^1,^1,^1,^1,^1,^1"]
|====
|        | byte   | short  | char   | int    | long   | float  | double | def
| byte   | int    | int    | int    | int    | long   | float  | double | def
| short  | int    | int    | int    | int    | long   | float  | double | def
| char   | int    | int    | int    | int    | long   | float  | double | def
| int    | int    | int    | int    | int    | long   | float  | double | def
| long   | long   | long   | long   | long   | long   | float  | double | def
| float  | float  | float  | float  | float  | float  | float  | double | def
| double | double | double | double | double | double | double | double | def
| def    | def    | def    | def    | def    | def    | def    | def    | def
|====

*Examples*

* Uses of the *less than or equal operator*.
+
[source,Painless]
----
<1> boolean x = 5 <= 4;
<2> double y = 6.0;
<3> x = 6 <= y;
----
+
<1> declare `boolean x`;
    less than or equal `int 5` and `int 4` -> `boolean false`;
    store `boolean true` to `x`
<2> declare `double y`;
    store `double 6.0` to `y`
<3> load from `y` -> `double 6.0 @0`;
    promote `int 6` and `double 6.0`: result `double`;
    implicit cast `int 6` to `double 6.0 @1` -> `double 6.0 @1`;
    less than or equal `double 6.0 @1` and `double 6.0 @0` -> `boolean true`;
    store `boolean true` to `x`
+
* Uses of the *less than operator or equal* with the `def` type.
+
[source,Painless]
----
<1> int x = 5;
<2> def y = 7.0;
<3> def z = y <= 7.0;
<4> def a = x <= y;
----
+
<1> declare `int x`;
    store `int 5` to `x`;
<2> declare `def y`;
    implicit cast `double 7.0` to `def` -> `def`;
    store `def` to `y`;
<3> declare `def z`;
    load from `y` -> `def`;
    implicit cast `def` to `double 7.0 @0` -> `double 7.0 @0`;
    less than or equal `double 7.0 @0` and `double 7.0 @1` -> `boolean true`;
    implicit cast `boolean true` to `def` -> `def`;
    store `def` to `z`
<4> declare `def a`;
    load from `y` -> `def`;
    implicit cast `def` to `double 7.0` -> `double 7.0`;
    load from `x` -> `int 5`;
    promote `int 5` and `double 7.0`: result `double`;
    implicit cast `int 5` to `double 5.0` -> `double 5.0`;
    less than or equal `double 5.0` and `double 7.0` -> `boolean true`;
    implicit cast `boolean true` to `def` -> `def`;
    store `def` to `z`

[[instanceof-operator]]
==== Instanceof

Use the *instanceof operator* to compare the variable/field type to a
specified reference type using the reference type name where a resultant
`boolean` type value is `true` if the variable/field type is the same as or a
descendant of the specified reference type and false otherwise.

*Errors*

* If the reference type name doesn't exist as specified by the right-hand side.

*Grammar*

[source,ANTLR4]
----
instance_of: ID 'instanceof' TYPE;
----

*Examples*

* Uses of the *instanceof operator*.
+
[source,Painless]
----
<1> Map m = new HashMap();
<2> boolean a = m instanceof HashMap;
<3> boolean b = m instanceof Map;
----
+
<1> declare `Map m`;
    allocate `HashMap` instance -> `HashMap reference`;
    implicit cast `HashMap reference` to `Map reference`;
    store `Map reference` to `m`
<2> declare `boolean a`;
    load from `m` -> `Map reference`;
    implicit cast `Map reference` to `HashMap reference` -> `HashMap reference`;
    instanceof `HashMap reference` and `HashMap` -> `true`;
    store `true` to `a`
<3> declare `boolean b`;
    load from `m` -> `Map reference`;
    implicit cast `Map reference` to `HashMap reference` -> `HashMap reference`;
    instanceof `HashMap reference` and `Map` -> `true`;
    store `true` to `b`;
    (note `HashMap` is a descendant of `Map`)
+
* Uses of the *instanceof operator* with the `def` type.
+
[source,Painless]
----
<1> def d = new ArrayList();
<2> boolean a = d instanceof List;
<3> boolean b = d instanceof Map;
----
+
<1> declare `def d`;
    allocate `ArrayList` instance -> `ArrayList reference`;
    implicit cast `ArrayList reference` to `def` -> `def`;
    store `def` to `d`
<2> declare `boolean a`;
    load from `d` -> `def`;
    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;
    instanceof `ArrayList reference` and `List` -> `true`;
    store `true` to `a`;
    (note `ArrayList` is a descendant of `List`)
<3> declare `boolean b`;
    load from `d` -> `def`;
    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;
    instanceof `ArrayList reference` and `Map` -> `false`;
    store `false` to `a`;
    (note `ArrayList` is not a descendant of `Map`)

[[equality-equals-operator]]
==== Equality Equals

Equality equals compares two expressions where a resultant boolean value is true if the two expressions are equal and false otherwise.  When reference types are compared using this operator the equivalent of the equals member method will be called against the first expression, where the second expression is the argument.  Though the equals member method is used for reference types, this operation will always be null-safe.  Valid comparisons are between boolean types, primitive numeric types, and reference types.  If a comparison is made that is not listed as one of the valid comparisons an error will occur.  The format is an expression, followed by the equals-equals operator, and finished with an expression.

*Grammar:*
[source,ANTLR4]
----
equality_equals: expression '==' expression;
----

A numeric type promotion may occur during a primitive numeric comparison.  A def type evaluated at run-time will follow the same promotion table at run-time following whatever type def represents.

Promotion Table:
|====
||byte|short|char|int|long|float|double|def
|byte|int|int|int|int|long|float|double|def
|short|int|int|int|int|long|float|double|def
|char|int|int|int|int|long|float|double|def
|int|int|int|int|int|long|float|double|def
|long|long|long|long|long|long|float|double|def
|float|float|float|float|float|float|float|double|def
|double|double|double|double|double|double|double|double|def
|def|def|def|def|def|def|def|def|def
|====

*Examples:*
[source,Java]
----
boolean b0 = true;              // declares the boolean variable b0 and sets it the constant boolean true
boolean b1 = false;             // declares the boolean variable b1 and sets it the constant boolean false
int i = 2;                      // declares the int variable i and sets it the constant int 2
float f = 2.0f;                 // declares the float variable f and sets it the constant float 2.0
List l0 = new ArrayList();      // declares the List variable l0 and sets it to a newly allocated ArrayList
ArrayList l1 = new ArrayList(); // declares the ArrayList variable l1 and sets it to a newly allocated ArrayList
def di0 = 2;                    // declares the def variable di0 and sets it the constant int 2
def di1 = 3;                    // declares the def variable di1 and sets it the constant int 3
def dl = new ArrayList();       // declares the def variable dl and sets it to a newly allocated ArrayList
boolean result;                 // declares the boolean variable result

result = b0 == b1;              // compares b0 to b1 and has a boolean result of false
result = i == f;                // compares i to f where i is promoted to float and has a boolean result of true
result = b0 == i;               // ERROR: a comparison between a boolean and a primitive numeric type is illegal
result = i == l0;               // ERROR: a comparison between a primitive numeric type and a reference type is illegal

l0.add(1);                      // adds a constant int 1 to the List l0
l1.add(1);                      // adds a constant int 1 to the ArrayList l1
result = l0 == l1;              // compares l0 to l1 using l0.equals(l1) and has a boolean result of true
l0.add(1);                      // adds a constant int 1 to the List l0
result = l0 == l1;              // compares l0 to l1 using l0.equals(l1) and has a boolean result of false

result = di0 == di1;            // compares di0 to di1 and has a boolean result of false
result = di0 == i;              // compares di0 to i where i is promoted to def and has a boolean result of true

dl.add(1);                      // adds a constant int 1 to the def ArrayList dl
result = dl == l0;              // compares dl to l0 using dl.equals(l0) with a boolean result of true

result = null == dl;            // compares null to dl with a boolean result of false
result = l1 == null;            // compares l1 to null with a boolean result of false
----

[[equality-not-equals-operator]]
==== Equality Not Equals

Equality not equals compares two expressions where a resultant boolean value is true if the two expressions are not equal and false otherwise.  When reference types are compared using this operator the equivalent of the equals member method will be called against the first expression, where the second expression is the argument, with the resultant boolean being reversed.  Though the equals member method is used for reference types, this operation will always be null-safe.  Valid comparisons are between boolean types, primitive numeric types, and reference types.  If a comparison is made that is not listed as one of the valid comparisons an error will occur.  The format is an expression, followed by the bang-equals operator, and finished with an expression.

*Grammar:*
[source,ANTLR4]
----
equality_not_equals: expression '!=' expression;
----

A numeric type promotion may occur during a primitive numeric comparison.  A def type evaluated at run-time will follow the same promotion table at run-time following whatever type def represents.

Promotion Table:
|====
||byte|short|char|int|long|float|double|def
|byte|int|int|int|int|long|float|double|def
|short|int|int|int|int|long|float|double|def
|char|int|int|int|int|long|float|double|def
|int|int|int|int|int|long|float|double|def
|long|long|long|long|long|long|float|double|def
|float|float|float|float|float|float|float|double|def
|double|double|double|double|double|double|double|double|def
|def|def|def|def|def|def|def|def|def
|====

*Examples:*
[source,Java]
----
boolean b0 = true;              // declares the boolean variable b0 and sets it the constant boolean true
boolean b1 = false;             // declares the boolean variable b1 and sets it the constant boolean false
int i = 2;                      // declares the int variable i and sets it the constant int 2
float f = 2.0f;                 // declares the float variable f and sets it the constant float 2.0
List l0 = new ArrayList();      // declares the List variable l0 and sets it to a newly allocated ArrayList
ArrayList l1 = new ArrayList(); // declares the ArrayList variable l1 and sets it to a newly allocated ArrayList
def di0 = 2;                    // declares the def variable di0 and sets it the constant int 2
def di1 = 3;                    // declares the def variable di1 and sets it the constant int 3
def dl = new ArrayList();       // declares the def variable dl and sets it to a newly allocated ArrayList
boolean result;                 // declares the boolean variable result

result = b0 != b1;              // compares b0 to b1 and has a boolean result of true
result = i != f;                // compares i to f where i is promoted to float and has a boolean result of false
result = b0 != i;               // ERROR: a comparison between a boolean and a primitive numeric type is illegal
result = i != l0;               // ERROR: a comparison between a primitive numeric type and a reference type is illegal

l0.add(1);                      // adds a constant int 1 to the List l0
l1.add(1);                      // adds a constant int 1 to the ArrayList l1
result = l0 != l1;              // compares l0 to l1 using l0.equals(l1) and has a boolean result of false
l0.add(1);                      // adds a constant int 1 to the List l0
result = l0 != l1;              // compares l0 to l1 using l0.equals(l1) and has a boolean result of true

result = di0 != di1;            // compares di0 to di1 and has a boolean result of true
result = di0 != i;              // compares di0 to i where i is promoted to def and has a boolean result of false

dl.add(1);                      // adds a constant int 1 to the def ArrayList dl
result = dl != l0;              // compares dl to l0 using dl.equals(l0) with a boolean result of false

result = null != dl;            // compares null to dl with a boolean result of true
result = l1 != null;            // compares null to l1 with a boolean result of true
----

[[identity-equals-operator]]
==== Identity Equals

Identity equals compares two expressions where a resultant boolean value is true if the two expressions are equal and false otherwise.  Two primitive types are considered to be equal if they have the same value.  Two reference types are considered to be equal if they refer to the exact same instance in memory or are both null.  Valid comparisons are between boolean types, primitive numeric types, and reference types.  If a comparison is made that is not listed as one of the valid comparisons an error will occur.  The format is an expression, followed by the equals-equals-equals operator, and finished with an expression.

*Grammar:*
[source,ANTLR4]
----
identity_equals: expression '===' expression;
----

A numeric type promotion may occur during a primitive numeric comparison.  A def type evaluated at run-time will follow the same promotion table at run-time following whatever type def represents.

Promotion Table:
|====
||byte|short|char|int|long|float|double|def
|byte|int|int|int|int|long|float|double|def
|short|int|int|int|int|long|float|double|def
|char|int|int|int|int|long|float|double|def
|int|int|int|int|int|long|float|double|def
|long|long|long|long|long|long|float|double|def
|float|float|float|float|float|float|float|double|def
|double|double|double|double|double|double|double|double|def
|def|def|def|def|def|def|def|def|def
|====

*Examples:*
[source,Java]
----
boolean b0 = true;              // declares the boolean variable b0 and sets it the constant boolean true
boolean b1 = false;             // declares the boolean variable b1 and sets it the constant boolean false
int i = 2;                      // declares the int variable i and sets it the constant int 2
float f = 2.0f;                 // declares the float variable f and sets it the constant float 2.0
List l0 = new ArrayList();      // declares the List variable l0 and sets it to a newly allocated ArrayList
ArrayList l1 = new ArrayList(); // declares the ArrayList variable l1 and sets it to a newly allocated ArrayList
List l2 = l1;                   // declares the List variable l2 and sets it to l1
def di0 = 2;                    // declares the def variable di0 and sets it the constant int 2
def di1 = 3;                    // declares the def variable di1 and sets it the constant int 3
def dl = l0;                    // declares the def variable dl and sets it to l0
boolean result;                 // declares the boolean variable result

result = b0 === b1;             // compares b0 to b1 and has a boolean result of false
result = i === f;               // compares i to f where i is promoted to float and has a boolean result of true
result = b0 === i;              // ERROR: a comparison between a boolean and a primitive numeric type is illegal
result = i === l0;              // ERROR: a comparison between a primitive numeric type and a reference type is illegal

l0.add(1);                      // adds a constant int 1 to the List l0
l1.add(1);                      // adds a constant int 1 to the ArrayList l1
result = l0 === l1;             // compares l0 to l1 and has a boolean result of false
l0.add(1);                      // adds a constant int 1 to the List l0
result = l0 === l1;             // compares l0 to l1 and has a boolean result of false
result = l1 === l2;             // compares l1 to l2 and has a boolean result of true

result = di0 === di1;           // compares di0 to di1 and has a boolean result of false
result = di0 === i;             // compares di0 to i where i is promoted to def and has a boolean result of true

result = dl === l0;             // compares dl to l0 with a boolean result of true

result = null === dl;           // compares null to dl with a boolean result of false
result = l1 === null;           // compares null to l1 with a boolean result of false
----

[[identity-not-equals-operator]]
==== Identity Not Equals

Identity not equals compares two expressions where a resultant boolean value is true if the two expressions are not equal and false otherwise.  Two primitive types are considered to be not equal if they have different values.  Two reference types are considered to be not equal if they refer to the different instances in memory or one is null and the other is not.  Valid comparisons are between boolean types, primitive numeric types, and reference types.  If a comparison is made that is not listed as one of the valid comparisons an error will occur.  The format is an expression, followed by the bang-equals-equals operator, and finished with an expression.

*Grammar:*
[source,ANTLR4]
----
identity_not_equals: expression '!==' expression;
----

A numeric type promotion may occur during a primitive numeric comparison.  A def type evaluated at run-time will follow the same promotion table at run-time following whatever type def represents.

Promotion Table:
|====
||byte|short|char|int|long|float|double|def
|byte|int|int|int|int|long|float|double|def
|short|int|int|int|int|long|float|double|def
|char|int|int|int|int|long|float|double|def
|int|int|int|int|int|long|float|double|def
|long|long|long|long|long|long|float|double|def
|float|float|float|float|float|float|float|double|def
|double|double|double|double|double|double|double|double|def
|def|def|def|def|def|def|def|def|def
|====

*Examples:*
[source,Java]
----
boolean b0 = true;              // declares the boolean variable b0 and sets it the constant boolean true
boolean b1 = false;             // declares the boolean variable b1 and sets it the constant boolean false
int i = 2;                      // declares the int variable i and sets it the constant int 2
float f = 2.0f;                 // declares the float variable f and sets it the constant float 2.0
List l0 = new ArrayList();      // declares the List variable l0 and sets it to a newly allocated ArrayList
ArrayList l1 = new ArrayList(); // declares the ArrayList variable l1 and sets it to a newly allocated ArrayList
List l2 = l1;                   // declares the List variable l2 and sets it to l1
def di0 = 2;                    // declares the def variable di0 and sets it the constant int 2
def di1 = 3;                    // declares the def variable di1 and sets it the constant int 3
def dl = l0;                    // declares the def variable dl and sets it to l0
boolean result;                 // declares the boolean variable result

result = b0 !== b1;             // compares b0 to b1 and has a boolean result of true
result = i !== f;               // compares i to f where i is promoted to float and has a boolean result of false
result = b0 !== i;              // ERROR: a comparison between a boolean and a primitive numeric type is illegal
result = i !== l0;              // ERROR: a comparison between a primitive numeric type and a reference type is illegal

l0.add(1);                      // adds a constant int 1 to the List l0
l1.add(1);                      // adds a constant int 1 to the ArrayList l1
result = l0 !== l1;             // compares l0 to l1 and has a boolean result of true
l0.add(1);                      // adds a constant int 1 to the List l0
result = l0 !== l1;             // compares l0 to l1 and has a boolean result of true
result = l1 !== l2;             // compares l1 to l2 and has a boolean result of false

result = di0 !== di1;           // compares di0 to di1 and has a boolean result of true
result = di0 !== i;             // compares di0 to i where i is promoted to def and has a boolean result of false

result = dl !== l0;             // compares dl to l0 with a boolean result of false

result = null !== dl;           // compares null to dl with a boolean result of true
result = l1 !== null;           // compares null to l1 with a boolean result of true
----

[[boolean-xor-operator]]
==== Boolean Xor

Boolean xor will xor together two boolean expressions.  The table below shows what the resultant boolean value will be based on the two boolean expressions.

|====
||true|false
|true|false|true
|false|true|false
|====

The format starts with an expression, follows with the carrot operator, and finishes with an expression.

*Grammar:*
[source,ANTLR4]
----
boolean_xor: expression '^' expression;
----

Note that def types will be assumed to be of the boolean type.  Any def type evaluated at run-time that does not represent a boolean will result in an error.  Non-boolean expressions will result in an error.

*Examples:*
[source,Java]
----
boolean x = false;    // declares the boolean variable x and sets the constant boolean false
boolean y = x ^ true; // declares the boolean variable y and sets it the result of x xor true
def z = y ^ x;        // declares the def variable z and sets it to the result of y xor x
----

[[boolean-and-operator]]
==== Boolean And

Boolean and will and together two boolean expressions.  If the first expression is found to be false then it is known that the result will also be false, so evaluation of the second expression will be skipped.  The table below shows what the resultant boolean value will be based on the two boolean expressions.

||true|false
|true|true|false
|false|false|false

The format starts with an expression, follows with the ampersand-ampersand operator, and finishes with an expression.

*Grammar:*
[source,ANTLR4]
----
boolean_and: expression '&&' expression;
----

Note that def types will be assumed to be of the boolean type.  Any def type evaluated at run-time that does not represent a boolean will result in an error.  Non-boolean expressions will result in an error.

*Examples:*
[source,Java]
----
boolean x = false;     // declares the boolean variable x and sets the constant boolean false
boolean y = x && true; // declares the boolean variable y and sets it the result of x and true
def z = y && x;        // declares the def variable z and sets it to the result of y and x
----

[[boolean-or-operator]]
==== Boolean Or

Boolean or will or together two boolean expressions.  If the first expression is found to be true then it is known that the result will also be true, so evaluation of the second expression will be skipped.  The table below shows what the resultant boolean value will be based on the two boolean expressions.

|====
||true|false
|true|true|true
|false|true|false
|====

The format starts with an expression, follows with the pipe-pipe operator, and finishes with an expression.

*Grammar:*
[source,ANTLR4]
----
boolean_and: expression '||' expression;
----

Note that def types will be assumed to be of the boolean type.  Any def type evaluated at run-time that does not represent a boolean will result in an error.  Non-boolean expressions will result in an error.

*Examples:*
[source,Java]
----
boolean x = false;     // declares the boolean variable x and sets the constant boolean false
boolean y = x || true; // declares the boolean variable y and sets it the result of x or true
def z = y || x;        // declares the def variable z and sets it to the result of y or x
----