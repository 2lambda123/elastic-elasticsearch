[[painless-variables]]
=== Variables

<<declaration, Declare>> variables to <<assignment, assign>> values for
<<painless-operators, use>> in expressions.  Specify variables as a
<<primitive-types, primitive type>>, <<reference-types, reference type>>, or
<<dynamic-types, dynamic type>>.  Variable operations follow the structure of a
standard JVM in relation to instruction execution and memory usage.

[[declaration]]
==== Declaration

Declare variables before use with the format of <<painless-types, type>>
<<painless-identifiers, identifier>>. Declare <<array-type, array type>>
variables using an opening `[` token and a closing `]` token for each
dimension directly after the <<painless-identifiers, identifier>>. Specify a
comma-separated list of <<painless-identifiers, identifiers>> following the
<<painless-types, type>> to declare multiple variables in a single statement.
Use an <<assignment, assignment>> statement combined with a declaration
statement to immediately assign a value to a variable. Variables not
immediately assigned a value will have a default value assigned implicitly
based on the <<painless-types, type>>.

*Grammar*
[source,ANTLR4]
----
declaration : type ID assignment? (',' ID assignment?)*;
type: ID ('[' ']')*;
assignment: '=' expression;
----

*Examples*

* Different variations of variable declaration.
+
[source,Painless]
----
<1> int x;
<2> List y;
<3> int x, y = 5, z;
<4> def d;
<5> int i = 10;
<6> float[] f;
<7> Map[][] m;
----
+
<1> declare `int x`;
    assign default value of `null` to `x`
<2> declare `List y`;
    assign default value of `null` to `y`
<3> declare `int x`;
    assign default value of `int 0` to `x`;
    declare `int y`;
    assign value of `int 5` to `y`;
    declare `int z`;
    assign default value of `int 0` to `z`;
<4> declare `def d`;
    assign default value of `null` to `d`
<5> declare `int i`;
    assign value of `int 10` to `i`
<6> declare `float[] f`;
    assign default value of `null` to `f`
<7> declare `Map[][] m`;
    assign default value of `null` to `m`

[[assignment]]
==== Assignment

Use the `equals operator '='` to assign a value to a variable. Any expression
that produces a value can be assigned to any variable as long as the
<<painless-types, types>> are the same or the resultant
<<painless-types, type>> can be implicitly <<painless-casting, cast>> to
the variable <<painless-types, type>>.

*Grammar*
[source,ANTLR4]
----
assignment: ID '=' expression
----

*Examples*

* Variable assignment with an <<integers, integer literal>>.
+
[source,Painless]
----
<1> int i;
<2> i = 10;
----
+
<1> declare `int i`;
    assign default value of `int 0` to `i`
<2> assign value of `int 10` to `i`
+
* <<declaration, Declaration>> combined with immediate variable assignment.
+
[source,Painless]
----
<1> int i = 10;
<2> double j = 2.0;
----
+
<1> declare `int i`;
    assign value of `int 10` to `i`
<2> declare `double j`;
    assign value of `double 2.0` to `j`
+
* Assignment of one variable to another using
  <<primitive-types, primitive types>>.
+
[source,Painless]
----
<1> int i = 10;
<2> int j = i;
----
+
<1> declare `int i`;
    assign value of `int 10` to `i`
<2> declare `int j`;
    access `i` -> `int 10`;
    assign value of `int 10` to `j`
+
* Assignment with <<reference-types, reference types>> using the
  <<constructor-call, new operator>>.
+
[source,Painless]
----
<1> ArrayList l = new ArrayList();
<2> Map m = new HashMap();
----
+
<1> declare `ArrayList l`;
    allocate `ArrayList` instance -> `ArrayList reference`;
    assign value of `ArrayList reference` to `l`
<2> declare `Map m`;
    allocate `HashMap` instance -> `HashMap reference`;
    implicit cast value of `HashMap reference` to value of `Map reference`
            -> `Map reference`;
    assign value of `Map reference` to `m`
+
* Assignment of one variable to another using
  <<reference-types, reference types>>.
+
[source,Painless]
----
<1> List l = new ArrayList();
<2> List k = l;
<3> List m;
<4> m = k;
----
+
<1> declare `List l`;
    allocate `ArrayList` instance -> `ArrayList reference`;
    implicit cast value of `ArrayList reference` to value of `List reference`
            -> `List reference`;
    assign value of `List reference` to `l`
<2> declare `List k`;
    access `l` -> `List reference`;
    assign value of `List reference` to `k`;
    (note `l` and `k` refer to the same instance known as a shallow-copy)
<3> declare `List m`;
    assign default value of `null` to `m`
<4> access `k` -> `List reference`;
    assign value of `List reference` to `m`;
    (note `l`, `k`, and `m` refer to the same instance)
+
* Assignment with the <<array-type, array type>> using the
  <<new-array, new operator>>.
+
[source,Painless]
----
<1> int[] ia1;
<2> ia1 = new int[2];
<3> ia1[0] = 1;
<4> int[] ib1 = ia1;
<5> int[][] ic2 = new int[2][5];
<6> ic2[1][3] = 2;
<7> ic2[0] = ia1;
----
+
<1> declare `int[] ia1`;
    assign default value of `null` to `ia1`
<2> allocate `1-d int array` instance with `length [2]`
            -> `1-d int array reference`;
    assign value of `1-d int array reference` to `ia1`
<3> access `ia1` -> `1-d int array reference`;
    assign value of `int 1` to `index [0]` of `1-d int array reference`
<4> declare `int[] ib1`;
    access `ia1` -> `1-d int array reference`;
    assign value of `1-d int array reference` to `ib1`;
    (note `ia1` and `ib1` refer to the same instance known as a shallow copy)
<5> declare `int[][] ic2`;
    allocate `2-d int array` instance with `length [2, 5]`
            -> `2-d int array reference`;
    assign value of `2-d int array reference` to `ic2`
<6> access `ic2` -> `2-d int array reference`;
    assign value of `int 2` to `index [1, 3]` of `2-d int array reference`
<7> access `ia1` -> `1-d int array reference`;
    access `ic2` -> `2-d int array reference`;
    assign value of `1-d int array reference` to
            `index [0]` of `2-d int array reference`;
    (note `ia1`, `ib1`, and `index [0]` of `ia2` refer to the same instance)
