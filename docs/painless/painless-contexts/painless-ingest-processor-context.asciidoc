[[painless-ingest-processor-context]]
=== Ingest processor context

Use a Painless script in an {es_version}/script-processor.html[ingest processor]
to modify documents upon insertion.

*Variables*

`params` (`Map`, read-only)::
        User-defined parameters passed in as part of the query.

{es_version}/mapping-index-field.html[`ctx['_index']`] (`String`)::
        The name of the index.

{es_version}/mapping-type-field.html[`ctx['_type']`] (`String`)::
        The type of document within an index.

`ctx` (`Map`)::
        Contains extracted JSON in a `Map` and `List` structure for the fields
        that are part of the document.

*Side Effects*

{es_version}/mapping-index-field.html[`ctx['_index']`]::
        Modify this to change the destination index for the current document.

{es_version}/mapping-type-field.html[`ctx['_type']`]::
        Modify this to change the type for the current document.

`ctx` (`Map`)::
        Modify the values in the `Map/List` structure to add, modify, or delete
        the fields of a document.

*Return*

void::
        No expected return value.

*API*

The standard <<painless-api-reference, Painless API>> is available.

*Example*

To use this example first follow the steps outlined in
<<painless-context-examples, context examples>>.

The original seat data gives a date `String` with the format `YYYY-MM-DD` where
the second digit of each the month and the day is optional and gives a time
`String` with the format `HH:MM*` where the second digit of each the hours and
the minutes is optional and the star represents a `String` of either `AM` or
`PM`. The following ingest script processor converts the given date and time
`Strings` into a useful format for storage into a date field. Upon completion of
the script each document will have its `datetime` field value filled in.

The following script is used as the ingest script processor:

[source,Painless]
----
<1> String[] split(String s, char d) {
      int count = 0;

<2>     for (char c : s.toCharArray()) {
          if (c == d) {
              ++count;
          }
      }

<3>     if (count == 0) {
          return new String[] {s};
      }

<4>     String[] r = new String[count + 1];
      int i0 = 0, i1 = 0;
      count = 0;

<5>     for (char c : s.toCharArray()) {
          if (c == d) {
              r[count++] = s.substring(i0, i1);
              i0 = i1 + 1;
          }

          ++i1;
      }

<6>     r[count] = s.substring(i0, i1);

      return r;
  }

<7> String[] dateSplit = split(ctx.date, (char)"-");
  String year = dateSplit[0].trim();
  String month = dateSplit[1].trim();

<8> if (month.length() == 1) {
      month = "0" + month;
  }

  String day = dateSplit[2].trim();

<9> if (day.length() == 1) {
      day = "0" + day;
  }

<10> boolean pm = ctx.time.substring(ctx.time.length() - 2).equals("PM");
<11> String[] timeSplit = split(
          ctx.time.substring(0, ctx.time.length() - 2), (char)":");
  int hours = Integer.parseInt(timeSplit[0].trim());
  int minutes = Integer.parseInt(timeSplit[1].trim());

<12> if (pm) {
      hours += 12;
  }

<13> String dts = year + "-" + month + "-" + day + "T" +
          (hours < 10 ? "0" + hours : "" + hours) + ":" +
          (minutes < 10 ? "0" + minutes : "" + minutes) +
          ":00+08:00";

<14> ZonedDateTime dt = ZonedDateTime.parse(
           dts, DateTimeFormatter.ISO_OFFSET_DATE_TIME);
<15> ctx.datetime = dt.getLong(ChronoField.INSTANT_SECONDS)*1000L;
----
<1> Creates a `split` <<painless-functions, function>> to split a
    <<string-type, `String`>> type value using a <<primitive-types, `char`>>
    type value as the delimiter. This is useful for handling the necessity of
    pulling out the individual pieces of the date and time `Strings` from the
    original seat data since .
<2> The first pass through each `char` in the `String` collects how many new
    `Strings` the original is split into.
<3> Returns the original `String` if there are no instances of the delimiting
    `char`.
<4> Creates an <<array-type, array type>> value to collect the split `Strings`
    into based on the number of `char` delimiters found in the first pass.
<5> The second pass through each `char` in the `String` collects each split
    substring into an array type value of `Strings`.
<6> Collects the last substring into the array type value of `Strings`.
<7> Uses the `split` function to separate the date `String` from the seat data
    into year, month, and day `Strings`. Note the use of a `String` type value
    to `char` type value <<string-character-casting, cast>> as part of the
    second argument since character literals do not exist.
<8> Appends the <<string-literals, string literal>> `"0"` value to a single
    digit month since the format of the seat data allows for this case.
<9> Appends the <<string-literals, string literal>> `"0"` value to a single
    digit day since the format of the seat data allows for this case.
<10> Sets the <<primitive-types, `boolean type`>>
     <<painless-variables, variable>> to `true` if the time `String` is a time
     in the afternoon or evening.
<11> Uses the `split` function to separate the time `String` from the seat data
     into hours and minutes `Strings`. Note the use of the `substring` method to
     remove the `AM` or `PM` portion of the time `String`. Also note the use of
     a `String` type value to `char` type value
     <<string-character-casting, cast>> as part of the second argument since
     character literals do not exist.
<12> If the time `String` is an afternoon or evening value adds the
     <<integer-literals, integer literal>> `12` to the existing hours to move to
     a 24-hour based time.
<13> Builds a new time `String` that is parsable using existing API methods.
<14> Creates a `ZonedDateTime` <<reference-types, reference type>> value by using
     the API method `parse` to parse the new time `String`.
<15> Sets the datetime field `datetime` to the number of milliseconds retrieved
     from the API method `getLong`. Note the use of the `ctx` ingest processor
     context variable to set the field `datetime`. Manipulate each document's
     fields with the `ctx` variable as each document is indexed.

Use the following curl command to create the ingest script processor:

[source,js]
----
PUT /_ingest/pipeline/seats
{
    "description": "update datetime for seats",
    "processors": [
      {
        "script": {
          "source": "String[] split(String s, char d) { int count = 0; for (char c : s.toCharArray()) { if (c == d) { ++count; } } if (count == 0) { return new String[] {s}; } String[] r = new String[count + 1]; int i0 = 0, i1 = 0; count = 0; for (char c : s.toCharArray()) { if (c == d) { r[count++] = s.substring(i0, i1); i0 = i1 + 1; } ++i1; } r[count] = s.substring(i0, i1); return r; } String[] dateSplit = split(ctx.date, (char)\"-\"); String year = dateSplit[0].trim(); String month = dateSplit[1].trim(); if (month.length() == 1) { month = \"0\" + month; } String day = dateSplit[2].trim(); if (day.length() == 1) { day = \"0\" + day; } boolean pm = ctx.time.substring(ctx.time.length() - 2).equals(\"PM\"); String[] timeSplit = split(ctx.time.substring(0, ctx.time.length() - 2), (char)\":\"); int hours = Integer.parseInt(timeSplit[0].trim()); int minutes = Integer.parseInt(timeSplit[1].trim()); if (pm) { hours += 12; } String dts = year + \"-\" + month + \"-\" + day + \"T\" + (hours < 10 ? \"0\" + hours : \"\" + hours) + \":\" + (minutes < 10 ? \"0\" + minutes : \"\" + minutes) + \":00+08:00\"; ZonedDateTime dt = ZonedDateTime.parse(dts, DateTimeFormatter.ISO_OFFSET_DATE_TIME); ctx.datetime = dt.getLong(ChronoField.INSTANT_SECONDS)*1000L;"
        }
      }
    ]
}
----
// CONSOLE