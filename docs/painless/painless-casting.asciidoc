[[painless-casting]]
=== Casting

A cast is the conversion of the value of one type to the equivalent value of an
inferred or specified type. Implicit casts are an inferred operation that
automatically convert values between types within a statement or
<<painless-operators, expression>> when necessary. Explicit casts are a
specified operation that forcefully convert values between types and are
required when an appropriate type for a statement or
<<painless-operators, expression>> cannot be inferred.  If there exists no
equivalent value for the type converted to during a cast operation an error
will occur.  If an implicit cast is given but an explicit cast is required an
error will occur.

*Grammar*
[source,ANTLR4]
----
cast: '(' TYPE ')' expression
----

*Examples*

* Valid general casts.
+
[source,Painless]
----
<1> int i = (int)5L;
<2> Map m = new HashMap();
<3> HashMap hm = (HashMap)m;
----
+
<1> declare `int i`;
    explicit cast value of `long 5` to value of `int 5` -> `int 5`;
    assign value of `int 5` to `i`
<2> declare `Map m`;
    allocate `HashMap` instance -> `HashMap reference`;
    implicit cast value of `HashMap reference` to value of `Map reference`
            -> `Map reference`;
    assign value of `Map reference` to `m`
<3> declare `HashMap hm`;
    access value of `m` -> `Map reference`;
    explicit cast value of `Map reference` to value of `HashMap reference`
            -> `HashMap reference`;
    assign value of `HashMap reference` to `hm`

[[numeric-type-casting]]
==== Numeric Type Casting

A <<primitive-types, numeric type>> cast is the conversion of the value of one
<<primitive-types, numeric type>> to the equivalent value of an inferred or
specified <<primitive-types, numeric type>>. Casts between values of
<<primitive-types, numeric types>> will result in data loss when the value of
the type converted from is larger than the equivalent value of the type
converted to can accommodate. Casts between values of integral types and values
of floating point types will result in precision loss when the value of the
integral type converted from is unable to accurately represent the equivalent
value of the floating point type converted to and vice versa.

The table below illustrates allowed casts between values of
<<primitive-types, numeric types>> and which specific casts must be explicit.
Each cast is read as a conversion of row to column.

|====
|        | byte     | short    | char     | int      | long     | float    | double
| byte   |          | implicit | implicit | implicit | implicit | implicit | implicit
| short  | explicit |          | explicit | implicit | implicit | implicit | implicit
| char   | explicit | explicit |          | implicit | implicit | implicit | implicit
| int    | explicit | explicit | explicit |          | implicit | implicit | implicit
| long   | explicit | explicit | explicit | explicit |          | implicit | implicit
| float  | explicit | explicit | explicit | explicit | explicit |          | implicit
| double | explicit | explicit | explicit | explicit | explicit | explicit |
|====

*Examples*

* Valid <<primitive-types, numeric type>> casts.
+
[source,Painless]
----
<1> int a = 1;
<2> long b = a;
<3> short c = (short)b;
<4> double e = (double)a;
----
+
<1> declare `int a`;
    assign value of `int 1` to `a`
<2> declare `long b`;
    access value of `a` -> `int 1`;
    implicit cast value of `int 1` to value of `long 1` -> `long 1`;
    assign value of `long 1` to `b`
<3> declare `short c`;
    access value of `b` -> `long 1`;
    explicit cast value of `long 1` to value of `short 1` -> `short 1`;
    assign value of `short 1` value to `c`
<4> declare `double e`;
    access value of `a` -> `int 1`;
    explicit cast value of `int 1` to `double 1.0`;
    assign value of `double 1.0` to `e`;
    (note the explicit cast is extraneous, and an implicit cast is valid)
+
* Invalid <<primitive-types, numeric type>> casts resulting in errors.
+
[source,Painless]
----
<1> int a = 1.0; // error
<2> int b = 2;
<3> byte c = b;  // error
----
+
<1> declare `int i`;
    *error* -> cannot implicit cast value of `double 1.0` to value of `int 1`;
    (note an explicit cast is valid)
<2> declare `int b`;
    assign value of `int 2` to `b`
<3> declare byte `c`;
    access value of `b` -> `int 2`;
    *error* -> cannot implicit cast value of `int 2` to value of `byte 2`;
    (note an explicit cast is valid)

[[reference-type-casting]]
==== Reference Type Casting

A <<reference-types, reference type>> cast is the conversion of the value of
one <<reference-types, reference type>> to the equivalent value of an inferred
or specified <<reference-types, reference type>>. Implicit casts between
reference type values are allowed when the reference type being cast *from*
is a descendant of the reference type being cast *to*. Explicit casts between
reference type values are allowed when the reference type being cast *from*
is a descendant of the reference type being cast *to* or the reference type
being cast *to* is a descendant of the reference type being cast *from*.

*Examples*

* Valid <<reference-types, reference type>> casts.
+
[source,Painless]
----
<1> List x;
<2> ArrayList y = new ArrayList();
<3> x = y;
<4> y = (ArrayList)x;
<5> x = (List)y;
----
+
<1> declare `List x`;
    assign default value `null` to `x`
<2> declare `ArrayList y`;
    allocate `ArrayList` instance -> `ArrayList reference`;
    assign value of `ArrayList reference` to `y`;
<3> access value of `y` -> `ArrayList reference`;
    implicit cast value of `ArrayList reference` to value of `List reference`
            -> `List reference`;
    assign value of `List reference` to `x`;
    (note `ArrayList` is a descendant of `List`)
<4> access value of `x` -> `List reference`;
    explicit cast value of `List reference` to value of `ArrayList reference`
            -> `ArrayList reference`;
    assign value of `ArrayList reference` to `y`;
<5> access value of `y` -> `ArrayList reference`;
    explicit cast value of `ArrayList reference` to value of `List reference`
            -> `List reference`;
    assign value of `List reference` to `x`;
    (note the explicit cast is extraneous, and an implicit cast is valid)
+
* Invalid <<reference-types, reference type>> casts resulting in errors.
+
[source,Painless]
----
<1> List x = new ArrayList();
<2> ArrayList y = x;          // error
<3> Map m = (Map)x;           // error
----
+
<1> declare `List x`;
    allocate `ArrayList` instance -> `ArrayList reference`;
    implicit cast value of `ArrayList reference` to value of `List reference`
            -> `List reference`;
    assign value of `List reference` to `x`
<2> declare `ArrayList y`;
    access value of `x` -> `List reference`;
    *error* -> cannot implicit cast `List reference` to `ArrayList reference`;
    (note an explicit cast is valid since `ArrayList` is a descendant of
            `List`)
<3> declare `ArrayList y`;
    access value of `x` -> `List reference`;
    *error* -> cannot explicit cast `List reference` to `Map reference`;
    (note no cast would be valid since neither `List` nor `Map` is a descendant
            of the other)

[[dynamic-type-casting]]
==== Dynamic Type Casting

A <<dynamic-types, dynamic type>> cast is the conversion of the value of one
<<dynamic-types, dynamic type>>, `def`, to the equivalent value of any inferred
or specified other <<painless-types, type>> or vice versa.

Implicit casts from <<painless-types, any type>> value to a
<<dynamic-types, `def` type>> value are always allowed. Explicit casts from
<<painless-types, any type>> value to a <<dynamic-types, `def` type>> value are
allowed but never necessary.

Implicit and explicit casts from a <dynamic-types, `def` type>>, value to
<<painless-types, any type>> value are allowed if and only if the cast is
normally allowed based on the current type value the
<dynamic-types, `def` type>> value represents.

*Examples*

* Examples of casting <<painless-types, any type>> to the
  <<dynamic-types, dynamic type>>.
+
[source,Painless]
----
<1> def d0 = 3;
<2> d0 = new ArrayList();
<3> Object o = new HashMap();
<4> def d1 = o;
<5> int i = d1.size();
----
+
<1> declare `def d0`;
    implicit cast value of `int 3` to `def`;
    assign value of `int 3` to `d0`
<2> allocate `ArrayList` instance -> `ArrayList reference`;
    implicit cast value of `ArrayList reference` to value of `def` -> `def`;
    assign value of `def` to `d0`
<3> declare `Object o`;
    allocate `HashMap` instance -> `HashMap reference`;
    implicit cast value of `HashMap reference` to value of `Object reference`
            -> `Object reference`;
    assign value of `Object reference` to `o`
<4> declare `def d1`;
    access value of `o` -> `Object reference`;
    implicit cast value of `Object reference` to value of `def` -> `def`;
    assign value of `def` to `d1`
<5> declare `int i`;
    access value of `d1` -> `def`;
    implicit cast value of `def` to value of `HashMap reference`
            -> HashMap reference`;
    call `size` on `HashMap reference` -> `int 0`;
    assign value of `int 0` to `i`;
    (note value of `def` was implicit cast to value of `HashMap reference`
            since `HashMap` is the child-most descendant type value that the
            `def` type value represents)
+
* Examples of casting from the <<dynamic-types, dynamic type>> to
  <<painless-types, any type>>.
+
[source,Painless]
----
<1> def d = 1.0;
<2> int i = (int)d;
<3> d = 1;
<4> float f = d;
<5> d = new ArrayList();
<6> List l = d;
----
+
<1> declare `def d`;
    implicit cast value of `double 1.0` to value of `def` -> `def`;
    assign value of `def` to `d`
<2> declare `int i`;
    access value of `d` -> `def`;
    implicit cast value of `def` to value of `double 1.0` -> `double 1.0`;
    explicit cast value of `double 1.0` to value of `int 1` -> `int 1`;
    assign value of `int 1` to `i`;
    (note the explicit cast is necessary since a `double` value cannot be
     converted to an `int` value implicitly)
<3> assign value of `int 1` to `d`;
    (note the switch in the type `d` represents from `double` to `int`)
<4> declare `float i`;
    access value of `d` -> `def`;
    implicit cast value of `def` to value of `int 1` -> `int 1`;
    implicit cast value of `int 1` to value of `float 1.0` -> `float 1.0`;
    assign value of `float 1.0` to `f`
<5> allocate `ArrayList` instance -> `ArrayList reference`;
    assign value of `ArrayList reference` to `d`;
    (note the switch in the type `d` represents from `int` to `ArrayList`)
<6> declare `List l`;
    access value of `d` -> `def`;
    implicit cast value of `def` to value of `ArrayList reference`
            -> `ArrayList reference`;
    implicit cast value of `ArrayList reference` to value of `List reference`
            -> `List reference`;
    assign value of `List reference` to `l`
+
* Examples of errors when casting with the <<dynamic-types, dynamic-type>>.
+
[source,Painless]
----
<1> def d = 1;
<2> short s = d;       // error
<3> d = new HashMap();
<4> List l = d;        // error
----
<1> declare `def d`;
    implicit cast value of `int 1` to value of `def` -> `def`;
    assign value of `def` to `d`
<2> declare `short s`;
    access value of `d` -> `def`;
    implicit cast value of `def` to value of `int 1` -> `int 1`;
    *error* -> cannot implicit cast value of `int 1` to value of `short 1`;
    (note an explicit cast is valid)
<3> allocate `HashMap` instance -> `HashMap reference`;
    implicit cast value of `HashMap reference` to value of `def` -> `def`;
    assign value of `def` to `d`
<4> declare `List l`;
    access value of `d` -> `def`;
    implicit cast value of `def` to value of `HashMap reference`;
    *error* -> cannot implicit cast `HashMap reference` to `List reference`;
    (note no cast would be valid since neither `HashMap` nor `List` is a
            descendant of the other)

[[string-character-casting]]
==== String to Character Casting

Use the <<painless-casting, `cast operator '()'`>> to convert
<<string-type, String>> values into <<primitive-types, char>> values. Use only
<<string-type, String>> values one character in length for this conversion or
an error will occur.

*Examples*

* Casting <<strings, string literals>> into <<primitive-types, char>> values.
+
[source,Painless]
----
<1> char c = (char)"C"
<2> c = (char)'c'
----
+
<1> declare `char c`;
    explicit cast value of `String "C"` to value of `char C` -> `char C`;
    assign value of `char C` to `c`
<2> explicit cast value of `String 'c'` to value of `char c` -> `char c`;
    assign value of `char c` to `c`
+
* Casting a <<string-type, String>> value into a <<primitive-types, char>>
  value.
+
[source,Painless]
----
<1> String s = "s";
<2> char c = (char)s;
----
<1> declare `String s`;
    assign value of `String "s"` to `s`;
<2> declare `char c`
    access value of `s` -> `String "s"`;
    explicit cast value of `String "s"` to value of `char s` -> `char s`;
    assign value of `char s` to `c`

[[boxing-unboxing]]
==== Boxing and Unboxing

Boxing is a special type of cast used to convert a
<<primitive-types, primitive type>> to its corresponding
<<reference-types, reference type>>. Unboxing is the reverse used to convert a
<<reference-types, reference type>> to its corresponding
<<primitive-types, primitive type>>.

Implicit boxing/unboxing occurs during the following
<<painless-operators, operations>>:

* Conversions between the <<dynamic-types, `def` type>> and
  <<primitive-types, primitive types>> will be implicitly boxed/unboxed as
  necessary, though this is referred to as an implicit cast throughout the
  documentation.
* <<method-access, Method>>/function call arguments will be implicitly
  boxed/unboxed as necessary.
* <<primitive-types, Primitive type>> values will be implicitly boxed when a
  <<reference-types, reference type>> <<method-access, method call>> is made on a
  <<primitive-types, primitive type>> value.

Explicit boxing/unboxing is not allowed and will result in an error. Use the
reference type API to explicitly convert primitive type values to their
respective reference type values and vice versa.

*Examples*

* Uses of implicit boxing/unboxing.
+
[source,Painless]
----
<1> List l = new ArrayList();
<2> l.add(1);
<3> Integer I = Integer.valueOf(0);
<4> int i = l.get(i);
----
+
<1> declare `List l`;
    allocate `ArrayList` instance -> `ArrayList reference`;
    assign value of `ArrayList reference` to `l`;
<2> access value of `l` -> `List reference`;
    implicit cast value of `int 1` to value of `def` -> `def`;
    call `add` on `List reference` with arguments (`def`);
    (note internally `int 1` is boxed to `Integer 1` to store as a `def` type
            value)
<3> declare `Integer I`;
    call `valueOf` on `Integer` with arguments of (`int 0`) -> `Integer 0`;
    assign value of `Integer 0` to `I`;
<4> declare `int i`;
    access value of `I` -> `Integer 0`;
    unbox `Integer 0` -> `int 0`;
    access value of `l` -> `List reference`;
    call `get` on `List reference` with arguments (`int 0`) -> `def`;
    implicit cast value of `def` to value of `int 1` -> `int 1`;
    assign value of `int 1` to `i`;
    (note internally `int 1` is unboxed from `Integer 1` when read from a `def`
            type value)
+
* Uses of invalid boxing/unboxing resulting in errors.
+
[source,Painless]
----
<1> Integer x = 1;                   // error
<2> Integer y = (Integer)1;          // error
<3> int a = Integer.valueOf(1);      // error
<4> int b = (int)Integer.valueOf(1); // error
----
+
<1> declare `Integer x`;
    *error* -> cannot implicit box `int 1` to `Integer 1` during assignment
<2> declare `Integer y`;
    *error* -> cannot explicit box `int 1` to `Integer 1` during assignment
<3> declare `int a`;
    call `valueOf` on `Integer` with arguments of (`int 1`) -> `Integer 1`;
    *error* -> cannot implicit unbox `Integer 1` to `int 1` during assignment
<4> declare `int a`;
    call `valueOf` on `Integer` with arguments of (`int 1`) -> `Integer 1`;
    *error* -> cannot explicit unbox `Integer 1` to `int 1` during assignment

[[promotion]]
==== Promotion

Promotion is when a value is converted into either a certain type or when
multiple values are converted into equivalent types for use during an
<<painless-operators, operation>>. Each <<painless-operators, operation>> that
requires promotion will have a promotion table that shows all allowed
conversions. Values can be promoted to the `def` type at compile-time; however,
at run-time, the promoted type of value is derived from what the `def` type
value represents.

*Examples*

* Uses of promotion.
+
[source,Painless]
----
<1> double d = 2 + 2.0;
<2> def x = 1;
<3> float f = x + 2.0F;
----
<1> declare `double d`;
    promote value of `int 2` and value of `double 2.0 @0` -> `double 2.0 @0`;
    implicit cast value of `int 2` to value of `double 2.0 @1`
            -> `double 2.0 @1`;
    add `double 2.0 @1` and `double 2.0 @0` -> `double 4.0`;
    assign value of `double 4.0` to `d`
<2> declare `def x`;
    implicit cast value of `int 1` to value of `def` -> `def`;
    assign value of `def` to `x`;
<3> declare `float f`;
    access value of `x` -> `def`;
    implicit cast value of `def` to value of `int 1` -> `int 1`;
    promote value of `int 1` and value of `float 2.0` -> `float 2.0`;
    implicit cast value of `int 1` to value of `float 1.0` -> `float `1.0`;
    add `float 1.0` and `float 2.0` -> `float 3.0`;
    assign value of `float 3.0` to `f`;
    (note this example illustrates promotion done at run-time as promotion
     done at compile-time would have resolved to a `def` type value)