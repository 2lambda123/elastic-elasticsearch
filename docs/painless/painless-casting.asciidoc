[[painless-casting]]
=== Casting

A cast is the conversion of the value of one type to the equivalent value of an
inferred or specified type. Implicit casts are an inferred operation that
automatically convert values between types within a statement or
<<painless-operators, expression>> when necessary. Explicit casts are a
specified operation that forcefully convert values between types and are
required when an appropriate type for a statement or
<<painless-operators, expression>> cannot be inferred.  If there exists no
equivalent value for the type converted to during a cast operation an error
will occur.  If an implicit cast is given but an explicit cast is required an
error will occur.

*Grammar*
[source,ANTLR4]
----
cast: '(' TYPE ')' expression
----

*Examples*

* General casts.
+
[source,Painless]
----
<1> int i = (int)5L;
<2> Map m = new HashMap();
<3> HashMap hm = (HashMap)m;
----
+
<1> declare `int i`;
    explicitly cast `long 5` to `int`;
    assign `5` to `i`
<2> declare `Map m`;
    implicit cast new `HashMap` to `Map`;
    assign `Map` value to `m`
<3> declare `HashMap hm`;
    explicit cast `Map m` to `HashMap`;
    assign `Map` value to `hm`

[[numeric-casting]]
==== Numeric Casting

A numeric cast is the conversion of the value of one
<<primitive-types, numeric type>> to the equivalent value of an inferred or
specified <<primitive-types, numeric type>>. Casts between values of
<<primitive-types, numeric types>> will result in data loss when the value of
the type converted from is larger than the equivalent value of the type
converted to can accommodate. Casts between values of integral types and values
of floating point types will result in precision loss when the value of the
integral type converted from is unable to accurately represent the equivalent
value of the floating point type converted to and vice versa.

The table below illustrates legal casts between values of
<<primitive-types, numeric types>> and if the cast must be explicit.  Each cast
is read as a conversion of row to column.

|====
|        | byte     | short    | char     | int      | long     | float    | double
| byte   |          | implicit | implicit | implicit | implicit | implicit | implicit
| short  | explicit |          | explicit | implicit | implicit | implicit | implicit
| char   | explicit | explicit |          | implicit | implicit | implicit | implicit
| int    | explicit | explicit | explicit |          | implicit | implicit | implicit
| long   | explicit | explicit | explicit | explicit |          | implicit | implicit
| float  | explicit | explicit | explicit | explicit | explicit |          | implicit
| double | explicit | explicit | explicit | explicit | explicit | explicit |
|====

*Examples*

* Valid numeric casts.
+
[source,Painless]
----
<1> int a = 1;
<2> long b = a;
<3> short c = (short)b;
<4> double e = (double)a;
----
+
<1> declare `int a`;
    assign `1` to `a`
<2> declare `long b`;
    implicit cast `long b` to `int`;
    assign `int` value to `b`
<3> declare `short c`;
    explicit cast `long b` to `short`;
    assign `short` value to `c`
<4> declare `double e`;
    explicit cast `int a` to `double`;
    assign `double` value to `e`;
    note this cast is extraneous and can be implicit
+
* Invalid numeric casts resulting in errors.
+
[source,Painless]
----
<1> int a = 1.0;
<2> int b = 2;
<3> byte c = b;
----
+
<1> declare `int i`;
    *error*: cannot implicitly cast `double 1.0` to `int`
<2> declare `int b`;
    assign `int 2` to `b`;

[[reference-casting]]
==== Reference Casting

A reference type can be implicitly cast to another reference type as long as
the type being cast _from_ is a descendant of the type being cast _to_.  A
reference type can be explicitly cast _to_ if the type being cast to is a
descendant of the type being cast _from_.

*Examples:*
[source,Java]
----
List x;                        // Declare List variable x
ArrayList y = new ArrayList(); // Declare ArrayList variable y and assign it a
                               //   newly allocated ArrayList [1]
x = y;                         // Assign Arraylist y to List x using an
                               //   implicit cast
y = (ArrayList)x;              // Explicitly cast List x to an ArrayList and
                               //  assign it to ArrayList y
x = (List)y;                   // Set List x to ArrayList y using an explicit
                               //   cast (the explicit cast is not necessary)
y = x;                         // ERROR: List x cannot be implicitly cast to
                               //   an ArrayList, an explicit cast is required
Map m = y;                     // ERROR: Cannot implicitly or explicitly cast [2]
                               //   an ArrayList to a Map, no relationship
                               //   exists between the two types.
----
[1] `ArrayList` is a descendant of the `List` type.
[2] `Map` is unrelated to the `List` and `ArrayList` types.

[[def-type-casting]]
==== def Type Casting
All primitive and reference types can always be implicitly cast to
`def`. While it is possible to explicitly cast to `def`, it is not necessary.

However, it is not always possible to implicitly cast a `def` to other
primitive and reference types. An explicit cast is required if an explicit
cast would normally be required between the non-def types.


*Examples:*
[source,Java]
----
def x;          // Declare def variable x and set it to null
x = 3;          // Set the def variable x to the literal 3 with an implicit
                //   cast from int to def
double a = x;   // Declare double variable a and set it to def variable x,
                //   which contains a double
int b = x;      // ERROR: Results in a run-time error because an explicit cast is
                //   required to cast from a double to an int
int c = (int)x; // Declare int variable c, explicitly cast def variable x to an
                //   int, and assign x to c
----

[[boxing-unboxing]]
==== Boxing and Unboxing

Boxing is where a cast is used to convert a primitive type to its corresponding
reference type. Unboxing is the reverse, converting a reference type to the
corresponding primitive type.

There are two places Painless performs implicit boxing and unboxing:

* When you call methods, Painless automatically boxes and unboxes arguments
so you can specify either primitive types or their corresponding reference
types.
* When you use the `def` type, Painless automatically boxes and unboxes as
needed when converting to and from `def`.

The casting operator does not support any way to explicitly box a primitive
type or unbox a reference type.

If a primitive type needs to be converted to a reference type, the Painless
reference type API supports methods that can do that. However, under normal
circumstances this should not be necessary.

*Examples:*
[source,Java]
----
Integer x = 1;               // ERROR: not a legal implicit cast
Integer y = (Integer)1;      // ERROR: not a legal explicit cast
int a = new Integer(1);      // ERROR: not a legal implicit cast
int b = (int)new Integer(1); // ERROR: not a legal explicit cast
----

[[promotion]]
==== Promotion

Promotion is where certain operations require types to be either a minimum
numerical type or for two (or more) types to be equivalent.
The documentation for each operation that has these requirements
includes promotion tables that describe how this is handled.

When an operation promotes a type or types, the resultant type
of the operation is the promoted type.  Types can be promoted to def
at compile-time; however, at run-time, the resultant type will be the
promotion of the types the `def` is representing.

*Examples:*
[source,Java]
----
2 + 2.0     // Add the literal int 2 and the literal double 2.0. The literal
            //   2 is promoted to a double and the resulting value is a double.

def x = 1;  // Declare def variable x and set it to the literal int 1 through
            //   an implicit cast
x + 2.0F    // Add def variable x and the literal float 2.0.
            // At compile-time the types are promoted to def.
            // At run-time the types are promoted to float.
----
