[[painless-casting]]
=== Casting

A cast is the conversion of the value of one type to the equivalent value of an
inferred or specified type. Implicit casts are an inferred operation that
automatically convert values between types within a statement or
<<painless-operators, expression>> when necessary. Explicit casts are a
specified operation that forcefully convert values between types and are
required when an appropriate type for a statement or
<<painless-operators, expression>> cannot be inferred.  If there exists no
equivalent value for the type converted to during a cast operation an error
will occur.  If an implicit cast is given but an explicit cast is required an
error will occur.

*Grammar*
[source,ANTLR4]
----
cast: '(' TYPE ')' expression
----

*Examples*

* Valid general casts.
+
[source,Painless]
----
<1> int i = (int)5L;
<2> Map m = new HashMap();
<3> HashMap hm = (HashMap)m;
----
+
<1> declare `int i`;
    explicit cast value of `long 5` to value of `int 5` -> `int 5`;
    assign `int 5` to `i`
<2> declare `Map m`;
    allocate `HashMap` instance -> `HashMap reference`;
    implicit cast value of `HashMap reference` to value of `Map reference`
            -> `Map reference`;
    assign value of `Map reference` to `m`
<3> declare `HashMap hm`;
    access value of `m` -> `Map reference`;
    explicit cast value of `Map reference` to value of `HashMap reference`
            -> `HashMap reference`;
    assign value of `HashMap reference` to `hm`

[[numeric-type-casting]]
==== Numeric Type Casting

A <<primitive-types, numeric type>> cast is the conversion of the value of one
<<primitive-types, numeric type>> to the equivalent value of an inferred or
specified <<primitive-types, numeric type>>. Casts between values of
<<primitive-types, numeric types>> will result in data loss when the value of
the type converted from is larger than the equivalent value of the type
converted to can accommodate. Casts between values of integral types and values
of floating point types will result in precision loss when the value of the
integral type converted from is unable to accurately represent the equivalent
value of the floating point type converted to and vice versa.

The table below illustrates allowed casts between values of
<<primitive-types, numeric types>> and which specific casts must be explicit.
Each cast is read as a conversion of row to column.

|====
|        | byte     | short    | char     | int      | long     | float    | double
| byte   |          | implicit | implicit | implicit | implicit | implicit | implicit
| short  | explicit |          | explicit | implicit | implicit | implicit | implicit
| char   | explicit | explicit |          | implicit | implicit | implicit | implicit
| int    | explicit | explicit | explicit |          | implicit | implicit | implicit
| long   | explicit | explicit | explicit | explicit |          | implicit | implicit
| float  | explicit | explicit | explicit | explicit | explicit |          | implicit
| double | explicit | explicit | explicit | explicit | explicit | explicit |
|====

*Examples*

* Valid <<primitive-types, numeric type>> casts.
+
[source,Painless]
----
<1> int a = 1;
<2> long b = a;
<3> short c = (short)b;
<4> double e = (double)a;
----
+
<1> declare `int a`;
    assign `int 1` to `a`
<2> declare `long b`;
    access value of `a` -> `int 1`;
    implicit cast value of `int 1` to value of `long 1` -> `long 1`;
    assign value of `long 1` to `b`
<3> declare `short c`;
    access value of `b` -> `long 1`;
    explicit cast value of `long 1` to value of `short 1` -> `short 1`;
    assign `short 1` value to `c`
<4> declare `double e`;
    access value of `a` -> `int 1`;
    explicit cast value of `int 1` to `double 1.0`;
    assign value of `double 1.0` to `e`;
    (note the explicit cast is extraneous, and an implicit cast is valid)
+
* Invalid <<primitive-types, numeric type>> casts resulting in errors.
+
[source,Painless]
----
<1> int a = 1.0; // error
<2> int b = 2;
<3> byte c = b;  // error
----
+
<1> declare `int i`;
    *error* -> cannot implicit cast value of `double 1.0` to value of `int 1`;
    (note an explicit cast is valid)
<2> declare `int b`;
    assign `int 2` to `b`
<3> declare byte `c`;
    access value of `b` -> `int 2`;
    *error* -> cannot implicit cast value of `int 2` to value of `byte 2`;
    (note an explicit cast is valid)

[[reference-type-casting]]
==== Reference Type Casting

A <<reference-types, reference type>> cast is the conversion of the value of
one <<reference-types, reference type>> to the equivalent value of an inferred
or specified <<reference-types, reference type>>. Implicit casts between
reference type values are allowed when the reference type being cast *from*
is a descendant of the reference type being cast *to*. Explicit casts between
reference type values are allowed when the reference type being cast *from*
is a descendant of the reference type being cast *to* or the reference type
being cast *to* is a descendant of the reference type being cast *from*.

*Examples*

* Valid <<reference-types, reference type>> casts.
+
[source,Painless]
----
<1> List x;
<2> ArrayList y = new ArrayList();
<3> x = y;
<4> y = (ArrayList)x;
<5> x = (List)y;
----
+
<1> declare `List x`;
    assign default value `null` to `x`
<2> declare `ArrayList y`;
    allocate `ArrayList` instance -> `ArrayList reference`;
    assign value of `ArrayList reference` to `y`;
<3> access value of `y` -> `ArrayList reference`;
    implicit cast value of `ArrayList reference` to value of `List reference`
            -> `List reference`;
    assign `List reference` to `x`;
    (note `ArrayList` is a descendant of `List`)
<4> access value of `x` -> `List reference`;
    explicit cast value of `List reference` to value of `ArrayList reference`
            -> `ArrayList reference`;
    assign `ArrayList reference` to `y`;
<5> access value of `y` -> `ArrayList reference`;
    explicit cast value of `ArrayList reference` to value of `List reference`
            -> `List reference`;
    assign `List reference` to `x`;
    (note the explicit cast is extraneous, and an implicit cast is valid)
+
* Invalid <<reference-types, reference type>> casts resulting in errors.
+
[source,Painless]
----
<1> List x = new ArrayList();
<2> ArrayList y = x;          // error
<3> Map m = (Map)x;           // error
----
+
<1> declare `List x`;
    allocate `ArrayList` instance -> `ArrayList reference`;
    implicit cast value of `ArrayList reference` to value of `List reference`
            -> `List reference`;
    assign `List reference` to `x`
<2> declare `ArrayList y`;
    access value of `x` -> `List reference`;
    *error* -> cannot implicit cast `List reference` to `ArrayList reference`;
    (note an explicit cast is valid since `ArrayList` is a descendant of
            `List`)
<3> declare `ArrayList y`;
    access value of `x` -> `List reference`;
    *error* -> cannot explicit cast `List reference` to `Map reference`;
    (note no cast would be valid since neither `List` nor `Map` is a descendant
            of the other)

[[dynamic-type-casting]]
==== Dynamic Type Casting

A <<dynamic-types, dynamic type>> cast is the conversion of the value of one
<<dynamic-types, dynamic type>>, `def`, to the equivalent value of any inferred
or specified other <<painless-types, type>> or vice versa.

Implicit casts from <<painless-types, any type>> value to a
<<dynamic-types, `def` type>> value are always allowed. Explicit casts from
<<painless-types, any type>> value to a <<dynamic-types, `def` type>> value are
allowed but never necessary.

Implicit and explicit casts from a <dynamic-types, `def` type>>, value to
<<painless-types, any type>> value are allowed if and only if the cast is
normally allowed based on the current type value the
<dynamic-types, `def` type>> value represents.

*Examples*
+
* Examples of casting <<painless-types, any type>> to the
  <<dynamic-types, dynamic type>>.
+
[source,Painless]
----
<1> def d0 = 3;
<2> d0 = new ArrayList();
<3> Object o = new HashMap();
<4> def d1 = o;
<5> int i = d1.size();
----
+
<1> declare `def d0`;
    implicit cast value of `int 3` to `def`
    assign value of `int 3` to `d0`
<2> allocate `ArrayList` instance -> `ArrayList reference`;
    implicit cast value of `ArrayList reference` to value of `def` -> `def`;
    assign value of `def` to `d0`
<3> declare `Object o`;
    allocate `HashMap` instance -> `HashMap reference`;
    implicit cast value of `HashMap reference` to value of `Object reference`
            -> `Object reference`;
    assign value of `Object reference` to `o`
<4> declare `def d1`;
    access value of `o` -> `Object reference`;
    implicit cast value of `Object reference` to value of `def` -> `def`;
    assign `def` to `d1`
<5> declare `int i`;
    access value of `d1` -> `def`;
    implicit cast value of `def` to value of `HashMap reference`
            -> HashMap reference`;
    call `size` on `HashMap reference` -> `int 0`;
    assign `int 0` to `i`;
    (note value of `def` was implicit cast to value of `HashMap reference`
            since `HashMap` is the child-most descendant type value that the
            `def` type value represents)
+
* Examples of casting from the <<dynamic-types, dynamic type>> to
  <<painless-types, any type>>.
+
[source,Painless]
----
<1> def d = 1.0;
<2> int i = (int)d;
<3> d = 1;
<4> float f = d;
<5> d = new ArrayList();
<6> List l = d;
----
+
<1> declare `def d`;
    implicit cast value of `double 1.0` to value of `def` -> `def`;
    assign value of `def` to `d`
<2> declare `int i`;
    access value of `d` -> `def`;
    implicit cast value of `def` to value of `double 1.0` -> `double 1.0`;
    explicit cast value of `double 1.0` to value of `int 1` -> `int 1`;
    assign value of `int 1` to `i`;
    (note the explicit cast is necessary since a `double` value cannot be
     converted to an `int` value implicitly)
<3> assign value of `int 1` to `d`;
    (note the switch in the type `d` represents from `double` to `int`)
<4> declare `float i`;
    access value of `d` -> `def`;
    implicit cast value of `def` to value of `int 1` -> `int 1`;
    implicit cast value of `int 1` to value of `float 1.0` -> `float 1.0`;
    assign value of `float 1.0` to `f`
<5> allocate `ArrayList` instance -> `ArrayList reference`;
    assign value of `ArrayList reference` to `d`;
    (note the switch in the type `d` represents from `int` to `ArrayList`)
<6> declare `List l`;
    access value of `d` -> `def`;
    implicit cast value of `def` to value of `ArrayList reference`
            -> `ArrayList reference`;
    implicit cast value of `ArrayList reference` to value of `List reference`
            -> `List reference`;
    assign value of `List reference` to `l`
+
* Examples of errors casting with <<dynamic-types, dynamic-type>>.
+
[source,Painless]
----
<1> def d = 1;
<2> short s = d;       // error
<3> d = new HashMap();
<4> List l = d;        // error
----
<1> declare `def d`;
    implicit cast value of `int 1` to value of `def` -> `def`;
    assign value of `def` to `d`
<2> declare `short s`;
    access value of `d` -> `def`;
    implicit cast value of `def` to value of `int 1` -> `int 1`;
    *error* -> cannot implicit cast value of `int 1` to value of `short 1`;
    (note an explicit cast is valid)
<3> allocate `HashMap` instance -> `HashMap reference`;
    implicit cast value of `HashMap reference` to value of `def` -> `def`;
    assign value of `def` to `d`
<4> declare `List l`;
    access value of `d` -> `def`;
    implicit cast value of `def` to value of `HashMap reference`;
    *error* -> cannot implicit cast `HashMap reference` to `List reference`;
    (note no cast would be valid since neither `HashMap` nor `List` is a
            descendant of the other)

[[string-character-casting]]
==== String to Character Casting

Use the <<painless-casting, `cast operator '()'`>> to convert
<<string-type, String>> values into <<primitive-types, char>> values. Use only
<<string-type, String>> values one character in length for this conversion or
an error will occur.

*Examples*

* Casting <<strings, string literals>> into <<primitive-types, char>> values.
+
[source,Painless]
----
<1> char c = (char)"C"
<2> c = (char)'c'
----
+
<1> a
<2> a
+
* Casting a <<string-type, String>> value into a <<primitive-types, char>>
  value.
+
[source,Painless]
----
<1> String s = "s";
<2> char c = (char)s;
----
<1> a
<2> a

[[boxing-unboxing]]
==== Boxing and Unboxing

Boxing is where a cast is used to convert a primitive type to its corresponding
reference type. Unboxing is the reverse, converting a reference type to the
corresponding primitive type.

There are two places Painless performs implicit boxing and unboxing:

* When you call methods, Painless automatically boxes and unboxes arguments
so you can specify either primitive types or their corresponding reference
types.
* When you use the `def` type, Painless automatically boxes and unboxes as
needed when converting to and from `def`.

The casting operator does not support any way to explicitly box a primitive
type or unbox a reference type.

If a primitive type needs to be converted to a reference type, the Painless
reference type API supports methods that can do that. However, under normal
circumstances this should not be necessary.

*Examples:*
[source,Java]
----
Integer x = 1;               // ERROR: not a legal implicit cast
Integer y = (Integer)1;      // ERROR: not a legal explicit cast
int a = new Integer(1);      // ERROR: not a legal implicit cast
int b = (int)new Integer(1); // ERROR: not a legal explicit cast
----

[[promotion]]
==== Promotion

Promotion is where certain operations require types to be either a minimum
numerical type or for two (or more) types to be equivalent.
The documentation for each operation that has these requirements
includes promotion tables that describe how this is handled.

When an operation promotes a type or types, the resultant type
of the operation is the promoted type.  Types can be promoted to def
at compile-time; however, at run-time, the resultant type will be the
promotion of the types the `def` is representing.

*Examples:*
[source,Java]
----
2 + 2.0     // Add the literal int 2 and the literal double 2.0. The literal
            //   2 is promoted to a double and the resulting value is a double.

def x = 1;  // Declare def variable x and set it to the literal int 1 through
            //   an implicit cast
x + 2.0F    // Add def variable x and the literal float 2.0.
            // At compile-time the types are promoted to def.
            // At run-time the types are promoted to float.
----