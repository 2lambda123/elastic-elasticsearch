[[painless-field]]
=== Accessing document values in Painless

Document values are available for fields using the `Field` object.

The `Field` object is an `Iterable` that supports the following API
String getName();
boolean isEmpty();
int size();

Inherited from `Iterable`
Iterator<T> iterator();
void forEach(Consumer<? super T> action);


Each mapped data type has it's own `Field` class.  Those classes implement methods of the form:

`{type} get({type} defaultValue)` and
`{type} get(int index, {type} defaultValue)`

Where type is either a reference type or a primitive type based on the most appropriate painless type for the mapped field type.  While you can use boxing, it will be slower so we recommend using primitive types where possible.

Real life data is messy.  When searching within a single index, a field may have one, many or no values.  When searching accross indices via an index alias, an field may be not be mapped in some of the target indices.  A common way of handling missing values is to use a default sentile value.  For example, for a keyword field, you may use empty string as a default value.

`def keyword = field('myKeyword').get('missing')`

or, more succicently, you can use the dollar-get shortcut

`def keyword = $('myKeyword', 'missing')`

The variable `keyword` will have the contents of the first value (index zero) of the `myKeyword` field, or, if that field is empty or unmapped, it will have the value `missing`.

So, for example, if you have a runtime field that creates a record for every cloud resouce owner, you can do something like:


[source,Painless]
----
emit($('user', 'unknown') + ':' + $('team', 'unknown'))
----

Summing metric values:


[source,Painless]
----
int total = 0; for (String metric : ['metricA', 'metricB', 'metricC']) { total += $(metric, 0); }
----

Or perhaps you are transitioning from one field to another, you can use the old field as the fallback for the new field:

[source,Painless]
----
emit($('newField', $('oldField', 'missing')))`
----

Of course, you can iterate over multivalued fields.

[source,Painless]
----
for (String team : field('team')) {
	if (team == 'accounting') {
	  emit(true);
	  return;
	}
}
emit(false);
----

Of course, you can explicitly check if a field has a value.

[source,Painless]
----
Field f = field('model');
if (f.empty) {
	return;
}
----

In ingestion contexts, when you call `field('<path>')`, you will get a `WriteField`, which is an implementation of `Field` with helper methods useful in ingest contexts.

`WriteField` has the following API:

* String getName() - Get the path represented by this Field
* boolean exists() - Does the path exist?
* WriteField move(def) - Move this path to another path in the map, target must be empty
* WriteField overwrite(def) - Move this path to another path, overwriting the path destination
* void remove() - Remove this Field
* WriteField set(def) - Set the value
* WriteField append(def) - Append a value to this path.  Creates a list at the field if necessary
* boolean isEmpty() - Does this field have no values?
* int size() - The number of values in the field
* Iterator iterator() - Get an iterator for the values
* def get(def) - Get the first value at the field, or the default if the field is empty
* def get(int, def) - Get the value at the given index, or the default if there is no value at that index
* boolean hasValue(Predicate) - Is there any value in the field for which the predicate is true?
* WriteField transform(Function) - Transform every value in the field using the function
* WriteField deduplicate() - Remove duplicate values from the field
* WriteField removeValuesIf(Predicate) - Remove values from the field if predicate matches
* WriteField removeValue(int) - Remove the value at the index if it exists

