[[painless-operators-general]]
=== Operators: General

[[precedence]]
==== Precedence

An expression encapsulated within a *precedence operator* overrides
existing precedence relationships between operators and is evaluated
prior to other expressions in inward-to-outward order. Use the *precedence
operator* to guarantee the order of evaluation for an expression.

*Grammar*
[source,ANTLR4]
----
precedence: '(' expression ')';
----

*Examples*

* Uses of the *precedence operator*.
+
[source,Painless]
----
<1> int x = (5+4)*6;
<2> int y = 12/(x-50);
----
+
<1> declare `int x`;
    add `int 5` and `int 4` -> `int 9`;
    multiply `int 9` and `int 6` -> `int 54`;
    store `int 54` to `x`;
    (note the add is evaluated before the multiply due to the *precedence
            operator*)
<2> declare `int y`;
    load from `x` -> `int 54`;
    subtract `int 50` from `int 54` -> `int 4`;
    divide `int 12` by `int 4` -> `int 3`;
    store `int 3` to `y`;
    (note the subtract is evaluated before the divide due to the *precedence
            operator*)

[[function-call]]
==== Function Call

A function call is defined within a script.  Use the *function call operator* to
call an existing function.

*Grammar*
[source,ANTLR4]
----
function_call: ID '(' ( expression (',' expression)* )? ')'';
----

*Examples*

* Use of the *function call operator*.
+
[source,Painless]
----
<1> int add(int x, int y) {
      return x + y;
  }

<2> int z = add(1, 2);
----
+
<1> define function `add` that returns `int` and has parameters (`int x`,
            `int y`)
<2> declare `int z`;
    call `add` with arguments (`int 1`, `int 2`) -> `int 3`;
    store `int 3` to `z`

[[cast]]
==== Cast

An explicit cast converts the value of an original type to the equivalent value
of a target type forcefully as an operation.  Use the *cast operator* to specify
an explicit cast. Refer to <<painless-casting, casting>> for more information.

[[conditional]]
==== Conditional

A conditional consists of three expressions. The first expression is evaluated
with an expected boolean result type. If the first expression evaluates to true
then the second expression will be evaluated.  If the first expression evaluates
to false then the third expression will be evaluated. The second and third
expressions will be <<promotion, promoted>> if the evaluated values are not the
same type. Use the *conditional operator* as a shortcut to avoid the need for a
full if/else branch in certain expressions.

*Errors*

* If the first expression does not evaluate to a boolean type value.
* If the values for the second and third expressions cannot be promoted.

*Grammar*
[source,ANTLR4]
----
conditional: expression '?' expression ':' expression;
----

*Promotion*

[cols="<1,^1,^1,^1,^1,^1,^1,^1,^1,^1"]
|====
|           | byte   | short  | char   | int    | long   | float  | double | Reference | def
| byte      | int    | int    | int    | int    | long   | float  | double | -         | def
| short     | int    | int    | int    | int    | long   | float  | double | -         | def
| char      | int    | int    | int    | int    | long   | float  | double | -         | def
| int       | int    | int    | int    | int    | long   | float  | double | -         | def
| long      | long   | long   | long   | long   | long   | float  | double | -         | def
| float     | float  | float  | float  | float  | float  | float  | double | -         | def
| double    | double | double | double | double | double | double | double | -         | def
| Reference | -      | -      | -      | -      | -      | -      | -      | Object @  | def
| def       | def    | def    | def    | def    | def    | def    | def    | def       | def
|====

@ If the two reference type values are the same then this promotion will not
occur.

*Examples*

* Uses of the *conditional operator*.
+
[source,Painless]
----
<1> boolean b = true;
<2> int x = b ? 1 : 2;
<3> List y = x > 1 ? new ArrayList() : null;
<4> def z = x < 2 ? x : 2.0;
----
+
<1> declare `boolean b`;
    store `boolean true` to `b`
<2> declare `int x`;
    load from `b` -> `boolean true`
    evaluate 1st expression: `int 1` -> `int 1`;
    store `int 1` to `x`
<3> declare `List y`;
    load from `x` -> `int 1`;
    `int 1` greater than `int 1` -> `boolean false`;
    evaluate 2nd expression: `null` -> `null`;
    store `null` to `y`;
<4> declare `def z`;
    load from `x` -> `int 1`;
    `int 1` less than `int 2` -> `boolean true`;
    evaluate 1st expression: load from `x` -> `int 1`;
    promote `int 1` and `double 2.0`: result `double`;
    implicit cast `int 1` to `double 1.0` -> `double 1.0`;
    implicit cast `double 1.0` to `def` -> `def`;
    store `def` to `z`;

[[assignment]]
==== Assignment

Assignment can be used to assign a value to a variable.  See Variable Assignment [MARK] for more information.

[[compound-assignment]]
==== Compound Assignment

Compound assignment can be used as a shortcut for an assignment where a binary operation would occur between the variable/field as the left-side expression and a separate right-side expression.  The variable/field and right-side expression must be of appropriate types for the specific operation or an error will occur.  A downcast may be necessary for certain operations to be able to assign the result back into the variable/field and will happen implicitly.  The format is a variable/field, followed by one of the compound assignment operators, finished with an expression.

*Grammar:*
[source,ANTLR4]
----
compund_assignment: ID (. ID)? '$=' expression; // $ is a placeholder for the operation symbol
----

A compound assignment is equivalent to the expression below where V is the variable/field and T is the type of variable/member.

[source,Java]
----
V = (T)(V op expression);
----

The table below shows all available operators for compound assignment.  All operators follow any casting/promotion rules according to their regular definition.

|====
|Operator|Compound Symbol
|Multiplication|*=
|Division|/=
|Remainder|%=
|String Concatenation|+=
|Addition|+=
|Subtraction|-=
|Left Shift|<<=
|Right Shift|>>=
|Unsigned Right Shift|>>>=
|Bitwise And|&=
|Boolean And|&=
|Bitwise Xor|^=
|Boolean Xor|^=
|Bitwise Or|\|=
|Boolean Or|\|=
|====

*Examples:*
[source,Java]
----
int i = 10;         // declares the variable i and sets it to constant int 10
i *= 2;             // multiplies i by 2 -- i = (int)(i * 2)
i /= 5;             // divides i by 5 -- i = (int)(i / 5)
i %= 3;             // gives the remainder for i/3 -- i = (int)(i % 3)
i += 5;             // adds 5 to i -- i = (int)(i + 5)
i -= 5;             // subtracts 5 from i -- i = (int)(i - 5)
i <<= 2;            // left shifts i by 2 -- i = (int)(i << 2)
i >>= 1;            // right shifts i by 1 -- i = (int)(i >> 1)
i >>>= 1;           // unsigned right shifts i by 1 -- i = (int)(i >>> 1)
i &= 15;            // ands i with 15 -- i = (int)(i & 15)
i ^= 12;            // xors i with 12 -- i = (int)(i ^ 2)
i |= 4;             // ors i with 4 -- i = (int)(i | 4)

boolean b = true;   // declares the boolean variable b and sets it to the constant boolean true
b &= false;         // ands b with false -- b = (boolean)(b & false)
b ^= false;         // xors b with false -- b = (boolean)(b & false)
b |= true;          // ors be with true -- b = (boolean)(b & false)

def x = 'compound'; // declares the def variable x and sets it to the constant String 'compound'
x += ' assignment'; // string concatenates ' assignment' to x -- x = (String)(x + ' assignment')
----