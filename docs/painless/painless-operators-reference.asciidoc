[[painless-operators-reference]]
=== Operators: Reference

[[method-call-operator]]
==== Method Call

Use the *method call operator* to call a member method on a
<<reference-types, reference type>> value. Implicit
<<boxing-unboxing, boxing/unboxing>> is evaluated as necessary per argument.
When a method call is made on a `def` type value, the parameters and return
type value are considered to also be of the `def` type and are evaluated at
run-time.

An overloaded method is one that shares the same name with two or more methods.
A method is overloaded based on arity where the same name is re-used for
multiple methods as long as the number of parameters differs.

*Errors*

* If the reference type value is `null`.
* If the member method name doesn't exist for a given reference type value.
* If the number of arguments passed in is different from the number of specified
  parameters.
* If the arguments cannot be implicitly cast or implicitly boxed/unboxed to the
  correct type values for the parameters.

*Grammar*

[source,ANTLR4]
----
method_call: callable '.' ID arguments;
callable: (variable | field | type);
arguments: '(' (expression (',' expression)*)? ')';
----

*Examples*

* Uses of method calls.
+
[source,Painless]
----
<1> Map m = new HashMap();
<2> m.put(1, 2);
<3> int z = m.get(1);
<4> def d = new ArrayList();
<5> d.add(1);
<6> int i = Integer.parseInt(d.get(0).toString());
----
+
<1> declare `Map m`;
    allocate `HashMap` instance -> `HashMap reference`;
    store `HashMap reference` to `m`
<2> load from `m` -> `Map reference`;
    implicit cast `int 1` to `def` -> `def`;
    implicit cast `int 2` to `def` -> `def`;
    call `put` on `Map reference` with arguments (`int 1`, `int 2`)
<3> declare `int z`;
    load from `m` -> `Map reference`;
    call `get` on `Map reference` with arguments (`int 1`) -> `def`;
    implicit cast `def` to `int 2` -> `int 2`;
    store `int 2` to `z`
<4> declare `def d`;
    allocate `ArrayList` instance -> `ArrayList reference`;
    implicit cast `ArrayList` to `def` -> `def`;
    store `def` to `d`
<5> load from `d` -> `def`;
    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`
    call `add` on `ArrayList reference` with arguments (`int 1`);
<6> declare `int i`;
    load from `d` -> `def`;
    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`
    call `get` on `ArrayList reference` with arguments (`int 1`) -> `def`;
    implicit cast `def` to `Integer 1 reference` -> `Integer 1 reference`;
    call `toString` on `Integer 1 reference` -> `String '1'`;
    call `parseInt` on `Integer` with arguments (`String '1'`) -> `int 1`;
    store `int 1` in `i`;

[[field-access-operator]]
==== Field Access

Use the *field access operator* to store a value to or load a value from a
<<reference-types, reference type>> member field.

*Errors*

* If the reference type value is `null`.
* If the member field name doesn't exist for a given reference type value.

*Grammar*

[source,ANTLR4]
----
field_access: accessible '.' ID;
accessible: (variable | field | type);
----

*Examples*

The examples use the following reference type definition:

----
name:
  Example

non-static member fields:
  * int x
  * def y
  * List z
----

* Uses of the *field access operator*.
+
[source,Painless]
----
<1> Example example = new Example();
<2> example.x = 1;
<3> example.y = example.x;
<4> example.z = new ArrayList();
<5> example.z.add(1);
<6> example.x = example.z.get(0);
----
+
<1> declare `Example example`;
    allocate `Example` instance -> `Example reference`;
    store `Example reference` to `example`
<2> load from `example` -> `Example reference`;
    store `int 1` to `x` of `Example reference`
<3> load from `example` -> `Example reference @0`;
    load from `example` -> `Example reference @1`;
    load from `x` of `Example reference @1` -> `int 1`;
    implicit cast `int 1` to `def` -> `def`;
    store `def` to `y` of `Example reference @0`;
    (note `Example reference @0` and `Example reference @1` are the same)
<4> load from `example` -> `Example reference`;
    allocate `ArrayList` instance -> `ArrayList reference`;
    implicit cast `ArrayList reference` to `List reference` -> `List reference`;
    store `List reference` to `z` of `Example reference`
<5> load from `example` -> `Example reference`;
    load from `z` of `Example reference` -> `List reference`;
    call `add` on `List reference` with arguments (`int 1`)
<6> load from `example` -> `Example reference @0`;
    load from `example` -> `Example reference @1`;
    load from `z` of `Example reference @1` -> `List reference`;
    call `get` on `List reference` with arguments (`int 0`) -> `int 1`;
    store `int 1` in `x` of `List reference @0`;
    (note `Example reference @0` and `Example reference @1` are the same)

[[null-safe-operator]]
==== Null Safe

Use the *null safe operator* instead of the *method call operator* or *field
access operator* to ensure a reference type value is not `null` before
a method call or field access. A `null` value will be returned if the reference
type value is `null`, otherwise the method call or field access is evaluated.

*Errors*

* If the method call return type value or the field access type value is not
  a reference type value and is not implicitly castable to a reference type
  value.

*Grammar*

[source,ANTLR4]
----
null_safe: null_safe_field_access
         | null_safe_method_call;

null_safe_field_access: accessible '?.' ID;
accessible: (variable | field | type);

null_safe_method_call: callable '?.' ID arguments;
callable: (variable | field | type);
arguments: '(' (expression (',' expression)*)? ')';
----

*Examples*

The examples use the following reference type definition:

----
name:
  Example

non-static member methods:
  * List factory()

non-static member fields:
  * List x
----

* Use of the *null safe operator* without a `null` value.
+
[source,Painless]
----
<1> Example example = new Example();
<2> List x = example?.factory();
----
+
<1> declare `Example example`;
    allocate `Example` instance -> `Example reference`;
    store `Example reference` to `example`
<2> declare `List x`;
    load from `example` -> `Example reference`;
    null safe call `factory` on `Example reference` -> `List reference`;
    store `List reference` to `x`;
+
* Use of the *null safe operator* with a `null` value;
+
[source,Painless]
----
<1> Example example = null;
<2> List x = example?.x;
----
<1> declare `Example example`;
    store `null` to `example`
<2> declare `List x`;
    load from `example` -> `Example reference`;
    null safe access `x` on `Example reference` -> `null`;
    store `null` to `x`;
    (note the *null safe operator* returned `null` because `example` is `null`)

[[list-initialization-operator]]
==== List Initialization

Use the *list initialization operator* to allocate an ArrayList type value with
a set of pre-defined values. Each value used to initialize the ArrayList type
value is converted to a `def` type value when inserted into the ArrayList type
value using the `add` method. The order of specified values is maintained upon
insertion.

*Grammar*

[source,ANTLR4]
----
list_initialization: '[' expression (',' expression)* ']'
                   | '[' ']';
----

*Examples*

* Use of the *list initialization operator* to create an empty List type value.
+
[source,Painless]
----
<1> List empty = [];
----
+
<1> declare `List empty`;
    allocate `ArrayList` instance -> `ArrayList reference`;
    implicit cast `ArrayList reference` to `List reference` -> `List reference`;
    store `List reference` to `empty`
+
* Use of the *list initialization operator* with static values.
+
[source,Painless]
----
<1> List list = [1, 2, 3];
----
+
<1> declare `List list`;
    allocate `ArrayList` instance -> `ArrayList reference`;
    call `add` on `ArrayList reference` with arguments(`int 1`);
    call `add` on `ArrayList reference` with arguments(`int 2`);
    call `add` on `ArrayList reference` with arguments(`int 3`);
    implicit cast `ArrayList reference` to `List reference` -> `List reference`;
    store `List reference` to `list`
+
* Use of the *list initialization operator* with non-static values.
+
[source,Painless]
----
<1> int i = 1;
<2> long l = 2L;
<3> float f = 3.0F;
<4> double d = 4.0;
<5> String s = "5";
<6> List list = [i, l, f*d, s];
----
+
<1> declare `int i`;
    store `int 1` to `i`
<2> declare `long l`;
    store `long 2` to `l`
<3> declare `float f`;
    store `float 3.0` to `f`
<4> declare `double d`;
    store `double 4.0` to `d`
<5> declare `String s`;
    store `String "5"` to `s`
<6> declare `List list`;
    allocate `ArrayList` instance -> `ArrayList reference`;
    load from `i` -> `int 1`;
    call `add` on `ArrayList reference` with arguments(`int 1`);
    load from `l` -> `long 2`;
    call `add` on `ArrayList reference` with arguments(`long 2`);
    load from `f` -> `float 3.0`;
    load from `d` -> `double 4.0`;
    promote `float 3.0` and `double 4.0`: result `double`;
    implicit cast `float 3.0` to `double 3.0` -> `double 3.0`;
    multiply `double 3.0` and `double 4.0` -> `double 12.0`;
    call `add` on `ArrayList reference` with arguments(`double 12.0`);
    load from `s` -> `String "5"`;
    call `add` on `ArrayList reference` with arguments(`String "5"`);
    implicit cast `ArrayList reference` to `List reference` -> `List reference`;
    store `List reference` to `list`

[[list-access-operator]]
==== List Access

Use the *list access operator* as a shortcut for an `set` method call or `get`
method call made on a List type value.

*Errors*

* Use of the *list access operator* on a value that is not a List type value.
* Use of a non-integer type value as an index for an `set` method call or `get`
  method call.

*Grammar*

[source,ANTLR4]
----
list_access: '[' expression ']'
----

*Examples*

* Uses of the *list access operator*.
+
[source,Painless]
----
<1> List list = new ArrayList();
<2> list.add(1);
<3> list.add(2);
<4> list.add(3);
<5> list[0] = 2;
<6> list[1] = 5;
<7> int x = list[0] + list[1];
<8> int y = 1;
<9> int z = list[y];
----
+
<1> declare `List list`;
    allocate `ArrayList` instance -> `ArrayList reference`;
    implicit cast `ArrayList reference` to `List reference` -> `List reference`;
    store `List reference` to `list`
<2> load from `list` -> `List reference`;
    call `add` on `List reference` with arguments(`int 1`)
<3> load from `list` -> `List reference`;
    call `add` on `List reference` with arguments(`int 2`)
<4> load from `list` -> `List reference`;
    call `add` on `List reference` with arguments(`int 3`)
<5> load from `list` -> `List reference`;
    call `set` on `List reference` with arguments(`int 0`, `int 2`)
<6> load from `list` -> `List reference`;
    call `set` on `List reference` with arguments(`int 1`, `int 5`)
<7> declare `int x`;
    load from `list` -> `List reference`;
    call `get` on `List reference` with arguments(`int 0`); -> `def`;
    implicit cast `def` to `int 2` -> `int 2`;
    load from `list` -> `List reference`;
    call `get` on `List reference` with arguments(`int 1`); -> `def`;
    implicit cast `def` to `int 5` -> `int 5`;
    add `int 2` and `int 5` -> `int 7`;
    store `int 7` to `x`
<8> declare `int y`;
    store `int 1` int `y`
<9> declare `int z`;
    load from `list` -> `List reference`;
    load from `y` -> `int 1`;
    call `get` on `List reference` with arguments(`int 1`); -> `def`;
    implicit cast `def` to `int 5` -> `int 5`;
    store `int 5` to `z`
+
* Uses of the *list access operator* with the `def` type.
+
[source,Painless]
----
<1> def d = new ArrayList();
<2> d.add(1);
<3> d.add(2);
<4> d.add(3);
<5> d[0] = 2;
<6> d[1] = 5;
<7> def x = d[0] + d[1];
<8> def y = 1;
<9> def z = d[y];
----
+
<1> declare `List d`;
    allocate `ArrayList` instance -> `ArrayList reference`;
    implicit cast `ArrayList reference` to `def` -> `def`;
    store `def` to `d`
<2> load from `d` -> `def`;
    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;
    call `add` on `ArrayList reference` with arguments(`int 1`)
<3> load from `d` -> `def`;
    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;
    call `add` on `ArrayList reference` with arguments(`int 2`)
<4> load from `d` -> `def`;
    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;
    call `add` on `ArrayList reference` with arguments(`int 3`)
<5> load from `d` -> `def`;
    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;
    call `set` on `ArrayList reference` with arguments(`int 0`, `int 2`)
<6> load from `d` -> `def`;
    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;
    call `set` on `ArrayList reference` with arguments(`int 1`, `int 5`)
<7> declare `def x`;
    load from `d` -> `def`;
    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;
    call `get` on `ArrayList reference` with arguments(`int 0`); -> `def`;
    implicit cast `def` to `int 2` -> `int 2`;
    load from `d` -> `def`;
    implicit cast `def` to `ArrayList reference` -> `ArrayList reference`;
    call `get` on `ArrayList reference` with arguments(`int 1`); -> `def`;
    implicit cast `def` to `int 2` -> `int 2`;
    add `int 2` and `int 5` -> `int 7`;
    store `int 7` to `x`
<8> declare `int y`;
    store `int 1` int `y`
<9> declare `int z`;
    load from `d` -> `ArrayList reference`;
    load from `y` -> `def`;
    implicit cast `def` to `int 1` -> `int 1`;
    call `get` on `ArrayList reference` with arguments(`int 1`); -> `def`;
    store `def` to `z`

[[map-initialization-operator]]
==== Map Initialization

Use the *map initialization operator* to allocate a HashMap type value with
a set of pre-defined values. Each pair of values used to initialize the HashMap
type value are converted to `def` type values when inserted into the HashMap
type value using the `put` method. The order of specified values is maintained
upon insertion.

*Grammar*

[source,ANTLR4]
----
map_initialization: '[' key_pair (',' key_pair)* ']'
                  | '[' ':' ']';
key_pair: expression ':' expression
----

*Examples*



[source,Java]
----
Map empty = [:];            // declares the Map variable empty and sets it to a newly initialized empty Map
Map m0 = [1:2, 3:4, 5:6];   // declares the Map variable m0 and sets it to a newly initialized Map with the keys 1, 3, 5 and values 2, 4, 6, respectively

byte b = 0;
int i = 1;
long l = 2L;
float f = 3.0F;
double d = 4.0;
String s = "5";
Map m1 = [b:i, l:f*d, d:s]; // declares the Map variable m1 and sets it to a newly initialized Map with the keys b, l, d and values i, f*d, s, respectively
----

[[map-access-operator]]
==== Map Access

Elements in a Map can be stored or accessed using the brackets operator.  The format begins with an opening bracket, followed by an expression, and finishes with a closing bracket.  Storing values in a Map is equivalent to invoking a Map's put method.  Accessing values in a Map is equivalent to invoking a Map's get method.  Using this operator is strictly a shortcut for the previously mentioned methods.  Any element from a Map can be stored/accessed where the expression is the key.  If a key has no corresponding value when accessing a Map then the value will be null.

*Grammar:*
[source,ANTLR4]
----
map_access: '[' expression ']'
----

*Examples:*
[source,Java]
----
Map x = new HashMap();             // declares a Map variable x and sets it to a newly allocated HashMap
x['value2'] = 2;                   // puts the value of the key constant String value2 of the variable x to the constant int 2
x['value5'] = 5;                   // puts the value of the key constant String value5 of the variable x to the constant int 5
int y = x['value2'] + x['value5']; // declares the int variable y and sets it to the sum of the two values of the variable x
String z = 'value5';               // declares the String variable z and sets it to the constant String value5
return x[z];                       // accesses the value for the key value5 of the variable x using the variable z as an expression and returns the value

def d = new HashMap();             // declares a def variable d and sets it to a newly allocated HashMap
d['value2'] = 2;                   // puts the value of the key constant String value2 of the variable d to the constant int 2
d['value5'] = 5;                   // puts the value of the key constant String value5 of the variable d to the constant int 5
int y = d['value2'] + d['value5']; // declares the int variable y and sets it to the sum of the two values of the variable d
String z = 'value5';               // declares the String variable z and sets it to the constant String value5
return d[z];                       // accesses the value for the key value5 of the variable x using the variable z as an expression and returns the value
----

Note in the first example above all types can be resolved at compile-time, while in the second example all types must wait to be resolved until run-time.

[[new-instance-operator]]
==== New Instance

A constructor call is a special type of method call [MARK] used to allocate a reference type instance using the new operator.  The format is the new operator followed by a type, an opening parenthesis, arguments if any, and a closing parenthesis.  Arguments are a series of zero-to-many expressions delimited by commas.  Auto-boxing and auto-unboxing will be applied automatically for arguments passed into a constructor call.  See boxing and unboxing [MARK] for more information on this topic.  Constructor argument types can always be resolved at run-time; if appropriate type conversions (casting) cannot be applied an error will occur.  Once a reference type instance has been allocated, its members may be used as part of other expressions.

Constructor calls may be overloaded based on arity in Painless.  This means the same reference type may have multiple constructors as long as the number of arguments differs for each one.  This does have an effect on some of the provided reference type constructors in the Painless API [MARK].  When there are overloaded constructors with the same arity for a reference type in Java a single constructor must be chosen to be provided in Painless.

*Grammar:*
[source,ANTLR4]
----
constructor_call: 'new' TYPE '(' (expression (',' expression)*)? ')';
----

*Examples:*
[source,Java]
----
Map m = new HashMap();   // declares the Map variable m and sets it to a newly allocated HashMap using an empty constructor
m.put(3, 3);             // invokes the method call member put and adds the key-value pair of 3 to Map variable m
def d = new ArrayList(); // declares the def variable d and sets it to a newly allocated ArrayList using an empty constructor
def e;                   // declares the def variable e
e = new HashMap(m);      // sets e to a newly allocated HashMap using the constructor with a single argument m
----

[[string-concatenation-operator]]
==== String Concatenation

Concatenates two expressions together as a single String where at least of one of the expressions is a String to begin with.  The format is an expression, followed by a plus operator, and a closing expression.

*Grammar:*
[source,ANTLR4]
----
concatenate: expression '+' expression;
----

*Examples:*
[source,Java]
----
String x = "con";          // declares the String variable x and sets it to the String constant "con"
String y = x + "cat";      // declares the String variable y and sets it to the concatenation of the String variable x and the String constant "cat"
String z = 4 + x;          // declares the String variable z and sets it to the concatenation of the int constant 4 and the String variable x (4 is implicitly cast to a String)
def d = 2;                 // declares the def variable d and sets it to the int constant 2
z = z + d;                 // sets the String variable z to the concatenation of the String variable z
d = "con" + x + y + "cat"; // sets the def variable d to the concatenation of String constant "con", x, y, and the String constant "cat"
----

[[elvis-operator]]
==== Elvis

The elvis operator consists of two expressions.  If the first expression is a non-null value then the resultant value will be the evaluated first expression otherwise the resultant value will be the evaluated second expression.  This is typically used as a shortcut for a null check in a conditional.  An error will occur if the expected result is a primitive type.  The format is an expression, followed by the question-mark-colon operator, and finishes with an expression.

*Grammar:*
[source,ANTLR4]
----
elvis: expression '?:' expression;
----

*Examples:*
[source,Java]
----
List l = new ArrayList();      // declares the List variable l and sets it to a newly allocated ArrayList
List y = l ?: new ArrayList(); // declares the List variable y and sets it to l since l is not null
y = null;                      // sets y to null
def z = y ?: new HashMap();    // declares the def variable z and sets it to a newly allocated HashMap since y is null
----
