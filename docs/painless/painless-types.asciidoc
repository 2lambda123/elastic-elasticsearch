[[painless-types]]
=== Types

Types are a classification of data used to describe the properties of values
operated on in expressions and statements. These properties describe what data
the value can represent such as a number, string, or something more complex and
the rules for when a value is operated on.  Types are split into the following
categories: <<primitive-types, primitive types>>,
<<reference-types, reference types>>, and <<dynamic-types, dynamic types>>.

[[primitive-types]]
==== Primitive Types

Primitive types are built straight into the JVM, directly contain their data,
and are allocated to non-heap memory.  Primitive type values are copied when
<<assignment, assigned>> and when passed into a <<method-access, method>> or
function as arguments.

Primitive types have corresponding <<reference-types, reference types>> (also
known as a <<boxing-unboxing, boxed type>>). Any member of the corresponding
<<reference-types, reference type>> can be <<field-access, accessed>> or
<<method-access, called>> by executing the appropriate operation on the
primitive type value. Operations performed in this manner convert
(<<boxing-unboxing, box>>) the primitive type value to its corresponding
<<reference-types, reference type>> value at runtime and execute the specified
<<field-access, field access>> or <<method-access, method call>>.

The following primitive types are available:

[horizontal]
`byte`::
8-bit, signed, two's complement integer
* range: [`-128`, `127`]
* default value: `0`
* reference type: `Byte`

`short`::
16-bit, signed, two's complement integer
* range: [`-32768`, `32767`]
* default value: `0`
* reference type: `Short`

`char`::
16-bit, unsigned, Unicode character
* range: [`0`, `65535`]
* default value: `0` or `\u0000`
* reference type: `Character`

`int`::
32-bit, signed, two's complement integer
* range: [`-2^32`, `2^32-1`]
* default value: `0`
* reference type: `Integer`

`long`::
64-bit, signed, two's complement integer
* range: [`-2^64`, `2^64-1`]
* default value: `0`
* reference type: `Long`

`float`::
32-bit, signed, single-precision, IEEE 754 floating point number
* default value: `0.0`
* reference type: `Float`

`double`::
64-bit, signed, double-precision, IEEE 754 floating point number
* default value: `0.0`
* reference type: `Double`

`boolean`::
logical quanity with two possible values of `true` and `false`
* default value: `false`
* reference type: `Boolean`

*Examples*

* Primitive types used in <<declaration, declaration>> and
<<assignment, assignment>>.
+
[source,Painless]
----
<1> int i = 1;
<2> double d;
<3> boolean b = true;
----
+
<1> declare `int i`; assign `1` to `i`
<2> declare `double d`; assign the default value of `0.0` to `d`
<3> declare `boolean b`; assign `true` to `b`
+
* Method call on a primitive type from the corresponding
<<reference-types, reference type>>.
+
[source,Painless]
----
<1> int i = 1;
<2> i.toString();
----
+
<1> declare `int i`; assign `1` to `i`
<2> implicitly convert (box) `i` to the reference type `Integer`;
invoke the `Integer` method `toString` on the converted (boxed) value

[[reference-types]]
==== Reference Types

Reference types are constructs (objects), potentially representing multiple
pieces of data (member fields) and logic to manipulate that data (member
methods), defined as part of the application programming interface (API) for
use in scripts.

A reference type instance is a single set of data for one reference type
object allocated to the heap. A reference type instance is allocated using the
<<constructor-call, new operator>>.

Reference type values refer to reference type instances, and multiple reference
type values may refer to a single reference type instance. A change to a
reference type instance will affect all reference type values refering to that
instance. Reference type values are shallow-copied when
<<assignment, assigned>> and when passed into a <<method-access, method>> or
function as arguments.

The default value for a <<declaration, newly-declared>> reference type
<<painless-variables, variable>> is `null`. <<assignment, Assign>> a
<<constructor-call, newly-allocated>> reference type instance or
<<assignment, refer>> an existing reference type instance to a reference type
<<painless-variables, variable>> for <<painless-operators, use>> later in a
script. <<assignment, Assign>> `null` to a reference type value to indicate the
reference type value refers to no reference type instance.  A reference type
instance will be garbage collected by the JVM when no reference type values
refer to that reference type instance.

Reference type objects can contain member fields, member methods, and
constructors. Member fields are named and typed pieces of data that are read
and written to using the <<field-access, dot operator>>.  Member methods are
functions decicated to a single reference type object that can manipulate
member fields and return values.  Call member methods using the
<<method-access, dot-operator>>.  Constructors are a special type of function
used to allocate a reference type instance using the
<<constructor-call, new operator>>.

Reference type objects can have both static and non-static members (member
fields and member methods). <<field-access, Access>> and
<<method-access, call>> static members of a reference type object without
allocating a reference type instance using the reference type object name
as the <<painless-identifiers, identifer>> in place of a reference type value.
Static members are singletons per reference type object. Non-static members are
specific to a reference type instance. <<field-access, Access>> and
<<method-access, call>> non-static members on a reference type value referring
to an allocated reference type instance.

A reference type can contain the following:

* zero to many <<primitive-types, primitive type>> static member fields
* zero to many <<primitive-types, primitive type>> non-static member fields
* zero to many reference type static member fields
* zero to many reference type non-static member fields
* zero to many <<dynamic-types, dynamic type>> static member fields
* zero to many <<dynamic-types, dynamic type>> non-static member fields
* zero to many static member methods
* zero to many non-static member methods
* zero to many constructors

Reference type objects support a basic inheritance model. Consider types A and
B. Type A is considered to be a parent of B, and B a child of A, if B inherits
(is able to access as its own) all of A's non-static members. Type B is
considered a descendant of A if there exists a recursive parent-child
relationship from B to A with none to many types in between. In this case, B
inherits all of A's non-static members along with all of the non-static members
of the types in between. Type B is also considered to be a type A in both
relationships.

*Examples*

* Reference types used in several different <<painless-operators, operations>>.
+
[source,Painless]
----
<1> List l = new ArrayList();
<2> l.add(1);
<3> int i = l.get(0) + 2;
----
+
<1> declare `List l`;
    assign a new `ArrayList` to `l`
<2> call non-static member method `add` on l with arguments of `1`
<3> declare `int i`;
    call non-static member method `get` on `l` with arguments `0`;
    add `1` to `2`;
    assign `3` to `i`
+
* Sharing a reference type instance.
+
[source,Painless]
----
<1> List l0 = new ArrayList();
<2> List l1 = l0;
<3> l0.add(1);
<4> l1.add(2);
<5> int i = l1.get(0) + l0.get(1);
----
+
<1> declare `List l0`;
    assign a new `ArrayList` to `l0`
<2> declare `List l1`;
    assign a shallow-copy of `l0` to `l1`
<3> call non-static member method `add` on l0 with arguments of `1`
<4> call non-static member method `add` on l1 with arguments of `2`
<5> note `l0` and `l1` refer to the same reference type instance;
    call non-static member method `get` on `l1` with arguments `0`;
    call non-static member method `get` on `l0` with arguments `1`;
    add `1` to `2`;
    assign `3` to `i`;
+
* Using the static members of a reference type.
+
[source,Painless]
----
<1> Integer.MAX_VALUE
<2> Long.parseLong("123L")
----
+
<1> access static field `MAX_VALUE` on reference type `Integer`
<2> call static member method `parseLong` on reference type `Long` with
    arguments `long 123`

[[dynamic-types]]
==== Dynamic Types

Dynamic types can represent values of any primitive type or reference type
under a single type name `def`.  The `def` type mimics the behavior of whatever
value is currently represented.

Internally, if a `def` type value is a primitive type value, the value is
converted (<<boxing-unboxing, boxed>>) to the corresponding reference type
instance. However, the `def` type still behaves like the primitive type
including within the <<painless-casting, casting model>>.

The default value for a <<declaration, newly-declared>> `def` type
<<painless-variables, variable>> is `null`. A `def` type
<<painless-variables, variable>> can have different types
<<assignment, assigned>> throughout a script.

<<painless-operators, Operations>> using the `def` type will generate
errors at *runtime* if an inappropriate type is used. Using the `def` type can
have a slight impact on performance. Use only primitive types and reference
types directly when performance is critical.

*Examples*

* General uses of the `def` type.
+
[source,Java]
----
<1> def i = 1;
<2> def l = new ArrayList();
<3> l = i;
----
+
<1> declare `def i`;
    assign `1` to `i`
<2> declare `def l`;
    assign a new `ArrayList` to `l`
<3> assign `i` to `l`;
    note the switch in type from `ArrayList` to `int`

[[string-type]]
==== String Type

A `String` is a specialized reference type that is immutable and does not have
to be explicitly allocated. You can directly assign to a `String` without first
allocating it with the `new` keyword. (Strings can be allocated with the `new`
keyword, but it's not required.)

When assigning a value to a `String`, you must enclose the text in single or
double quotes. Strings are allocated according to the standard Java Memory Model.
The default value for a `String` is `null.`

*Examples:*
[source,Java]
----
String r = "some text";             // Declare String r and set it to the
                                    //   String "some text"
String s = 'some text';             // Declare String s and set it to the
                                    //   String 'some text'
String t = new String("some text"); // Declare String t and set it to the
                                    //   String "some text"
String u;                           // Declare String u and set it to the
                                    //   default value null
----

[[void-type]]
==== void Type

The `void` type represents the concept of no type. In Painless, `void` declares
that a function has no return value.

[[array-type]]
==== Array Type

Arrays contain a series of elements of the same type that can be allocated
simultaneously. Painless supports both single and multi-dimensional arrays for
all types except void (including `def`).

You declare an array by specifying a type followed by a series of empty brackets,
where each set of brackets represents a dimension. Declared arrays have a default
value of `null` and are themselves a reference type.

To allocate an array, you use the `new` keyword followed by the type and a
set of brackets for each dimension. You can explicitly define the size of each dimension by specifying an expression within the brackets, or initialize each
dimension with the desired number of values. The allocated size of each
dimension is its permanent size.

To initialize an array, specify the values you want to initialize
each dimension with as a comma-separated list of expressions enclosed in braces.
For example, `new int[] {1, 2, 3}` creates a one-dimensional `int` array with a
size of 3 and the values 1, 2, and 3.

When you initialize an array, the order of the expressions is maintained. Each expression used as part of the initialization is converted to the
array's type. An error occurs if the types do not match.

*Grammar:*
[source,ANTLR4]
----
declare_array: TYPE ('[' ']')+;

array_initialization: 'new' TYPE '[' ']' '{' expression (',' expression) '}'
                    | 'new' TYPE '[' ']' '{' '}';
----

*Examples:*
[source,Java]
----
int[] x = new int[5];          // Declare int array x and assign it a newly
                               //   allocated int array with a size of 5
def[][] y = new def[5][5];     // Declare the 2-dimensional def array y and
                               //   assign it a newly allocated 2-dimensional
                               //   array where both dimensions have a size of 5
int[] x = new int[] {1, 2, 3}; // Declare int array x and set it to an int
                               //   array with values 1, 2, 3 and a size of 3
int i = 1;
long l = 2L;
float f = 3.0F;
double d = 4.0;
String s = "5";
def[] da = new def[] {i, l, f*d, s}; // Declare def array da and set it to
                                     // a def array with a size of 4 and the
                                     // values i, l, f*d, and s
----
