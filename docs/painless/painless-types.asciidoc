[[painless-types]]
=== Types

Types are a classification of data used to describe the properties of values
operated on in expressions and statements. These properties describe what data
the value can represent such as a number, string, or something more complex and
the rules for when a value is operated on.  Types are split into the following
categories: <<primitive-types, primitive types>>,
<<reference-types, reference types>>, and <<dynamic-types, dynamic types>>.

[[primitive-types]]
==== Primitive Types

Primitive types are built straight into the JVM, directly contain their data,
and are allocated to non-heap memory.  Primitive type values are copied when
<<assignment, assigned>> and when passed into a <<method-access, method>> or
function as arguments.

Primitive types have corresponding <<reference-types, reference types>> (also
known as <<boxing-unboxing, boxed types>>). Any member of the corresponding
<<reference-types, reference type>> can be <<field-access, accessed>> or
<<method-access, called>> by executing the appropriate operation on the
primitive type value. Operations performed in this manner convert
(<<boxing-unboxing, box>>) the primitive type value to its corresponding
<<reference-types, reference type>> value at runtime and execute the specified
<<field-access, field access>> or <<method-access, method call>>.

The following primitive types are available:

[horizontal]
`byte`::
8-bit, signed, two's complement integer
* range: [`-128`, `127`]
* default value: `0`
* reference type: `Byte`

`short`::
16-bit, signed, two's complement integer
* range: [`-32768`, `32767`]
* default value: `0`
* reference type: `Short`

`char`::
16-bit, unsigned, Unicode character
* range: [`0`, `65535`]
* default value: `0` or `\u0000`
* reference type: `Character`

`int`::
32-bit, signed, two's complement integer
* range: [`-2^32`, `2^32-1`]
* default value: `0`
* reference type: `Integer`

`long`::
64-bit, signed, two's complement integer
* range: [`-2^64`, `2^64-1`]
* default value: `0`
* reference type: `Long`

`float`::
32-bit, signed, single-precision, IEEE 754 floating point number
* default value: `0.0`
* reference type: `Float`

`double`::
64-bit, signed, double-precision, IEEE 754 floating point number
* default value: `0.0`
* reference type: `Double`

`boolean`::
logical quantity with two possible values of `true` and `false`
* default value: `false`
* reference type: `Boolean`

*Examples*

* Primitive types used in <<declaration, declaration>> and
<<assignment, assignment>>.
+
[source,Painless]
----
<1> int i = 1;
<2> double d;
<3> boolean b = true;
----
+
<1> declare `int i`;
    assign value of `int 1` to `i`
<2> declare `double d`;
    assign default value of `double 0.0` to `d`
<3> declare `boolean b`;
    assign value of `boolean true` to `b`
+
* Method call on a primitive type from the corresponding
<<reference-types, reference type>>.
+
[source,Painless]
----
<1> int i = 1;
<2> i.toString();
----
+
<1> declare `int i`;
    assign value of `int 1` to `i`
<2> box value of `i` -> `Integer 1`;
    call `toString` on `Integer 1` -> `String '1'`

[[reference-types]]
==== Reference Types

Reference types are constructs (objects), potentially representing multiple
pieces of data (member fields) and logic to manipulate that data (member
methods), defined as part of the application programming interface (API) for
use in scripts.

A reference type instance is a single set of data for one reference type
object allocated to the heap. A reference type instance is allocated using the
<<constructor-call, `new operator`>>.

Reference type values refer to reference type instances, and multiple reference
type values may refer to a single reference type instance. A change to a
reference type instance will affect all reference type values referring to that
instance. Reference type values are shallow-copied when
<<assignment, assigned>> and when passed into a <<method-access, method>> or
function as arguments.

The default value for a <<declaration, newly-declared>> reference type
<<painless-variables, variable>> is `null`. <<assignment, Assign>> a
<<constructor-call, newly-allocated>> reference type instance or
<<assignment, refer>> an existing reference type instance to a reference type
<<painless-variables, variable>> for <<painless-operators, use>> later in a
script. <<assignment, Assign>> `null` to a reference type value to indicate the
reference type value refers to no reference type instance.  A reference type
instance will be garbage collected by the JVM when no reference type values
refer to that reference type instance.

Reference type objects can contain member fields, member methods, and
constructors. Member fields are named and typed pieces of data that are read
and written to using the <<field-access, dot operator>>.  Member methods are
functions decicated to a single reference type object that can manipulate
member fields and return values.  Call member methods using the
<<method-access, dot-operator>>.  Constructors are a special type of function
used to allocate a reference type instance using the
<<constructor-call, `new` operator>>.

Reference type objects can have both static and non-static members (member
fields and member methods). <<field-access, Access>> and
<<method-access, call>> static members of a reference type object without
allocating a reference type instance using the reference type object name
as the <<painless-identifiers, identifer>> in place of a reference type value.
Static members are singletons per reference type object. Non-static members are
specific to a reference type instance. <<field-access, Access>> and
<<method-access, call>> non-static members on a reference type value referring
to an allocated reference type instance.

A reference type can contain the following:

* zero to many <<primitive-types, primitive type>> static member fields
* zero to many <<primitive-types, primitive type>> non-static member fields
* zero to many reference type static member fields
* zero to many reference type non-static member fields
* zero to many <<dynamic-types, dynamic type>> static member fields
* zero to many <<dynamic-types, dynamic type>> non-static member fields
* zero to many static member methods
* zero to many non-static member methods
* zero to many constructors

Reference type objects support a basic inheritance model. Consider types A and
B. Type A is considered to be a parent of B, and B a child of A, if B inherits
(is able to access as its own) all of A's non-static members. Type B is
considered a descendant of A if there exists a recursive parent-child
relationship from B to A with none to many types in between. In this case, B
inherits all of A's non-static members along with all of the non-static members
of the types in between. Type B is also considered to be a type A in both
relationships.

*Examples*

* Reference types used in several different <<painless-operators, operators>>.
+
[source,Painless]
----
<1> List l = new ArrayList();
<2> l.add(1);
<3> int i = l.get(0) + 2;
----
+
<1> declare `List l`;
    allocate `ArrayList` instance -> `ArrayList`;
    implicit cast value of `Arraylist` to `List` -> `List`;
    assign value of `List` to `l`
<2> box value of `int 1` -> `Integer 1`;
    call `add` on `l` with arguments `(Integer 1)`
<3> declare `int i`;
    call `get` on `l` with arguments `(int 0)` -> `Integer 1`;
    unbox value of Integer `1` -> `int 1`;
    add value of `int 1` and value of `int 2` -> `int 3`;
    assign value of `int 3` to `i`
+
* Sharing a reference type instance.
+
[source,Painless]
----
<1> List l0 = new ArrayList();
<2> List l1 = l0;
<3> l0.add(1);
<4> l1.add(2);
<5> int i = l1.get(0) + l0.get(1);
----
+
<1> declare `List l0`;
    allocate `ArrayList` instance -> `ArrayList`;
    implicit cast value of `ArrayList` to `List` -> `List`;
    assign value of `List` to `l0`
<2> declare `List l1`;
    assign shallow-copy of value of `l0` to `l1`
    (note `l0` and `l1` refer to the same instance)
<3> box value of `int 1` -> `Integer 1`;
    call `add` on `l0` with arguments `(Integer 1)`
<4> box value of `int 2` -> `Integer 2`;
    call `add` on `l1` with arguments `(Integer 2)`
<5> call `get` on `l1` with arguments `(int 0)` -> `Integer 1`;
    unbox value of `Integer 1` -> `int 1`;
    call get` on `l0` with arguments `(int 1)` -> `Integer 2`;
    unbox value of `Integer 2` -> `int 2`;
    add `int 1` and `int 2` -> `int 3`;
    assign value of `int 3` to `i`;
+
* Using the static members of a reference type.
+
[source,Painless]
----
<1> int i = Integer.MAX_VALUE;
<2> Long l = Long.parseLong("123L");
----
+
<1> declare `int i`;
    access `MAX_VALUE` on `Integer` -> `int 2147483647`;
    assign value of `int 2147483647` to `i`
<2> declare `Long l`;
    call `parseLong` on `Long` with arguments `(long 123)` -> `Long 123`;
    assign shallow-copy of value of `Long 123` to `l`

[[dynamic-types]]
==== Dynamic Types

Dynamic types can represent values of any primitive type or reference type
under a single type name `def`.  The `def` type mimics the behavior of whatever
value is currently represented.

Internally, if a `def` type value is a primitive type value, the value is
converted (<<boxing-unboxing, boxed>>) to the corresponding reference type
instance. However, the `def` type still behaves like the primitive type
including within the <<painless-casting, casting model>>.

The default value for a <<declaration, newly-declared>> `def` type
<<painless-variables, variable>> is `null`. A `def` type
<<painless-variables, variable>> can have different types
<<assignment, assigned>> throughout a script.

<<painless-operators, Operations>> using the `def` type will generate
errors at runtime if an inappropriate type is represented. Using the `def`
type can have a slight impact on performance. Use only primitive types and
reference types directly when performance is critical.

*Examples*

* General uses of the `def` type.
+
[source,Painless]
----
<1> def dp = 1;
<2> def dr = new ArrayList();
<3> dr = dp;
----
+
<1> declare `def dp`;
    assign value of `int 1` to `dp`
<2> declare `def dr`;
    allocate `ArrayList` instance -> `ArrayList`;
    assign value of `ArrayList` to `dr`
<3> assign value of `dp` to `dr`;
    (note the switch in type of `dr` from `ArrayList` to `int`)

[[string-type]]
==== String Type

The `String` type is a specialized reference type that does not require
explicit allocation. Use <<strings, string literals>> to directly
<<assignment, assign>> or <<painless-operators, operate>> on `String` values.
While not required, the <<constructor-call, `new` operator>> can allocate
`String` values.

*Examples*

* General use of the `String` type.
+
[source,Painless]
----
<1> String r = "some text";
<2> String s = 'some text';
<3> String t = new String("some text");
<4> String u;
----
+
<1> declare `String r`;
    assign value of `"some text"` to `r`
<2> declare `String s`;
    assign value of `'some text'` to `s`
<3> declare `String t`;
    allocate `String` instance with arguments `("some text")`
    -> `String "some text"`;
    assign value of `String "some text"` to `t`
<4> declare `String u`;
    assign default value of `null` to `u`

[[void-type]]
==== void Type

The `void` type represents the concept of a lack of type. The `void` type is
primarily used to indicate a function will return no value.

*Examples*

* Use of the `void` type in a function.
+
[source,Painless]
----
void addToList(List l, def d) {
    l.add(d);
}
----

[[array-type]]
==== Array Type

The array type is a specialized reference type where an array type instance
represents a series of values.  All values in an array type instance are of
the same type.  Each value is assigned an index from within the range
`[0, length)` where length is the total number of values allocated for the
array type instance. Specify the type of values and the length during an
array allocation.

Allocate an array type instance using the <<new-array, new operator>> or the
<<array-initialization, initialization operator>>.  Array type instances are
allocated to the heap. <<declaration, Declare>> and <<assignment, assign>>
array type variables for <<painless-operators, use>> within scripts.  The
default value for newly-declared array instance types is `null`.  Array type
values are shallow-copied when <<assignment, assigned>> and when passed into a
<<method-access, method>> or function as arguments. Read and write to individual
values within the array type instance using the <<array-access, access operator>>.

When an array type instance is allocated with multiple dimensions using the
range `[2, d]` where `d >= 2`, each dimension in the range `[1, d-1]` is also
an array type. The array type of each dimension, `n`, is an array type with the
number of dimensions equal to `d-n`. For example, consider `int[][][]` with 3
dimensions. The 3rd dimension, `d-3`, is the primitive type `int`.  The 2nd
dimension, `d-2`, is the array type `int[]`. And the 1st dimension, `d-1` is
the array type `int[][]`.

*Examples*

* General use of single-dimensional arrays.
+
[source,Painless]
----
<1> int[] x;
<2> float[] y = new float[10];
<3> def z = new float[5];
<4> y[9] = 1.0F;
<5> z[0] = y[9];
----
+
<1> declare `int[] x`;
    assign default value of `null` to `x`
<2> declare `float[] y`;
    allocate `1-d float array` instance with `length [10]`
    -> `1-d float array`;
    assign value of `1-d float array` to `y`
<3> declare `def z`;
    allocate `1-d float array` instance with `length [5]` -> `1-d float array`;
    assign value of `1-d float array` to `z`
<4> assign value of `float 1.0` to `index [9]` of `y`
<5> assign value of `index [9]` of `y` to `index [0]` of `z`
+
* Use of a multi-dimensional array.
+
[source,Painless]
----
<1> int[][][] ia3 = new int[2][3][4];
<2> ia3[1][2][3] = 99;
<3> int i = ia3[1][2][3];
----
+
<1> declare `int[][][] ia`;
    allocate `3-d int array` instance with length `[2, 3, 4]`
    -> `3-d float array`;
    assign value of `3-d float array` to `ia3`
<2> assign value of `int 99` to `index [1, 2, 3]` of `ia3`
<3> declare `int i`;
    assign value of `index [1, 2, 3]` of `ia3` to `i`