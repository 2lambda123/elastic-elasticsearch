[[avoid-oversharding]]
== Avoid oversharding

Sometimes reducing the number of shards in a cluster while maintaining the same amount of data will lead to a more effective use of system resources (CPU, RAM, IO). In these situations, we consider the cluster “oversharded”. The number of shards where this inflection point occurs depends on a variety of factors, including available hardware, indexing load, data volume, the types of queries executed against the cluster, the rate of these queries being issued, and the volume of data being queried. Testing against production data with production queries on production hardware is the only way to calibrate optimal shard sizes. Shard sizes of tens of GB are commonly used, and this may be a useful starting point from which to experiment. Kibana’s {kibana-ref}/elasticsearch-metrics.html[Elasticsearch monitoring] provides a useful view of historical cluster performance when evaluating the impact of different shard sizes.

[discrete]
[[oversharding-inefficient]]
=== Why oversharding is inefficient

Each segment has metadata that needs to be kept in heap memory. These include lists of fields, the number of documents, and terms dictionaries. As a shard grows in size, the size of its segments generally grow because smaller segments are <<index-modules-merge,merged>> into fewer, larger segments. This typically reduces the amount of heap required by a shard’s segment metadata for a given data volume. At a bare minimum shards should be at least larger than 1GB to make the most efficient use of memory. 

However, even though shards start to be more memory efficient at around 1GB, a cluster full of 1GB shards will likely still perform poorly. This is because having many small shards can also have a negative impact on search and indexing operations. Each query or indexing operation is executed in a single thread per shard of indices being queried or indexed to. The node receiving a request from a client becomes responsible for distributing that request to the appropriate shards as well as reducing the results from those individual shards into a single response. Even assuming that a cluster has sufficient <<modules-threadpool,search threadpool threads>> available to immediately process the requested action against all shards required by the request, the overhead associated with making network requests to the nodes holding those shards and with having to merge the results of results from many small shards can lead to increased latency. This in turn can lead to exhaustion of the threadpool and, as a result, decreased throughput.

[discrete]
[[reduce-shard-counts-increase-shard-size]]
=== How to reduce shard counts and increase shard size

Try these six methods to reduce oversharding.

[[reduce-shards-for-new-indices]]
==== Reduce the number of shards for new indices

The `index.number_of_shards` setting can be specified for new indices created with the <<indices-create-index,Create Index API>> or as part of <<indices-templates,index templates>> for indices automatically created by <<index-lifecycle-management,Index Lifecycle Management>>. For Elasticsearch versions below 7.0, the default value for this setting was `5`. For versions 7.0 and higher, the default value for this setting is `1`.

The <<rollover-index-api-example,rollover request>> body can also override that same `index.number_of_shards` setting.

[[create-larger-shards-by-increasing-rollover-thresholds]]
==== Create larger shards by increasing rollover thresholds

If indices are rolled over by either directly using the Rollover API or by specifying the Index Lifecycle Management {ref}/_actions.html#ilm-rollover-action[Rollover action], then the rollover condition thresholds (`max_age`, `max_docs`, `max_size`) can be increased to allow the indices to grow to a larger size before being rolled over, thereby generating larger shards.

Take special note of any indices that are empty. These may be managed by an ILM policy that is rolling over the indices because the `max_age` threshold is met. In this case, you may need to adjust the policy to make use of the `max_docs` or `max_size` properties to prevent the creation of these empty indices. One example where this may happen is if one or more Beats stop sending data. If the ILM-managed indices for those Beats are configured to rollover daily, then new, empty indices will be generated each day. Empty indices can be identified using the following {ref}/cat-count.html[cat count API]: `GET /_cat/count?v`.


[float]
==== 3. Create larger shards by using index patterns spanning longer time periods

Creating indices covering longer time periods will also reduce the index, and thereby shard, counts and increase index sizes. For example, instead of daily indices, create monthly, or even yearly indices.

If creating indices using Logstash, the {logstash-ref}/plugins-outputs-elasticsearch.html#plugins-outputs-elasticsearch-index[index] property of the Elasticsearch output can be modified to a <<date-math-index-names,date math expression>> covering a longer time period. For example, use `logstash-%{+YYYY.MM}`` instead of `logstash-%{+YYYY.MM.dd}`` to create monthly, rather than daily, indices. Beats also allow changing the date math expression defined in the `index` property of the Elasticsearch output, such as for {filebeat-ref}/elasticsearch-output.html#index-option-es[Filebeat].


[float]
==== 4. Shrink an existing index to fewer shards

The {ref}/indices-shrink-index.html[Shrink index API] can shrink an existing index down to a fewer shards.

{ref}/index-lifecycle-management.html[Index Lifecycle Management] also has a shrink action available as part of its warm phase.


[float]
==== 5. Reindex an existing index to fewer shards

The <<docs-reindex,Reindex API>> can be used to reindex from an existing index to a new index with fewer shards. After the data has been reindexed, the initial oversharded index can be deleted.

[float]
==== 6. Reindex indices from shorter periods into longer periods

The <<docs-reindex,Reindex API>> can be used to reindex multiple small indices covering shorter time periods into a larger index covering a longer time period. For example, daily indices from October with naming patterns such as `foo-2019.10.11` could be combined into a monthly `foo-2019.10` index, like this:

[source,console]
--------------------------------------------------
POST _reindex
{
  "source": {
    "index": "foo-2019.10.*"
  },
  "dest": {
    "index": "foo-2019.10"
  }
}
--------------------------------------------------

link:https://www.elastic.co/guide/en/elasticsearch/client/curator/current/index.html[Curator] can also link:https://www.elastic.co/guide/en/elasticsearch/client/curator/current/ex_reindex.html#_filter_selected_indices_2[help with reindexing time-based indices].
 
