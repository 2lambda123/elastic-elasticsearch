[[migrate_to_java_time]]
=== Java time migration guide

With 7.0, {es} switch to java time from joda time for date-related parsing,
formatting, and calculations. This guide is designed to help you determine
if your cluster is impacted and, if so, prepare for the upgrade.

Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0
All new indices created in 7.x are expected to be using java-time patterns.

We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x

- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.
- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.
- Patterns with or without `8` on indices *created in 7.x*  are considered java.style

[[java-time-migration-impacted-features]]
==== Impacted features
The switch to java time only impacts custom <<date,`date`>> and
<<date_nanos,`date_nanos`>> formats.

These formats are commonly used in:

* <<mapping,Index mappings>>
* <<indices-templates,Index templates>>
* <<pipeline,Ingest pipelines>>

If you don't use custom date formats, you can skip the rest of this guide.
Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.

To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>
or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]

[[java-time-migration-incompatible-date-formats]]
==== Incompatible date formats
Custom date formats containing the following joda time literals should be
changed before upgrading.

`Y` (Year of era)::
+
--
Replace with `y`.

*Example:*
`YYYY-MM-dd` should become `yyyy-MM-dd`

In java time, `Y` is used for
https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].
Using `Y` in place of `y` could result in off-by-one errors in year calculation.


The difference between year-of-era and week based year
For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`
For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019
--

`y` year::
+
--
Replace with `u`.

*Example:*
`yyyy-MM-dd` should become `uuuu-MM-dd`

The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.
--


`C` century of era::
+
--
No longer supported in 7.0. There is no replacement, so you need to preprocess your input.

A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern
--

`x` week year::
+
--
Replace with `Y`

This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time
--

`Z` Zone offset/id::
+
--
Replace with multiple `X`

`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.

Consider migrating to `X` which give you more control of how your time is parsed.
For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:

```
2010-01-01T01:02:03Z
2010-01-01T01:02:03+01
2010-01-01T01:02:03+01:02
2010-01-01T01:02:03+01:02:03
```

You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns

```
2010-01-01T01:02:03Z
2010-01-01T01:02:03+01
both parsed with yyyy-MM-dd'T'hh:mm:ssX

2010-01-01T01:02:03+01:02
yyyy-MM-dd'T'hh:mm:ssXXX

2010-01-01T01:02:03+01:02:03
yyyy-MM-dd'T'hh:mm:ssXXXXX
```


If you expect all these combination to occur in your data you need to combine these patterns in 7.0
[source,txt]
--------------------------------------------------
yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX
--------------------------------------------------

The same applies if you expect your pattern to occur without a colon:
Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:
```
2010-01-01T01:02:03Z
2010-01-01T01:02:03+01
2010-01-01T01:02:03+0102
2010-01-01T01:02:03+010203
```
To accept all these forms in java time, you must use the `||` delimiter:
[source,txt]
--------------------------------------------------
yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX
--------------------------------------------------
--

`d` (Day)::
+
--
In java time, `d` is still interpreted as "day" but is less flexible.

For example, the joda-time date format `YYYY-MM-dd` accepts `2010-01-01` or
`2010-01-1`.

In java time, you must use the `||` delimiter to provide specify each format:

[source,txt]
--------------------------------------------------
yyyy-MM-dd||yyyy-MM-d
--------------------------------------------------

In java time, `d` also does not accept more than 2 digits. To accept days with more
than two digits, you must include a text literal in your java-time date format.
For example, to parse `2010-01-00001`, you must use the following java-time date format: 

[source,txt]
--------------------------------------------------
yyyy-MM-'000'dd
--------------------------------------------------
--

`e` (Name of day)::
+
--
In java time, `e` is still interpreted as "name of day" but does not parse
short- or full-text forms.

For example, the joda-time date format `EEE YYYY-MM` accepts both
`Wed 2020-01` and `Wednesday 2020-01`.

To accept both of these dates in java time, you must specify each format using
the `||` delimiter: 

[source,txt]
--------------------------------------------------
cccc yyyy-MM||ccc yyyy-MM
--------------------------------------------------

The joda-time literal `E` is interpreted as "day of week."
The java-time literal `c` is interpreted as "localized day of week."
`E` does not accept full-text day formats, such as `Wednesday`.
--

Text forms EEEE and similar::
+
--
Support for full-text forms depends on the locale data provided with your Java
Development Kit (JDK) and other implementation details. We recommend you
test formats containing these patterns carefully before upgrading.
--

`z` (Time zone text)::
+
--
In 7.0 it will print 'Z' for Zulu given UTC timezone.
--

[[java-time-migration-test]]
===== Test with your data

We strongly recommend you test any date format changes using real data before
deploying in production.

For help with date debugging, consider using
https://esddd.herokuapp.com/[https://esddd.herokuapp.com/.]

[[java-time-migrate-update-mappings]]
==== Update index mappings
Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping
and reindex your data to it.
You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.
If you specified a custom date format there, then you need to update it too.

The following `my_index_1` index contains a mapping for the `datetime` field, a
`date` field with a custom joda-time date format.
////
[source,console]
--------------------------------------------------
PUT my_index_1
{
    "mappings" : {
      "properties" : {
         "datetime": {
           "type": "date",
           "format": "yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis"
         }
      }
    }
}
--------------------------------------------------
////

[source,console]
--------------------------------------------------
GET my_index_1/_mapping
--------------------------------------------------
// TEST[continued]

[source,console-result]
--------------------------------------------------
{
  "my_index_1" : {
    "mappings" : {
      "properties" : {
         "datetime": {
           "type": "date",
           "format": "yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis"
         }
      }
    }
  }
}
--------------------------------------------------


To change the date format for the `datetime` field, create a separate index
containing an updated mapping and date format.

For example, the following `my_index_2` index changes the `datetime` field's 
date format to `8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis`. The `8` prefix 
indicates this date format uses java time.

[source,console]
--------------------------------------------------
PUT my_index_2
{
  "mappings": {
    "properties": {
      "datetime": {
        "type": "date",
        "format": "8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis"
      }
    }
  }
}
--------------------------------------------------
// TEST[continued]

* Reindex the deprecated format index to new_index_1

[source,console]
--------------------------------------------------
POST _reindex
{
  "source": {
    "index": "my_index_1"
  },
  "dest": {
    "index": "my_index_2"
  }
}
--------------------------------------------------
// TEST[continued]

If you use index aliases, update them to point to the new index.

[source,console]
--------------------------------------------------
POST /_aliases
{
    "actions" : [
        { "remove" : { "index" : "my_index_1", "alias" : "my_index" } },
        { "add" : { "index" : "my_index_2", "alias" : "my_index" } }
    ]
}
--------------------------------------------------
// TEST[continued]

===== Update before upgrading to ES7.
If your ingest pipelines contain joda-time date formats, you can update them
using the <<put-pipeline-api,put ingest pipeline>> API.

[source,console]
--------------------------------------------------
PUT _ingest/pipeline/mypipeline
{
  "description": "Pipeline for routing data to specific index",
  "processors": [
    {
      "date": {
        "field": "createdTime",
        "formats": [
         "8uuuu-w"
        ]
      },
      "date_index_name": {
        "field": "@timestamp",
        "date_rounding": "d",
        "index_name_prefix": "x-",
        "index_name_format": "8uuuu-w"
      }
    }
  ]
}
--------------------------------------------------


* upgrade template
If your template was using joda date pattern it also should be updated before upgrading to ES7.

[source,console]
--------------------------------------------------
PUT _template/template_1
{
  "index_patterns": [
    "te*",
    "bar*"
  ],
  "settings": {
    "number_of_shards": 1
  },
  "mappings": {
    "_source": {
      "enabled": false
    },
    "properties": {
      "host_name": {
        "type": "keyword"
      },
      "created_at": {
        "type": "date",
        "format": "8EEE MMM dd HH:mm:ss Z yyyy"
      }
    }
  }
}
--------------------------------------------------

////
[source,console]
--------------------------------------------------
DELETE /_template/template_1
--------------------------------------------------
// TEST[continued]
////

===== External templates
Revisit other templates from elastic stack where you used a custom date pattern.
