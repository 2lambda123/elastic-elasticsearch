[[migrate_to_java_time]]
=== Java time migration guide

With 7.0, {es} switch to java time from joda time for date-related parsing,
formatting, and calculations. This guide is designed to help you determine
if your cluster is impacted and, if so, prepare for the upgrade.

Joda style indices are supported in 6.8, but indices created with joda-style patterns in 6.x are also allowed to be used in 7.0
All new indices created in 7.x are expected to be using java-time patterns.

We advice to prepare for this migration in 6.8, but it will also work if you decide to perform it in version 7.x

- In 6.8 you need to prefix your new java.style pattern with `8`. Patterns without `8` are considered joda style.
- In 7.x patterns without `8` on indices *created in 6.x* are considered joda-style.
- Patterns with or without `8` on indices *created in 7.x*  are considered java.style

==== Impacted features
The switch to java time only impacts custom <<date,`date`>> and
<<date_nanos,`date_nanos`>> formats.

These formats are commonly used in:

* <<mapping,Index mappings>>
* <<indices-templates,Index templates>>
* <<pipeline,Ingest pipelines>>

If you don't use custom date formats, you can skip the rest of this guide.
Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.

To see if your date format is impacted, use the <<migration-api-deprecation,deprecation info API>>
or the {kibana-ref}/upgrade-assistant.html[Kibana upgrade assistant]


==== Incompatible formats
Custom date formats containing the following joda time literals should be
changed before upgrading.

`Y` (Year of era)::
+
--
Replace with `y`.

*Example:*
`YYYY-MM-dd` should become `yyyy-MM-dd`

In java time, `Y` is used for
https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html[week-based year].
Using `Y` in place of `y` could result in off-by-one errors in year calculation.


The difference between year-of-era and week based year
For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`
For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019
--

`y` year::
+
--
Replace with `u`.

*Example:*
`yyyy-MM-dd` should become `uuuu-MM-dd`

The difference is that year can contain non positive values, whereas `y` can not. Also year-of-era can also be associated with an era field.
--


`C` century of era::
+
--
No longer supported in 7.0. There is no replacement, so you need to preprocess your input.

A possible workaround https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern
--

`x` week year::
+
--
Replace with `Y`

This is a big change. `x` means https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[zone-offset] in java.time
--

`Z` Zone offset/id::
+
--
Replace with multiple `X`

`Z` has similar meaning in 7.0 with a notable difference that it expects different number of literals to parse different forms.

Consider migrating to `X` which give you more control of how your time is parsed.
For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:

```
2010-01-01T01:02:03Z
2010-01-01T01:02:03+01
2010-01-01T01:02:03+01:02
2010-01-01T01:02:03+01:02:03
```

You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns

```
2010-01-01T01:02:03Z
2010-01-01T01:02:03+01
both parsed with yyyy-MM-dd'T'hh:mm:ssX

2010-01-01T01:02:03+01:02
yyyy-MM-dd'T'hh:mm:ssXXX

2010-01-01T01:02:03+01:02:03
yyyy-MM-dd'T'hh:mm:ssXXXXX
```


If you expect all these combination to occur in your data you need to combine these patterns in 7.0
[source,txt]
--------------------------------------------------
yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX
--------------------------------------------------

The same applies if you expect your pattern to occur without a colon:
Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:
```
2010-01-01T01:02:03Z
2010-01-01T01:02:03+01
2010-01-01T01:02:03+0102
2010-01-01T01:02:03+010203
```
To accept all these forms in java time, you must use the `||` delimiter:
[source,txt]
--------------------------------------------------
yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX
--------------------------------------------------
--

`d` (Day)::
+
--
In java time, `d` is still interpreted as "day" but is less flexible.

For example, the joda-time date format `YYYY-MM-dd` accepts `2010-01-01` or
`2010-01-1`.

In java time, you must use the `||` delimiter to provide specify each format:

[source,txt]
--------------------------------------------------
yyyy-MM-dd||yyyy-MM-d
--------------------------------------------------

In java time, `d` also does not accept more than 2 digits. To accept days with more
than two digits, you must include a text literal in your java-time date format.
For example, to parse `2010-01-00001`, you must use the following java-time date format: 

[source,txt]
--------------------------------------------------
yyyy-MM-'000'dd
--------------------------------------------------
--

`e` (Name of day)::
+
--
The same meaning in 7.0. However it is less flexible in 7.0. It do not allow parsing short and full text forms.

If you used `EEE YYYY-MM` for a format and expected days in form:
`Wed 2020-01` or `Wednesday 2020-01`
then you have to use two combined patterns in 7.0
`cccc yyyy-MM||ccc yyyy-MM`

E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday
--

Text forms EEEE and similar::
+
--
Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.
--

`z` time zone text::
+
--
In 7.0 it will print 'Z' for Zulu given UTC timezone.
--


===== Test with your data
All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.
If you expect your timezone to only be in one form - for instance `+01:00`  (XXX in java, ZZ in joda) -
then there is no need to create a new java pattern with so many alternatives.

Consider using this date debugging site for assistance https://esddd.herokuapp.com/

==== Migrating affected mappings
Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping
and reindex your data to it.
You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.
If you specified a custom date format there, then you need to update it too.

===== Example migration procedure
Let's assume that you have an index with a date field and custom format
////
[source,console]
--------------------------------------------------
PUT my_index_1
{
    "mappings" : {
      "properties" : {
         "datetime": {
           "type": "date",
           "format": "yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis"
         }
      }
    }
}
--------------------------------------------------
////

[source,console]
--------------------------------------------------
GET my_index_1/_mapping
--------------------------------------------------
// TEST[continued]

[source,console-result]
--------------------------------------------------
{
  "my_index_1" : {
    "mappings" : {
      "properties" : {
         "datetime": {
           "type": "date",
           "format": "yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis"
         }
      }
    }
  }
}
--------------------------------------------------


* Create my_index_2 with mappings changed with the format set to `8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis`

[source,console]
--------------------------------------------------
PUT my_index_2
{
  "mappings": {
    "properties": {
      "datetime": {
        "type": "date",
        "format": "8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis"
      }
    }
  }
}
--------------------------------------------------
// TEST[continued]

* Reindex the deprecated format index to new_index_1

[source,console]
--------------------------------------------------
POST _reindex
{
  "source": {
    "index": "my_index_1"
  },
  "dest": {
    "index": "my_index_2"
  }
}
--------------------------------------------------
// TEST[continued]

* If you were using aliases, update them to a new index

[source,console]
--------------------------------------------------
POST /_aliases
{
    "actions" : [
        { "remove" : { "index" : "my_index_1", "alias" : "my_index" } },
        { "add" : { "index" : "my_index_2", "alias" : "my_index" } }
    ]
}
--------------------------------------------------
// TEST[continued]

===== Update before upgrading to ES7.
If your pipelines were using a joda style patterns, they also have to be updated. There is no need to create a new pipeline.
Just update the already existing one.

[source,console]
--------------------------------------------------
PUT _ingest/pipeline/mypipeline
{
  "description": "Pipeline for routing data to specific index",
  "processors": [
    {
      "date": {
        "field": "createdTime",
        "formats": [
         "8uuuu-w"
        ]
      },
      "date_index_name": {
        "field": "@timestamp",
        "date_rounding": "d",
        "index_name_prefix": "x-",
        "index_name_format": "8uuuu-w"
      }
    }
  ]
}
--------------------------------------------------


* upgrade template
If your template was using joda date pattern it also should be updated before upgrading to ES7.

[source,console]
--------------------------------------------------
PUT _template/template_1
{
  "index_patterns": [
    "te*",
    "bar*"
  ],
  "settings": {
    "number_of_shards": 1
  },
  "mappings": {
    "_source": {
      "enabled": false
    },
    "properties": {
      "host_name": {
        "type": "keyword"
      },
      "created_at": {
        "type": "date",
        "format": "8EEE MMM dd HH:mm:ss Z yyyy"
      }
    }
  }
}
--------------------------------------------------


[source,console]
--------------------------------------------------
DELETE /_template/template_1
--------------------------------------------------
// TEST[continued]
* Upgrade to 7.x

===== External templates
Revisit other templates from elastic stack where you used a custom date pattern.
