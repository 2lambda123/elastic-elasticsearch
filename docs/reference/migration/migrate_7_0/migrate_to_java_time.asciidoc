[[migrate_to_java_time]]
=== Java time migration guide

With 7.0, {es} switch to java time from joda time for date-related parsing,
formatting, and calculations. This guide is designed to help you determine
if your cluster is impacted and, if so, prepare for the upgrade.

==== Impacted features
The switch to java time only impacts custom <<date,`date`>> and
<<date_nanos,`date_nanos`>> formats.

 These formats are commonly used in:

* <<mapping,Index mappings>>
* <<indices-templates,Index templates>>
* <<pipeline,Ingest pipelines>>

If you don't use custom date formats, you can skip the rest of this guide.
Most of the custom date formats are compatible, but with some there is a change of meaning or missing. More on that below.
A custom format is specified on a date field like this:
[source,console]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "properties": {
      "date": {
        "type":   "date",
        "format": "YYYY/MM/dd HH:mm:ss||YYYY/MM/dd||epoch_millis"
      }
    }
  }
}
--------------------------------------------------

To make sure if any of the date formats is deprecated run deprecation API or kibana upgrade assistant.
//todo fix this
xx migration-api-deprecation xx
xxinclude ::../apis/deprecation.asciidoc

Sample output of deprecation api will be as follows:
[source,text]
--------------------------------------------------
This index has date fields with deprecated formats: [[type: doc, field: param2, format: yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis, suggestion: 'y' year should be replaced with 'u'. Use 'y' for year-of-era.]]. Prefix your date format with '8' to use the new specifier.
--------------------------------------------------


==== Incompatible formats
Custom date formats containing the following joda time literals should be
changed before upgrading.

===== Y - in 6.8 meaning Year of era. It should be replaced to y in 7.0 This is a big change because in 7.0 'Y' means week-based-year.
If you don't update your date pattern, you will have problems with search results, parsing and date calculations.
example:
`YYYY-MM-dd` should become `yyyy-MM-dd`

====== The difference between year-of-era and week based year
For pattern `YYYY-ww` and date `2019-01-01T00:00:00.000Z`  will give `2019-01`
For pattern `YYYY-ww` and date `2018-12-31T00:00:00.000Z`  will give `2019-01` (counter intuitive) because there is >4 days of that week in 2019

===== y - in 6.8 meaning year. It should be replaced to 'u' in 7.0. This is a subtle change, but worth fixing.
As previously stated `y` means year-of-era. `u` means year. The difference is that year can contain non positive values, whereas `y` can not. //clarify 0 year
year-of-era can also be associated with an era field.

===== C - century of era is no longer supported in 7.0. There is no replacement, so you need to preprocess your input.
https://stackoverflow.com/questions/38354151/how-to-force-java-time-localdate-to-assume-19th-century-as-yy-year-pattern

===== x - in 6.8 meaning week year. It should be replaced with 'Y' in 7.0. Again a big change as 'x' means zone-offset in 7.0.
You will get parsing and search problems if you do not update this.

===== Z - in 6.8 meaning time zone offset/id. It has similar meaning in 7.0 with a notable difference that it expects different number of literals
to parse different forms.
It also won't parse `Z` for Zulu timezone. You should consider migrating to `X` which give you more control of how your time is parsed.
For instance format `YYYY-MM-dd'T'hh:mm:ssZZ` allowed all the forms below:

```
2010-01-01T01:02:03Z
2010-01-01T01:02:03+01
2010-01-01T01:02:03+01:02
2010-01-01T01:02:03+01:02:03
```


You cannot parse them all with one pattern in 7.0. You need to specify 3 separate patterns
```
2010-01-01T01:02:03Z
2010-01-01T01:02:03+01
both parsed with yyyy-MM-dd'T'hh:mm:ssX

2010-01-01T01:02:03+01:02
yyyy-MM-dd'T'hh:mm:ssXXX

2010-01-01T01:02:03+01:02:03
yyyy-MM-dd'T'hh:mm:ssXXXXX
```


If you expect all these combination to occur in your data you need to combine these patterns in 7.0
[source,txt]
--------------------------------------------------
yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXXX||yyyy-MM-dd'T'hh:mm:ssXXXXX
--------------------------------------------------


The same applies if you expect your pattern to occur without a colon:
Pattern `YYYY-MM-dd'T'hh:mm:ssZ` accepting these dates:
```
2010-01-01T01:02:03Z
2010-01-01T01:02:03+01
2010-01-01T01:02:03+0102
2010-01-01T01:02:03+010203
```
should be migrated to
[source,txt]
--------------------------------------------------
yyyy-MM-dd'T'hh:mm:ssX||yyyy-MM-dd'T'hh:mm:ssXX||yyyy-MM-dd'T'hh:mm:ssXXXX
--------------------------------------------------

===== d for day.
This one have the same meaning in 7.0 but are less flexible.
If your pattern was `YYYY-MM-dd` in 6.8 and you expects dates in form
`2010-01-01` or `2010-01-1`
You will need to provide an alternative pattern for all of these.
`yyyy-MM-dd||yyyy-MM-d`
More then 2 digits are not allowed anymore. If you want to parse dates like `2010-01-00001` you need to create a pattern that expects a text literal `'000'` before `'d'`
`yyyy-MM-'000'dd`

===== e for name of day
Also has a similar meaning in 7.0. However was more flexible in 6.8 and allowed to parse short and full text forms.
if you used `EEE YYYY-MM` for a format and expected days in form:
Wed 2020-01 or Wednesday 2020-01
then you have to use two combined patterns in 7.0
`cccc yyyy-MM||ccc yyyy-MM`

E vs c. E means day-of-week vs c is for localized day-of-week. The difference is that E won't behave correctly for full text forms like Wednesday

===== more on text forms EEEE and similar
Full text forms are depending on locale data provided with JDK and the implementation details of java vs joda. You should test carefully before upgrading these patterns.

===== 'z'
'z' time zone text. Will print 'Z' for Zulu given UTC timezone.


===== Test with your data
All of the examples above should be tested with real data. It is likely that you do not need the flexibility joda was giving.
If you expected your timezone to only be in `+01:00` form (XXX in java, ZZ in joda),
then there is no need to create a new java pattern with so many alternatives.

Consider using this date debugging site for assistance https://esddd.herokuapp.com/

==== Migrating affected mappings
Once an index is created with a mapping, it cannot change already existing fields. You need to create a new index with updated mapping
and reindex your data to it.
You can however update your pipelines or templates. Remember to look for templates you use with tools outside ES.
If you specified a custom date format there, then you need to update it too.

===== Example migration procedure
Let's assume that you have an index with a date field and custom format
////
[source,console]
--------------------------------------------------
PUT my_index_1
{
    "mappings" : {
      "properties" : {
         "datetime": {
           "type": "date",
           "format": "yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis"
         }
      }
    }
}
--------------------------------------------------
////

[source,console]
--------------------------------------------------
GET my_index_1/_mapping
--------------------------------------------------
// TEST[continued]

[source,console-result]
--------------------------------------------------
{
  "my_index_1" : {
    "mappings" : {
      "properties" : {
         "datetime": {
           "type": "date",
           "format": "yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis"
         }
      }
    }
  }
}
--------------------------------------------------
// NOTCONSOLE


* Create my_index_2 with mappings changed with the format set to 8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis

[source,console]
--------------------------------------------------
PUT my_index_2
{
  "mappings": {
    "properties": {
      "datetime": {
        "type": "date",
        "format": "8uuuu/MM/dd HH:mm:ss||uuuu/MM/dd||epoch_millis"
      }
    }
  }
}
--------------------------------------------------
// TEST[continued]

* Reindex the deprecated format index to new_index_1

[source,console]
--------------------------------------------------
POST _reindex
{
  "source": {
    "index": "my_index_1"
  },
  "dest": {
    "index": "my_index_2"
  }
}
--------------------------------------------------
// TEST[continued]

* If you were using aliases, update them to a new index

[source,console]
--------------------------------------------------
POST /_aliases
{
    "actions" : [
        { "remove" : { "index" : "my_index_1", "alias" : "my_index" } },
        { "add" : { "index" : "my_index_2", "alias" : "my_index" } }
    ]
}
--------------------------------------------------
// TEST[continued]

===== Update before upgrading to ES7.
* update pipeline
If your pipelines were using a joda style patterns, they also have to be updated. There is no need to create a new pipeline.
Just update the already existing one.

[source,console]
--------------------------------------------------
PUT _ingest/pipeline/mypipeline
{
  "description": "Pipeline for routing data to specific index",
  "processors": [
    {
      "date": {
        "field": "createdTime",
        "formats": [
         "8uuuu-w"
        ]
      },
      "date_index_name": {
        "field": "@timestamp",
        "date_rounding": "d",
        "index_name_prefix": "x-",
        "index_name_format": "8uuuu-w"
      }
    }
  ]
}
--------------------------------------------------


* upgrade template
If your template was using joda date pattern it also should be updated before upgrading to ES7.

[source,console]
--------------------------------------------------
PUT _template/template_1
{
  "index_patterns": [
    "te*",
    "bar*"
  ],
  "settings": {
    "number_of_shards": 1
  },
  "mappings": {
    "_source": {
      "enabled": false
    },
    "properties": {
      "host_name": {
        "type": "keyword"
      },
      "created_at": {
        "type": "date",
        "format": "8EEE MMM dd HH:mm:ss Z yyyy"
      }
    }
  }
}
--------------------------------------------------

////

[source,console]
--------------------------------------------------
DELETE /_template/template_1
--------------------------------------------------
// TEST[continued]
* Upgrade to 7.x

===== External templates
Revisit other templates from elastic stack where you used a custom date pattern.
