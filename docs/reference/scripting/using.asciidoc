[[modules-scripting-using]]
== How to write scripts

Wherever scripting is supported in the {es} APIs, the syntax follows the same
pattern:

[source,js]
-------------------------------------
  "script": {
    "lang":   "...",
    "source" | "id": "...",
    "params": { ... }
  }
-------------------------------------
// NOTCONSOLE

`lang`::

    Specifies the language the script is written in. Defaults to `painless`.

`source`, `id`::

    Specifies the source of the script. An `inline` script is specified as `source` in the previous example. A `stored` script is specified by `id` and is retrieved from the cluster state using the `_scripts` endpoint.

`params`::

    Specifies any named parameters that are passed into the script as
    variables. <<prefer-params,Use parameters>> instead of hard-coded values to decrease compile time.

[discrete]
[[hello-world-script]]
=== Write your first script
<<modules-scripting-painless,Painless>> is the default scripting language
for {es}. It is secure, performant, and provides a natural syntax for anyone
with a little coding experience.

A Painless script is structured as one or more statements and optionally
has one or more user-defined functions at the beginning. A script must always
have at least one statement.

The {painless}/painless-execute-api.html[Painless execute API] provides the ability to
test a script with simple user-defined parameters and receive a result. Let's
start with a simple script and review its constituent parts.

[source,console]
----
POST /_scripts/painless/_execute <1>
{
  "script": { <2>
    "source": "return 'Hello, world!';" <3>
  }
}
----
<1> Request URL
<2> `script` object
<3> `script` source

The request URL partially determines what script _contexts_ are available.
Contexts control how scripts run, what variables are available when
the script runs, and what the return type is.

We're using the Painless execute API without any URL parameters, which uses
the `painless_test` context by default. This context optionally makes
available a `Map` of user-defined parameters, and then returns a value as an
`Object`. `Map` and `Object` are known as _types_, which we'll discuss more
later on.

The `script` is a standard JSON object that defines scripts under most APIs
in {es}. This object requires `source` to define the script itself. The
example script doesn't specify a language, so it uses Painless by default.

The `source` defines the script itself. The example `source` returns a
`String` value of `Hello, world!`, converts the string to an `Object`, and
displays the output.

[discrete]
[[script-add-parameters]]
=== Add parameters to your script
Now that you have a simple script, we'll introduce parameters to pass in
variables. Using named `params` instead of hard-coding values makes scripts
flexible, and also reduces compilation time when the script runs.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": "return params.get('hello_world');", <1>
    "lang": "painless", <2>
    "params": { <3>
        "hello_world": "Hello, world!"
    }
  }
}
----
<1> Script `source`
<2> Language declaration
<3> `Map` of user-defined parameters

Our script now contains a `Map` of user-defined parameters. The `get` method
accesses a value using the `String` key of the `hello_world` parameter.

We'll explicitly specify the `Painless` language, even though that's the
default language.

The `params` section is where things get interesting. This part of the script
is where you pass in user-defined parameters, which are written as a JSON
object that is parsed into a `Map`. Our script defines a key of `hello_world`
with a `String` value of `Hello, world!`. We then access this value within
the example script.

[discrete]
[[script-shorten-syntax]]
=== Shorten your script
Using syntactic abilities that are native to Painless, you can reduce verbosity
in your scripts and make them shorter.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": "params['hello_world']",
    "params": {
        "hello_world": "Hello, world!"
    }
  }
}
----

This version of the script removes several components:

* The `return` keyword. Painless automatically uses the final statement in a
script (when possible) to produce a return value in a script context that
requires one.
* The semicolon at the end of the `source` statement. Painless does not
require semicolons for the final statement of a block. However, it does require
them in other cases to remove ambiguity.
* The `get` method, which is replaced with brackets `[]`. Painless
uses a shortcut specifically for the `Map` type that allows us to use brackets
instead of the lengthier `get` method.

[discrete]
[[script-whats-next]]
=== What's next
Now that you've learned the basic syntax of a Painless script, we'll dig more
into the language itself. Understanding the building blocks of the language
will help you to construct more complex and powerful scripts.

<<script-spec-variables,Learn about variables>>

[[script-spec-variables]]
=== Variables
A variable loads and stores a value for evaluation during operations. A
variable not immediately assigned a value will have a default value assigned
implicitly based on the type. We'll cover types in the next section.

When using variables, you declare a variable, specify a type, and assign
values to the variable. The following example declares a variable `my_int` of
type `int`, and assigns it a value of `1`:

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        int my_int;
        my_int = 1;
    """
  }
}
----

When declaring a variable, specify the type followed by an identifier. After
declaring variables, you can use them in scripts by referring to their
identifier.

Use the assignment operator `=` to store a value in a variable for use in
subsequent operations. Any operation that produces a value can be assigned to
any variable as long as the types are the same, or the resultant type can be
implicitly cast to the variable type.

[discrete]
[[variables-whats-next]]
=== What's next
Now that you understand variables, you can learn about the data types that
Painless supports. When you declare a variable, you assign it a supported type.

<<script-spec-types,Learn about types>>

[[script-spec-types]]
=== Types
A type is a classification of data used to define the properties of a value.
These properties specify what data a value represents and the rules for how a
value is evaluated during an operation. Each type belongs to one of the
following categories: primitive, reference, or dynamic.

[[script-type-primitive]]
==== Primitive types
A primitive type holds a singular piece of data. Examples of
{painless}/painless-types.html#primitive-types[available primitive types] are
`byte`, `int`, and `long`. Primitive types can also specify the size and type
of a variable value. For example, an `int` is 32-bit and stores whole numbers,
whereas a `double` is 64-bit and stores fractional numbers.

The following example declares three primitive types:

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        int my_int; <1>
        my_int = 1; <2>
        double my_double = 2.0; <3>
    """
  }
}
----
<1> Primitive `int` type declaration
<2> Primitive `int` type assignment with an `int` constant
<3> Primitive `double` type declaration with assignment of a `double` constant

You can declare a primitive type <<script-spec-variables,variable>> or access a
primitive type member field from a reference type instance, and assign it a
primitive type value for evaluation during later operations.

Use the field access operator or method call operator on a primitive type value
to force evaluation as its corresponding reference type value.

[[script-type-reference]]
==== Reference types
A reference type is a complex structure that can represent multiple pieces of
data and logic to manipulate that data. Reference types hold references to
objects and provide a way to access them. You define reference types as part of
the API for scripts.

Reference types have methods and fields available to modify internal state. You
cannot define new types, but can call any of the available types in the API's
allowlist. For example, let's assume that the allowlist contains an `Example`
reference type with the following definition:

[source,java]
----
class Example {
   int my_int;
   double my_double;
   def add(); <1>
}
----
<1> This operation adds together the `my_int` and `my_double` variables.

To use the `Example` reference type, you create a new instance of `Example`
that we'll name `my_example`. To call the `Example` method, include the
{painless}/painless-operators-reference.html[method call operator] `()`, which
in this example is `Example()`.

You can then define this new instance. The following example declares two
primitive types named `my_int` and `my_double`, assigns them each a value, and
includes them in the `my_example` reference type.

[source,painless]
----
Example my_example = new Example() <1>
my_example.my_int = 1; <2>
my_example.my_double = 2; <3>
double my_add = my_example.add();
----
<1> Create a new instance of `Example`
<2> Declare `my_int` as part of the `my_example` reference type
<3> Declare `my_double` as part of the `my_example` reference type

That's a brief overview of how reference types are structured within Painless,
but what you really need to know is how to use reference types.

[discrete]
===== How to use reference types
What if you want to modify the types and values that are part of a reference
type? That's where you can leverage the magic of reference types! You can have
multiple reference type values that point to the _same_ instance, which means
you don't have to modify the instance itself.

For example, the following statement creates two new reference types:
`my_example1` and `my_example2`:

[source,painless]
----
Example my_example1 = new Example(); <1>
Example my_example2 = my_example1; <2>
my_example2.my_int = 4;
----
<1> `my_example1` creates a new instance of `Example`.
<2> `my_example2` creates a new instance of `my_example1`.

By creating a new instance of `Example`, `my_example1` references `Example`
and inherits all of the data and logic that it contains.

Similarly, `my_example2` references `my_example1` and inherits everything it
contains. Even though `my_example2` references `my_example1`, you can
modify `my_example2` without impacting `my_example1`.

Looking back, `Example` indicates that `my_example.my_int = 1`. The last line
in the previous statement modifies the value of that variable by setting the
value of `my_int` to `4`. The `Example` reference type includes the following
definitions:

[source,painless]
----
my_example.my_int = 1;
my_example.my_double = 2;
double my_add = my_example.add();
----

The `my_add` variable would return `3` because it adds the values of
`my_example.my_int` (`1`) and `my_example.my_double` (`2`). However,
`my_example2` would return `6`, because the value of `my_example2.my_int` is
now `4` and the value of `my_example.my_double` is `2`.

By creating a new reference type, you can access existing objects and build
logic on top of them without changing how they operate.

[[script-type-dynamic]]
==== Dynamic types
A dynamic type can represent the value of any primitive type or reference type
using a single type named `def`. A `def` type value mimics the behavior of
whatever value it represents at runtime. Because a `def` type can mimic
multiple types, it always represents the last child descendant type value of
any type value when evaluated.

To access a `def` type variable, declare the variable or access a reference
type member field from an instance. You can then assign the variable
a value and reference the variable in various operations. The default value for
a newly-declared `def` type variable is `null`.

NOTE: Using the `def` type can have a slight impact on performance. Use only
primitive types and reference types directly when performance is critical.

[discrete]
===== How to use dynamic types
So how do dynamic types work in practice? Let's look at a basic example. The
following script creates a `List` named `x` and adds `1` to the list.
The script then declares an `int` named `y` and says that it's equal to an `int`
named `x`.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        List x = []; <1>
        x.add(1);
        int y = (int)x[0];
        y.toString();
    """
  }
}
----
<1> The brackets `[]` indicate that this is an empty list.

We can simplify that request by using `def`. Instead of explicitly declaring
a variable named `y` and equating it to `x`, we can say that `def y = x[0]`.
Now, the `y` variable will mimic `x` however it's defined.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        List x = [];
        x.add(1);
        def y = x[0];
        y.toString();
    """
  }
}
----

[discrete]
===== How to _really_ use dynamic types
So a `def` type is just another way to shorten scripts, right? True, but the
real magic is that a `def` type variable can change the type it represents
during the compilation and evaluation of a script. This capability is incredibly
powerful when your script is retrieving data, especially `_doc` values.

We'll talk more about retrieving data later on, but the main takeaway relating
to `def` values is this: you don't really need to know what primitive type your
data is; you can just call a `def` type and then start operating on the data.

For example, the following request starts with a list that includes primitive
types of `int`, `double`, and `String`. The request then declares an empty
`String` and introduces a `for` loop. This loop iterates through the values in
the list and changes the value three times:

* `1` is an `int`
* `2.0` is a `double`
* `'3'` is a `string`

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
      List list = [1, 2.0, '3'];
      String string = "";
      for (def value : list) {
        string += value.toString();
        }
    """
  }
}
----

The type changes occur automatically without doing anything other than using
`def` and iterating through the values. Painless changes the type for you so
that you can focus on writing your script without worrying about what your data
type is.

[discrete]
[[types-whats-next]]
==== What's next
These types are the most basic structures in Painless. There are {painless}/painless-types.html[other types] that you can learn about as you script writing
skills develop. Now that you've learned about types and variables, you can
start combining them with operators.

<<script-spec-operators,Learn about operators>>

[[script-spec-operators]]
=== Operators
An operator is the most basic action to evaluate variables and values in a
script. Painless offers basic operators for numeric computations
such as addition, division, and subtraction, but also provides operators for
comparisons, conditionals, and {painless}/painless-operators.html[much more].

An _expression_ is one-to-many consecutive operations. For example, a basic
expression can declare a variable and complete a simple arithmetic operation:

[source,painless]
----
int x = 5+4
----

_Precedence_ is the order in which an operator is evaluated relative to another
operator. Parentheses `()` indicate precendence, meaning the expression in
parentheses is evaluated first. An expression in parentheses overrides existing
precedence relationships between operators. The following expression indicates
that the addition operation should occur first:

[source,painless]
----
int x = (5+4)*6
----

Associativity is the direction within an expression in which a specific
operator is evaluated. The following expression indicates that value for `x` is
calculated first before evaluating `y`. This means that `x = 54`, and that
value is passed into the expression for `y`.

The expression in parentheses takes precedence `(x-50)`, resulting in `54-50`,
which equals `4`. Divide `12/4` and the result of the entire expression equals
`3`, which is stored to the `y` variable.

[source,painless]
----
int x = (5+4)*6
int y = 12/(x-50)
----
