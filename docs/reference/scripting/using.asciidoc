[[modules-scripting-using]]
== How to write scripts

Wherever scripting is supported in the {es} APIs, the syntax follows the same
pattern:

[source,js]
-------------------------------------
  "script": {
    "lang":   "...",
    "source" | "id": "...",
    "params": { ... }
  }
-------------------------------------
// NOTCONSOLE

`lang`::

    Specifies the language the script is written in. Defaults to `painless`.

`source`, `id`::

    Specifies the source of the script. An `inline` script is specified as `source` in the previous example. A `stored` script is specified by `id` and is retrieved from the cluster state using the `_scripts` endpoint.

`params`::

    Specifies any named parameters that are passed into the script as
    variables. <<prefer-params,Use parameters>> instead of hard-coded values to decrease compile time.

[discrete]
[[hello-world-script]]
=== Write your first script
<<modules-scripting-painless,Painless>> is the default scripting language
for {es}. It is secure, performant, and provides a natural syntax for anyone
with a little coding experience.

A Painless script is structured as one or more statements and optionally
has one or more user-defined functions at the beginning. A script must always
have at least one statement.

The {painless}/painless-execute-api.html[Painless execute API] provides the ability to
test a script with simple user-defined parameters and receive a result. Let's
start with a simple script and review its constituent parts.

[source,console]
----
POST /_scripts/painless/_execute <1>
{
  "script": { <2>
    "source": "return 'Hello, world!';" <3>
  }
}
----
<1> Request URL
<2> `script` object
<3> `script` source

The request URL partially determines what script _contexts_ are available.
Contexts control how scripts run, what variables are available when
the script runs, and what the return type is.

We're using the Painless execute API without any URL parameters, which uses
the `painless_test` context by default. This context optionally makes
available a `Map` of user-defined parameters, and then returns a value as an
`Object`. `Map` and `Object` are known as _types_, which we'll discuss more
later on.

The `script` is a standard JSON object that defines scripts under most APIs
in {es}. This object requires `source` to define the script itself. The
example script doesn't specify a language, so it uses Painless by default.

The `source` defines the script itself. The example `source` returns a
`String` value of `Hello, world!`, converts the string to an `Object`, and
displays the output.

[discrete]
[[script-add-parameters]]
=== Add parameters to your script
Now that you have a simple script, we'll introduce parameters to pass in
variables. Using named `params` instead of hard-coding values makes scripts
flexible, and also reduces compilation time when the script runs.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": "return params.get('hello_world');", <1>
    "lang": "painless", <2>
    "params": { <3>
        "hello_world": "Hello, world!"
    }
  }
}
----
<1> Script `source`
<2> Language declaration
<3> `Map` of user-defined parameters

Our script now contains a `Map` of user-defined parameters. The `get` method
accesses a value using the `String` key of the `hello_world` parameter.

We'll explicitly specify the `Painless` language, even though that's the
default language.

The `params` section is where things get interesting. This part of the script
is where you pass in user-defined parameters, which are written as a JSON
object that is parsed into a `Map`. Our script defines a key of `hello_world`
with a `String` value of `Hello, world!`. We then access this value within
the example script.

[discrete]
[[script-shorten-syntax]]
=== Shorten your script
Using syntactic abilities that are native to Painless, you can reduce verbosity
in your scripts and make them shorter.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": "params['hello_world']",
    "params": {
        "hello_world": "Hello, world!"
    }
  }
}
----

This version of the script removes several components:

* The `return` keyword. Painless automatically uses the final statement in a
script (when possible) to produce a return value in a script context that
requires one.
* The semicolon at the end of the `source` statement. Painless does not
require semicolons for the final statement of a block. However, it does require
them in other cases to remove ambiguity.
* The `get` method, which is replaced with brackets `[]`. Painless
uses a shortcut specifically for the `Map` type that allows us to use brackets
instead of the lengthier `get` method.

[discrete]
[[script-whats-next]]
=== What's next
Now that you've learned the basic syntax of a Painless script, we'll dig more
into the language itself. Understanding the building blocks of the language
will help you to construct more complex and powerful scripts.

<<script-spec-variables,Learn about variables>>

[[script-spec-variables]]
=== Variables
A variable loads and stores a value for evaluation during operations. A
variable not immediately assigned a value will have a default value assigned
implicitly based on the type. We'll cover types in the next section.

When using variables, you declare a variable, specify a type, and assign
values to the variable. The following example declares a variable `my_int` of
type `int`, and assigns it a value of `1`:

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        int my_int;
        my_int = 1;
    """
  }
}
----

When declaring a variable, specify the type followed by an identifier. After
declaring variables, you can use them in scripts by referring to their
identifier.

Use the assignment operator `=` to store a value in a variable for use in
subsequent operations. Any operation that produces a value can be assigned to
any variable as long as the types are the same, or the resultant type can be
implicitly cast to the variable type.

[discrete]
[[variables-whats-next]]
=== What's next
Now that you understand variables, you can learn about the data types that
Painless supports. When you declare a variable, you assign it a supported type.

<<script-spec-types,Learn about types>>

[[script-spec-types]]
=== Types
A type is a classification of data used to define the properties of a value.
These properties specify what data a value represents and the rules for how a
value is evaluated during an operation. Each type belongs to one of the
following categories: primitive, reference, or dynamic.

[[script-type-primitive]]
==== Primitive types
A primitive type holds a singular piece of data. Examples of
{painless}painless-types.html#primitive-types[available primitive types] are
`byte`, `int`, and `long`. Primitive types can also specify the size and type
of a variable value. For example, an `int` is 32-bit and stores whole numbers,
whereas a `double` is 64-bit and stores fractional numbers.

The following example builds on the previous one, but adds a declaration for a
`double` primitive type:

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        int my_int; <1>
        my_int = 1; <2>
        double my_double = 2.0; <3>
    """
  }
}
----
<1> Primitive `int` type declaration
<2> Primitive `int` type assignment with an `int` constant
<3> Primitive `double` type declaration with assignment of a `double` constant

You can declare a primitive type <<script-spec-variables,variable>> or access a
primitive type member field from a reference type instance, and assign it a
primitive type value for evaluation during later operations.

Use the field access operator or method call operator on a primitive type value
to force evaluation as its corresponding reference type value.

[[script-type-reference]]
==== Reference types
A reference type is a complex structure that can represent multiple pieces of
data and logic to manipulate that data. Reference types hold references to
objects and provide a way to access those objects. You define reference types as
part of the API for scripts.

Reference types are complex types that have method and fields available to
modify internal state. You cannot define new types, but can call any of the
available types in the API's allowlist. For example, let's assume that the
allowlist contains an `Example` reference type with the following definition:

[source,java]
----
class Example {
   int my_int;
   double my_double;
   def add(); <1>
}
----
<1> This operation adds together the `my_int` and `my_double` variables.

To use the `Example` reference type, you create a new instance of `Example`
named `my_example`. You can then define this new instance. The following
example declares two primitive types named `my_int` and `my_double`, assigns
them each a valie, and includes them in the `my_example` reference type.

[source,painless]
----
Example my_example = new Example() <1>
my_example.my_int = 1; <2>
my_example.my_double = 2; <3>
double my_add = my_example.add();
----
<1> Create a new instance of `Example`
<2> Declare `my_int` as part of the `my_example` reference type
<3> Declare `my_double` as part of the `my_example` reference type

[discrete]
===== How to use reference types
What if you want to modify the types and values that are part of a reference
type? That's where you can leverage the magic of reference types! You can have
multiple reference type values that point to the _same_ instance, which means
you don't have to modify the instance itself.

The following example creates two new reference types: `my_example1` and
`my_example2`:

[source,painless]
----
Example my_example1 = new Example(); <1>
Example my_example2 = my_example1; <2>
my_example2.my_int = 4;
----
<1> `my_example1` creates a new instance of `Example`.
<2> `my_example2` creates a new instance of `my_example1`.

By creating a new instance of `Example`, `my_example1` references `Example`
and inherits all of the data and logic that it contains.

Similarly, `my_example2` references `my_example1` and inherits everything it
contains. However, even though `my_example2` references `my_example1`, you can
modify `my_example2` without impacting `my_example1`.

Looking back, `Example` indicates that `my_example.my_int = 1`. The last line
in the previous statement modifies the value of that variable by setting the
value of `my_int` to `4`.

[[script-type-dynamic]]
==== Dynamic types
A dynamic type can represent the value of any primitive type or reference type
using a single type named `def`. A `def` type value mimics the behavior of
whatever value it represents at runtime, and always represents the last child
descendant type value of any type value when evaluated.

To access a `def` type _variable_, declare the variable or access a
reference type member field from an instance. You can then assign the variable
a value and reference the variable in various operations. The default value for
a newly-declared `def` type variable is `null`.

Let's implement a `def` type to the previous example. You can declare the
primitive type `int`, name it `my_int`, and then assign it avalue of `1`:

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        int my_int;
        my_int = 1;
    """
  }
}
----

Instead, you can use a `def` type variable to simplify the declaration:

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        def my_int = 1;
    """
  }
}
----

This declaration declares a `def` type named `my_int` and assigns it a value of
`1` in a single statement. Because a `def` type can mimic a primitive type,
this statement implicitly casts `my_int` as type `int` without having to
declare it.

NOTE: Using the `def` type can have a slight impact on performance. Use only
primitive types and reference types directly when performance is critical.

[discrete]
[[types-whats-next]]
==== What's next
These types are the most basic structures in Painless, and there are other
types that you can learn about when writing scripts. Now that you've learned
about types, you can start declaring variables and assigning types to them.

<<script-spec-variables,Learn about variables>>

[[script-spec-operators]]
=== Operators
An operator is the most basic action that can be taken to evaluate variables
and values in a script. Painless offers basic operators for numeric computations
such as addition, division, and subtraction, but also provides operators for
comparisons, conditionals, and {painless}/painless-operators.html[much more].

An expression is one-to-many consecutive operations. Precedence is the
order in which an operator will be evaluated relative to another operator.
Associativity is the direction within an expression in which a specific
operator is evaluated.

The following example introduces a basic expression with arithmetic operators.
The parentheses `()` indicate precendence, meaning the expression in
parentheses will be evaluated first.

[[script-spec-statements]]
=== Statements


[[script-spec-functions]]
=== Functions
