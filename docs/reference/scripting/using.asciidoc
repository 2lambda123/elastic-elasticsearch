[[modules-scripting-using]]
== How to write scripts

Wherever scripting is supported in the {es} APIs, the syntax follows the same
pattern:

[source,js]
-------------------------------------
  "script": {
    "lang":   "...",
    "source" | "id": "...",
    "params": { ... }
  }
-------------------------------------
// NOTCONSOLE

`lang`::

    Specifies the language the script is written in. Defaults to `painless`.

`source`, `id`::

    Specifies the source of the script. An `inline` script is specified as `source` in the previous example. A `stored` script is specified by `id` and is retrieved from the cluster state (see <<modules-scripting-stored-scripts,Stored Scripts>>).

`params`::

    Specifies any named parameters that are passed into the script as
    variables. <<prefer-params,Use parameters>> instead of hard-coded values to decrease compile time.

[discrete]
[[hello-world-script]]
=== Write your first script
<<modules-scripting-painless,Painless>> is the default scripting language
for {es}. It is secure, performant, and provides a natural syntax for anyone
with a little coding experience.

A Painless script is structured as one or more statements and optionally
has one or more user-defined functions at the beginning. A script must always
have at least one statement.

The {painless}/painless-execute-api.html[Painless execute API] provides the ability to
test a script with simple user-defined parameters and receive a result. Let's
start with a simple script and review its constituent parts.

[source,console]
----
POST /_scripts/painless/_execute <1>
{
  "script": { <2>
    "source": "return 'Hello, world!';" <3>
  }
}
----
<1> Request URL
<2> `script` object
<3> `script` source

The request URL partially determines what script _contexts_ are available.
Contexts control how scripts run, what variables are available when
the script runs, and what the return type is.

We're using the Painless execute API without any URL parameters, which uses
the `painless_test` context by default. This context optionally makes
available a `Map` of user-defined parameters, and then returns a value as an
`Object`. `Map` and `Object` are known as _types_, which we'll discuss more
later on.

The `script` is a standard JSON object that defines scripts under most APIs
in {es}. This object requires `source` to define the script itself. The
example script doesn't specify a language, so it uses Painless by default.

The `source` defines the script itself. The example `source` returns a
`String` value of `Hello, world!`, converts the string to an `Object`, and
displays the output.

[discrete]
[[script-add-parameters]]
=== Add parameters to your script
Now that you have a simple script, we'll introduce parameters to pass in
variables. Using named `params` instead of hard-coding values makes scripts
flexible, and also reduces compilation time when the script runs.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": "return params.get('hello_world');", <1>
    "lang": "painless", <2>
    "params": { <3>
        "hello_world": "Hello, world!"
    }
  }
}
----
<1> Script `source`
<2> Language declaration
<3> `Map` of user-defined parameters

Our script now contains a `Map` of user-defined parameters. The `get` method
accesses a value using the `String` key of the `hello_world` parameter.

We'll explicitly specify the `Painless` language, even though that's the
default language.

The `params` section is where things get interesting. This part of the script
is where you pass in user-defined parameters, which are written as a JSON
object that is parsed into a `Map`. Our script defines a key of `hello_world`
with a `String` value of `Hello, world!`. We then access this value within
the example script.

[discrete]
[[script-shorten-syntax]]
=== Shorten your script
Using syntactic abilities that are native to Painless, you can reduce verbosity
in your scripts and make them shorter.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": "params['hello_world']",
    "params": {
        "hello_world": "Hello, world!"
    }
  }
}
----

This version of the script removes several components:

* The `return` keyword. Painless automatically uses the final statement in a
script (when possible) to produce a return value in a script context that
requires one.
* The semicolon at the end of the `source` statement. Painless does not
require semicolons for the final statement of a block. However, it does require
them in other cases to remove ambiguity.
* The `get` method, which is replaced with brackets `[]`. Painless
uses a shortcut specifically for the `Map` type that allows us to use brackets
instead of the lengthier `get` method.

[discrete]
[[script-whats-next]]
=== What's next
Now that you've learned the basic syntax of a Painless script, we'll dig more
into the language itself. Understanding the building blocks of the language
will help you to construct more complex and powerful scripts.

<<script-spec-types,Learn about types>>

[[script-spec-types]]
=== Types
A type is a classification of data used to define the properties of a value.
These properties specify what data a value represents and the rules for how a
value is evaluated during an operation. Each type belongs to one of the
following categories: primitive, reference, or dynamic.

[discrete]
[[script-type-primitive]]
==== Primitive types
A primitive type represents basic data built natively into the JVM and is
allocated to non-heap memory. Examples of
<<available-primitive-types,available primitive types>> are `byte`, `int`, and
`long`.

A primitive type value is copied during an assignment or as an argument for a
method or function call. Each primitive type has a corresponding reference type
(or boxed type) as shown in the following list. For example, the reference type
for `byte` is `Byte`.

[[available-primitive-types]]
.**Available primitive types**
[%collapsible]
====
`byte` (`Byte`)::
    8-bit, signed, two's complement integer. Range: [`-128`, `127`]. Default: `0`.

`short` (`Short`)::
    16-bit, signed, two's complement integer. Range: [`-32768`, `32767`]. Default: `0`.

`char` (`Character`)::
    16-bit, unsigned, Unicode character. Range: [`0`, `65535`]. Default: `0` or `\u0000`.

`int` (`Integer`)::
    32-bit, signed, two's complement integer. Range: [`-2^31`, `2^31-1`]. Default: `0`.

`long` (`Long`)::
    64-bit, signed, two's complement integer. Range: [`-2^63`, `2^63-1`]. Default: `0`.

`float (`Float`)`::
    32-bit, signed, single-precision, IEEE 754 floating point number. Default `0.0`.

`double` (`Double`)::
    64-bit, signed, double-precision, IEEE 754 floating point number. Default: `0.0`.

`boolean` (`Boolean`)::
    logical quantity with two possible values of `true` and `false`. Default: `false`.
====

You can declare a primitive type <<script-spec-variables,variable>> or access a
primitive type member field from a reference type instance, and assign it a
primitive type value for evaluation during later operations.

Use the field access operator or method call operator on a primitive type value
to force evaluation as its corresponding reference type value.

Let's take our shortened script and incorporate some primitive types:

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        int my_int; <1>
        my_int = 1; <2>
        double my_double = 2.0; <3>
    """
  }
}
----
<1> Primitive `int` type declaration
<2> Primitive `int` type assignment with an `int` constant
<3> Primitive `double` type declaration with assignment of a `double` constant

[discrete]
[[script-type-reference]]
==== Reference types
A reference type is an object that potentially represents multiple pieces of
data and logic to manipulate that data, defined as part of the API for scripts.
A reference type is comprised of an instance, value, and variable.

A reference type _instance_ is a single set of data for one reference type
object allocated to the heap. Use a reference type instance to load from, store
to, and mainpulate complex data.

A reference type _value_ refers to an instance, and multiple values can refer to
the same instance. A change to an instance affects all values referring to that
specific instance.

To access a reference type _variable_, declare the variable or access a
reference type member field from an instance. You can then assign the variable
a value and reference the variable in various operations. The default value for
a newly-declared reference type variable is `null`.

Let's expand our example to include some reference types. The following example
adds a `Map` type declaration called `my_map`. Then, the `my_map` variable is
assigned a value with a new instance of `HashMap`.

Reference types are complex types that have method and fields available to
modify internal state. In the example, the `my_map.put` statement modifies the
`my_map` variable to include two instances of `my_int`.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        int my_int;
        my_int = 1;
        double my_double = 2.0;
        Map my_map; <1>
        my_map = new HashMap(); <2>
        my_map.put("my_int", my_int); <3>
        my_map.put("my_double", my_double);
        return my_map;
    """
  }
}
----
<1> Reference `Map` type declaration
<2> Reference `Map` type assignment with a new instance of a `HashMap`
<3> Modification of the `my_map` variable

The response includes the result of the `Map` named `my_map`:

[source,console-result]
----
{
  "result" : "{my_int=1, my_double=2.0}"
}
----
// TEST[continued]

[discrete]
[[script-type-dynamic]]
==== Dynamic types
A dynamic type can represent the value of any primitive type or reference type
using a single type named `def`. A `def` type value mimics the behavior of
whatever value it represents at runtime, and always represents the last child
descendant type value of any type value when evaluated.

To access a `def` type _variable_, declare the variable or access a
reference type member field from an instance. You can then assign the variable
a value and reference the variable in various operations. The default value for
a newly-declared `def` type variable is `null`.

Let's implement a `def` type to the previous example. You can declare the
primitive type `int`, name it `my_int`, and then assign it avalue of `1`:

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        int my_int;
        my_int = 1;
    """
  }
}
----

Instead, you can use a `def` type variable to simplify the declaration:

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        def my_int = 1;
    """
  }
}
----

This declaration declares a `def` type named `my_int` and assigns it a value of
`1` in a single statement. Because a `def` type can mimic a primitive type,
this statement implicitly casts `my_int` as type `int` without having to
declare it.

NOTE: Using the `def` type can have a slight impact on performance. Use only
primitive types and reference types directly when performance is critical.

[discrete]
[[types-whats-next]]
==== What's next
These types are the most basic structures in Painless, and there are other
types that you can learn about when writing scripts. Now that you've learned
about types, you can start declaring variables and assigning types to them.

<<script-spec-variables,Learn about variables>>

[[script-spec-variables]]
=== Variables
A variable loads and stores a value for evaluation during operations. A
variable not immediately assigned a value will have a default value assigned
implicitly based on the type.

When using variables, you declare the variable, specify a type, and assign
values to the variable. The following example declares a variable `i` of type
`int`, and assigns it a value of `10`:

[source,Painless]
----
int i;  <1>
i = 10; <2>
----
<1> Declare `int i` and store default `int 0` to `i`
<2> Store `int 10` to `i`

When declaring a variable, specify the type followed by an identifier. After
declaring variables, you can use them in scripts by referring to their
identifier.

Use the assignment operator `'='` to store a value in a variable for use in
subsequent operations. Any operation that produces a value can be assigned to
any variable as long as the types are the same, or the resultant type can be
implicitly cast to the variable type.

[[script-spec-operators]]
=== Operators
An operator is the most basic action that can be taken to evaluate values in a
script. An expression is one-to-many consecutive operations. Precedence is the
order in which an operator will be evaluated relative to another operator.
Associativity is the direction within an expression in which a specific
operator is evaluated.

[[script-spec-statements]]
=== Statements


[[script-spec-functions]]
=== Functions


[[modules-scripting-using-caching]]
=== Modify script caching

All scripts are cached by default so that they only need to be recompiled
when updates occur. By default, scripts do not have a time-based expiration, but
you can change this behavior by using the `script.cache.expire` setting.
You can configure the size of this cache by using the `script.cache.max_size` setting.
For most contexts, the default cache size is `100`. For ingest contexts, the
default cache size is `200`.

NOTE: The size of scripts is limited to 65,535 bytes. This can be
changed by setting `script.max_size_in_bytes` setting to increase that soft
limit, but if scripts are really large then a
<<modules-scripting-engine,native script engine>> should be considered.

[[scripts-and-search-speed]]
=== Scripts and search speed

Scripts can't make use of {es}'s index structures or related optimizations. This
can sometimes result in slower search speeds.

If you often use scripts to transform indexed data, you can speed up search by
making these changes during ingest instead. However, that often means slower
index speeds.

[[modules-scripting-stored-scripts]]
=== Stored scripts

Scripts may be stored in and retrieved from the cluster state using the
`_scripts` end-point.
