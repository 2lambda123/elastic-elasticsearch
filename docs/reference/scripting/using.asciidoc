[[modules-scripting-using]]
== How to write scripts

Wherever scripting is supported in the {es} APIs, the syntax follows the same
pattern; you specify the language of your script, provide the script logic (or
source, and add parameters that are passed into the script:

[source,js]
-------------------------------------
  "script": {
    "lang":   "...",
    "source" | "id": "...",
    "params": { ... }
  }
-------------------------------------
// NOTCONSOLE

`lang`::

    Specifies the language the script is written in. Defaults to `painless`.

`source`, `id`::

    The script itself, which you specify as `source` for an inline script or `id` for a stored script. Use the `_scripts` endpoint to retrieve a stored script. For example, you can create or delete a stored script by calling  `POST _scripts/{id}` and `DELETE _scripts/{id}`.

`params`::

    Specifies any named parameters that are passed into the script as
    variables. <<prefer-params,Use parameters>> instead of hard-coded values to decrease compile time.

[discrete]
[[hello-world-script]]
=== Write your first script
<<modules-scripting-painless,Painless>> is the default scripting language
for {es}. It is secure, performant, and provides a natural syntax for anyone
with a little coding experience.

A Painless script is structured as one or more statements and optionally
has one or more user-defined functions at the beginning. A script must always
have at least one statement.

The {painless}/painless-execute-api.html[Painless execute API] provides the ability to
test a script with simple user-defined parameters and receive a result. Let's
start with a complete script and review its constituent parts.

First, index a document with a single field so that we have some data to work
with:

[source,console]
----
PUT my-index-000001/_doc/1
{
  "my_field": 5
}
----

We can then construct a script that operates on that field and run evaluate the
script as part of a query. The following query uses the
<<script-fields,`script_fields`>> parameter of the search API to retrieve a
script valuation. There's a lot happening here, but we'll break it down the
components to understand them individually. For now, you only need to
understand that this script takes `my_field` and operates on it.

[source,console]
----
GET my-index-000001/_search
{
  "script_fields": {
    "my_doubled_field": {
      "script": { <1>
        "source": "doc['my_field'].value * params['multiplier']", <2>
        "params": {
          "multiplier": 2
        }
      }
    }
  }
}
----
// TEST[continued]
<1> `script` object
<2> `script` source

The `script` is a standard JSON object that defines scripts under most APIs
in {es}. This object requires `source` to define the script itself. The
script doesn't specify a language, so it defaults to Painless.

[discrete]
[[prefer-params]]
=== Use parameters in your script

The first time {es} sees a new script, it compiles it and stores the
compiled version in a cache. Compilation can be a heavy process. If you're
passing variables into a script, pass them in as named `params` instead of
hard-coding values into the script itself.

For example, in the previous script, we could have just hard coded values and
written a script that is seemingly less complex. We could just retrieve the
first value for `my_field` and then multiply it by `2`:

[source,painless]
----
"source": "return doc['my_field'].value * 2"
----

Though it works, this solution is pretty inflexible. We have to modify the
script source to change the multiplier, and {es} has to recompile the script
every time that the multiplier changes.

Instead of hard-coding values, use named `params` to make scripts flexible, and
also reduce compilation time when the script runs. Our script declares a
parameter named `multiplier` and assigns it a value that we can access it
anywhere in our script. Also, the script is compiled only once.

[source,painless]
----
"source": "doc['my_field'].value * params['multiplier']",
"params": {
  "multiplier": 2
}
----

For most contexts, you can compile up to 75 scripts per 5 minutes by default.
For ingest contexts, the default script compilation rate is unlimited. You
can change these settings dynamically by setting
`script.context.$CONTEXT.max_compilations_rate`. For example, the following
setting limits script compilation to 100 scripts every 10 minutes:

[source,js]
----
`script.context.field.max_compilations_rate=100/10m`
----
// NOTCONSOLE

IMPORTANT: If you compile too many unique scripts within a short time, {es}
rejects the new dynamic scripts with a `circuit_breaking_exception` error.

[discrete]
[[script-shorten-syntax]]
=== Shorten your script
Using syntactic abilities that are native to Painless, you can reduce verbosity
in your scripts and make them shorter. For example, we can write the previous
script like this and achieve the same goal:

[source,console]
----
GET my-index-000001/_search
{
  "script_fields": {
    "my_doubled_field": {
      "script": {
        "lang":   "painless",
        "source": "return doc['my_field'].value * params.get('multiplier');",
        "params": {
          "multiplier": 2
        }
      }
    }
  }
}
----

However, we can leverage capabilities inherent to Painless and shorten this
script. Let's look at the original version and see how what improvements it
includes over this current iteration:

[source,console]
----
GET my-index-000001/_search
{
  "script_fields": {
    "my_doubled_field": {
      "script": {
        "source": "doc['my_field'].value * params['multiplier']",
        "params": {
          "multiplier": 2
        }
      }
    }
  }
}
----

This version of the script removes several components and simplifies the syntax
significantly:

* The `lang` declaration. Because Painless is the default language, you don't
need to specify the language if you're writing a Painless script.
* The `return` keyword. Painless automatically uses the final statement in a
script (when possible) to produce a return value in a script context that
requires one.
* The `get` method, which is replaced with brackets `[]`. Painless
uses a shortcut specifically for the `Map` type that allows us to use brackets
instead of the lengthier `get` method.
* The semicolon at the end of the `source` statement. Painless does not
require semicolons for the final statement of a block. However, it does require
them in other cases to remove ambiguity.

Use this abbreviated syntax anywhere that {es} supports scripts.

[discrete]
[[script-whats-next]]
=== What's next
Now that you've learned the basic syntax of a Painless script, we'll dig more
into the language itself. Understanding the building blocks of the language
will help you to construct more complex and powerful scripts.

<<script-spec-types,Learn about types>>

[[script-spec-types]]
=== Types
A type is a classification of data used to define the properties of a value.
These properties specify what data a value represents and the rules for how a
value is evaluated during an operation. Each type belongs to one of the
following categories: primitive, reference, or dynamic.

[[script-type-primitive]]
==== Primitive types
A primitive type holds a singular piece of data. Examples of
{painless}/painless-types.html#primitive-types[available primitive types] are
`byte`, `int`, and `long`. Primitive types can also specify the size and type
of a variable value. For example, an `int` is 32-bit and stores whole numbers,
whereas a `double` is 64-bit and stores fractional numbers.

The following example declares three primitive types:

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        int my_int; <1>
        my_int = 1; <2>
        double my_double = 2.0; <3>
    """
  }
}
----
<1> Primitive `int` type declaration
<2> Primitive `int` type assignment with an `int` constant
<3> Primitive `double` type declaration with assignment of a `double` constant

You can declare a primitive type variable or access a primitive type member
field from a reference type instance, and assign it a primitive type value for
evaluation during later operations. But what's a
<<script-type-reference,reference type>>?

[[script-type-reference]]
==== Reference types
A reference type is a mutable object accessed through different variables that
change the underlying instance. Reference types hold references to
objects and provide a way to access them. You define reference types as part of
the API for scripts.

When you assign a primitive type to another variable, that variable gets a
*copy* of the contents of the original primitive type. For example, declare
variable `a` and assign it a value, and then set `b` equal to `a`.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        int a = 123;
        int b = a;
        a = 456;
        return b;
    """
  }
}
----

Even if you declare a new value for `a`, returning `b` results in a value of
`123`, which is the value declared for `a` that variable `b` knows about.
Because of this relationship, we can say that `b` is a _reference_ to `a`.

[source,console-result]
----
{
  "result" : "123"
}
----
// TEST[continued]

[discrete]
===== How to use reference types
What if you want to modify the types and values that are part of a reference
type? That's where you can leverage the magic of reference types! You can have
multiple reference type values that point to the _same_ instance, which means
you don't have to modify the instance itself.

To illustrate the magic of reference types, we'll update a reference type
within a script. The following request creates two new `ArrayList` objects
named `first` and `last`. The script creates another object named `current`,
which references the `first` object.

The `for` loop iterates through every number from `0` to `99` and adds a
condition that if an integer equals `5`, change the reference of `current` to
`last`.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        List first = new ArrayList();
        List last = new ArrayList();
        List current = first; <1>
        for (int i = 0; i < 100; i++) {
          current.add(i);
          if (i == 5) {
            current = last; <2>
            }
        }
        return last;
    """
  }
}
----
<1> Set `current` equal to `first`
<2> Modify `current` to make it equal to `last`

As the script begins iterating from `0` to `99`, it reaches `5` and triggers
the condition in the `for` loop. The script returns the following result, which
includes all values from `6` to `99`.

Our script didn't change the `first` or `last` objects, but instead changed the
reference of `current`. This ability to modify referenced values without
changing the underlying variable value allows you to write powerful scripts
with dynamic capabilites.

[source,console-result]
----
{
  "result" : "[6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
  23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
  42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
  61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
  80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
  99]"
}
----
// TEST[continued]

[[script-type-dynamic]]
==== Dynamic types
A dynamic type can represent any value by using a single type named `def`. A
`def` type value mimics the behavior of whatever value it represents at
runtime. The underlying value can have different types during script execution,
which provides flexibility in your script.

For example, the following script includes a `def` type named `abc` that is
implicitly defined as an `int` with a value of `1`. The second line sets the
value of `abc` to a string value, which would result in a compilation error if
`abc` was strictly defined as `int abc`.

[source,painless]
----
def abc = 1;
abc = "a string";
----

Because a `def` type can mimic multiple types, it always represents
the last child descendant type value of any type value when evaluated. The
default value for a newly-declared `def` type variable is `null`.

NOTE: Using the `def` type can have a slight impact on performance. Use only
primitive types and reference types directly when performance is critical. If
you know the type you're referring to, using a concrete type instead of a `def`
type results in faster script execution.

[discrete]
===== How to use dynamic types
So how do dynamic types work in practice? Let's look at a basic example. The
following script creates an empty `List` named `x` and adds `1` to the list.
The script then declares an `int` named `y` and says that it's equal to an `int`
named `x`.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        List x = []; <1>
        x.add(1);
        int y = (int)x[0];
        y.toString();
    """
  }
}
----
<1> The brackets `[]` indicate that this is an empty list.

We can simplify that request by using `def`. Instead of explicitly declaring
a variable named `y` and equating it to `x`, we can say that `def y = x[0]`.
Now, the `y` variable will mimic `x` however it's defined.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        List x = [];
        x.add(1);
        def y = x[0];
        y.toString();
    """
  }
}
----

[discrete]
===== How to _really_ use dynamic types
So a `def` type is just another way to shorten scripts, right? True, but the
real magic is that a `def` type variable can change the type it represents
during the compilation and evaluation of a script. This capability is incredibly
powerful when your script is retrieving data, especially `doc` values.

We'll talk more about retrieving data later on, but the main takeaway relating
to `def` values is this: you don't really need to know what primitive type your
data is; you can just use a `def` type and then start operating on the data.

For example, the following request starts with a list that includes primitive
types of `int`, `double`, and `String`. The request then declares an empty
`String` and introduces a `for` loop. This loop iterates through the values in
the list and changes the value three times:

* `1` is an `int`
* `2.0` is a `double`
* `'3'` is a `string`

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
      List list = [1, 2.0, '3'];
      String string = "";
      for (def value : list) {
        string += value.toString();
        }
    """
  }
}
----

The type changes occur automatically without doing anything other than using
`def` and iterating through the values. Painless changes the type for you so
that you can focus on writing your script without worrying about what your data
type is.

[discrete]
[[types-whats-next]]
==== What's next
These types are the most basic structures in Painless. There are {painless}/painless-types.html[other types] that you can learn about as you script writing
skills develop. Now that you've learned about types and variables, you can
start combining them with operators.

At this point, you know how to write basic scripts that incorporate different
types and variables to calculate values. This knowledge is foundational for
writing Painless scripts. Now that you understand how to write a script, you
need to know about how your script accesses data.

<<modules-scripting-fields,Learn about accessing document fields and data>>
