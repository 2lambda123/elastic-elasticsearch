[[modules-scripting-using]]
== How to write scripts

Wherever scripting is supported in the {es} APIs, the syntax follows the same
pattern; you specify the language of your script, provide the script logic (or
source, and add parameters that are passed into the script:

[source,js]
-------------------------------------
  "script": {
    "lang":   "...",
    "source" | "id": "...",
    "params": { ... }
  }
-------------------------------------
// NOTCONSOLE

`lang`::

    Specifies the language the script is written in. Defaults to `painless`.

`source`, `id`::

    Specifies the source of the script. An `inline` script is specified as `source` in the previous example. A `stored` script is specified by `id` and is retrieved from the cluster state using the `_scripts` endpoint. For
    example, `_scripts/id`.

`params`::

    Specifies any named parameters that are passed into the script as
    variables. <<prefer-params,Use parameters>> instead of hard-coded values to decrease compile time.

[discrete]
[[hello-world-script]]
=== Write your first script
<<modules-scripting-painless,Painless>> is the default scripting language
for {es}. It is secure, performant, and provides a natural syntax for anyone
with a little coding experience.

A Painless script is structured as one or more statements and optionally
has one or more user-defined functions at the beginning. A script must always
have at least one statement.

The {painless}/painless-execute-api.html[Painless execute API] provides the ability to
test a script with simple user-defined parameters and receive a result. Let's
start with a simple script and review its constituent parts.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": { <1>
    "source": "return 'Hello, world!';" <2>
  }
}
----
<1> `script` object
<2> `script` source

We're using the Painless execute API without any URL parameters, which uses
the `painless_test` context by default. This context optionally makes
available a `Map` of user-defined parameters, and then returns a value as an
`Object`. `Map` and `Object` are known as _types_, which we'll discuss more
later on.

The `script` is a standard JSON object that defines scripts under most APIs
in {es}. This object requires `source` to define the script itself. The
example script doesn't specify a language, so it uses Painless by default.

The `source` defines the script itself. The example `source` returns a
`String` value of `Hello, world!`, converts the string to an `Object`, and
displays the output.

[discrete]
[[script-add-parameters]]
=== Add parameters to your script
Now that you have a simple script, we'll introduce parameters to pass in
variables. Using named `params` instead of hard-coding values makes scripts
flexible, and also reduces compilation time when the script runs.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": "return params.get('hello_world');", <1>
    "lang": "painless", <2>
    "params": { <3>
        "hello_world": "Hello, world!"
    }
  }
}
----
<1> Script `source`
<2> Language declaration
<3> `Map` of user-defined parameters

Our script now contains a `Map` of user-defined parameters. The `get` method
accesses a value using the `String` key of the `hello_world` parameter.

We'll explicitly specify the `painless` language, even though that's the
default language.

The `params` section is where things get interesting. This part of the script
is where you pass in user-defined parameters, which are written as a JSON
object that is parsed into a `Map`. Our script defines a key of `hello_world`
with a `String` value of `Hello, world!`. We then access this value within
the example script.

[discrete]
[[script-shorten-syntax]]
=== Shorten your script
Using syntactic abilities that are native to Painless, you can reduce verbosity
in your scripts and make them shorter.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": "params['hello_world']",
    "params": {
        "hello_world": "Hello, world!"
    }
  }
}
----

This version of the script removes several components:

* The `return` keyword. Painless automatically uses the final statement in a
script (when possible) to produce a return value in a script context that
requires one.
* The semicolon at the end of the `source` statement. Painless does not
require semicolons for the final statement of a block. However, it does require
them in other cases to remove ambiguity.
* The `get` method, which is replaced with brackets `[]`. Painless
uses a shortcut specifically for the `Map` type that allows us to use brackets
instead of the lengthier `get` method.

[discrete]
[[script-whats-next]]
=== What's next
Now that you've learned the basic syntax of a Painless script, we'll dig more
into the language itself. Understanding the building blocks of the language
will help you to construct more complex and powerful scripts.

<<script-spec-variables,Learn about variables>>

[[script-spec-variables]]
=== Variables
A variable loads and stores a value for evaluation during operations. A
variable not immediately assigned a value will have a default value assigned
implicitly based on the type. We'll cover types in the next section.

When using variables, you declare a variable, specify a type, and assign
values to the variable. The following example declares a variable `my_int` of
type `int`, and assigns it a value of `1`:

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        int my_int;
        my_int = 1;
    """
  }
}
----

When declaring a variable, specify the type followed by an identifier. After
declaring variables, you can use them in scripts by referring to their
identifier.

Use the assignment operator `=` to store a value in a variable for use in
subsequent operations. Any operation that produces a value can be assigned to
any variable as long as the types are the same, or the resultant type can be
implicitly cast to the variable type.

[discrete]
[[variables-whats-next]]
=== What's next
Now that you understand variables, you can learn about the data types that
Painless supports. When you declare a variable, you assign it a supported type.

<<script-spec-types,Learn about types>>

[[script-spec-types]]
=== Types
A type is a classification of data used to define the properties of a value.
These properties specify what data a value represents and the rules for how a
value is evaluated during an operation. Each type belongs to one of the
following categories: primitive, reference, or dynamic.

[[script-type-primitive]]
==== Primitive types
A primitive type holds a singular piece of data. Examples of
{painless}/painless-types.html#primitive-types[available primitive types] are
`byte`, `int`, and `long`. Primitive types can also specify the size and type
of a variable value. For example, an `int` is 32-bit and stores whole numbers,
whereas a `double` is 64-bit and stores fractional numbers.

The following example declares three primitive types:

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        int my_int; <1>
        my_int = 1; <2>
        double my_double = 2.0; <3>
    """
  }
}
----
<1> Primitive `int` type declaration
<2> Primitive `int` type assignment with an `int` constant
<3> Primitive `double` type declaration with assignment of a `double` constant

You can declare a primitive type <<script-spec-variables,variable>> or access a
primitive type member field from a reference type instance, and assign it a
primitive type value for evaluation during later operations. But what's a
<<script-type-reference,reference type>>?

[[script-type-reference]]
==== Reference types
A reference type is a mutable object accessed through different variables that
change the underlying instance. Reference types hold references to
objects and provide a way to access them. You define reference types as part of
the API for scripts.

When you assign a primitive type to another variable, that variable gets a
*copy* of the contents of the original primitive type. For example, declare
variable `a` and assign it a value, and then set `b` equal to `a`.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        int a = 123;
        int b = a;
        a = 456;
        return b;
    """
  }
}
----

Even if you declare a new value for `a`, returning `b` results in a value of
`123`, which is the value declared for `a` that variable `b` knows about.
Because of this relationship, we can say that `b` is a _reference_ to `a`.

[source,console-result]
----
{
  "result" : "123"
}
----
// TEST[continued]

[discrete]
===== How to use reference types
What if you want to modify the types and values that are part of a reference
type? That's where you can leverage the magic of reference types! You can have
multiple reference type values that point to the _same_ instance, which means
you don't have to modify the instance itself.

To illustrate the magic of reference types, we'll update a reference type
within a script. The following request creates two new `ArrayList` objects
named `first` and `last`. The script creates another object named `current`,
which references the `first` object.

The `for` loop iterates through every number from `0` to `99` and adds a
condition that if an integer equals `5`, change the reference of `current` to
`last`.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        List first = new ArrayList();
        List last = new ArrayList();
        List current = first; <1>
        for (int i = 0; i < 100; i++) {
          current.add(i);
          if (i == 5) {
            current = last; <2>
            }
        }
        return last;
    """
  }
}
----
<1> Set `current` equal to `first`
<2> Modify `current` to make it equal to `last`

As the script begins iterating from `0` to `99`, it reaches `5` and triggers
the condition in the `for` loop. The script returns the following result, which
includes all values from `6` to `99`.

Our script didn't change the `first` or `last` objects, but instead changed the
reference of `current`. This ability to modify referenced values without
changing the underlying variable value allows you to write powerful scripts
with dynamic capabilites.

[source,console-result]
----
{
  "result" : "[6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
  23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
  42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
  61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
  80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
  99]"
}
----
// TEST[continued]

[[script-type-dynamic]]
==== Dynamic types
A dynamic type can represent the value of any primitive type or reference type
using a single type named `def`. A `def` type value mimics the behavior of
whatever value it represents at runtime. Because a `def` type can mimic
multiple types, it always represents the last child descendant type value of
any type value when evaluated. The default value for a newly-declared `def`
type variable is `null`.

NOTE: Using the `def` type can have a slight impact on performance. Use only
primitive types and reference types directly when performance is critical.

[discrete]
===== How to use dynamic types
So how do dynamic types work in practice? Let's look at a basic example. The
following script creates an empty `List` named `x` and adds `1` to the list.
The script then declares an `int` named `y` and says that it's equal to an `int`
named `x`.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        List x = []; <1>
        x.add(1);
        int y = (int)x[0];
        y.toString();
    """
  }
}
----
<1> The brackets `[]` indicate that this is an empty list.

We can simplify that request by using `def`. Instead of explicitly declaring
a variable named `y` and equating it to `x`, we can say that `def y = x[0]`.
Now, the `y` variable will mimic `x` however it's defined.

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
        List x = [];
        x.add(1);
        def y = x[0];
        y.toString();
    """
  }
}
----

[discrete]
===== How to _really_ use dynamic types
So a `def` type is just another way to shorten scripts, right? True, but the
real magic is that a `def` type variable can change the type it represents
during the compilation and evaluation of a script. This capability is incredibly
powerful when your script is retrieving data, especially `doc` values.

We'll talk more about retrieving data later on, but the main takeaway relating
to `def` values is this: you don't really need to know what primitive type your
data is; you can just use a `def` type and then start operating on the data.

For example, the following request starts with a list that includes primitive
types of `int`, `double`, and `String`. The request then declares an empty
`String` and introduces a `for` loop. This loop iterates through the values in
the list and changes the value three times:

* `1` is an `int`
* `2.0` is a `double`
* `'3'` is a `string`

[source,console]
----
POST /_scripts/painless/_execute
{
  "script": {
    "source": """
      List list = [1, 2.0, '3'];
      String string = "";
      for (def value : list) {
        string += value.toString();
        }
    """
  }
}
----

The type changes occur automatically without doing anything other than using
`def` and iterating through the values. Painless changes the type for you so
that you can focus on writing your script without worrying about what your data
type is.

[discrete]
[[types-whats-next]]
==== What's next
These types are the most basic structures in Painless. There are {painless}/painless-types.html[other types] that you can learn about as you script writing
skills develop. Now that you've learned about types and variables, you can
start combining them with operators.

At this point, you know how to write basic scripts that incorporate different
types and variables to calculate values. This knowledge is foundational for
writing Painless scripts. Now that you understand how to write a script, you
need to know about how your script accesses data.

<<modules-scripting-fields,Learn about accessing document fields and data>>
