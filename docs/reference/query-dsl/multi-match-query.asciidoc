[[query-dsl-multi-match-query]]
=== Multi-match query
++++
<titleabbrev>Multi-match</titleabbrev>
++++

The `multi_match` query builds on the <<query-dsl-match-query,`match` query>>
to allow multi-field queries:

[source,console]
--------------------------------------------------
GET /_search
{
  "query": {
    "multi_match" : {
      "query":    "this is a test", <1>
      "fields": [ "subject", "message" ] <2>
    }
  }
}
--------------------------------------------------

<1> The query string.
<2> The fields to be queried.

[discrete]
[[field-boost]]
==== `fields` and per-field boosting

Fields can be specified with wildcards, eg:

[source,console]
--------------------------------------------------
GET /_search
{
  "query": {
    "multi_match" : {
      "query":    "Will Smith",
      "fields": [ "title", "*_name" ] <1>
    }
  }
}
--------------------------------------------------

<1> Query the `title`, `first_name` and `last_name` fields.

Individual fields can be boosted with the caret (`^`) notation:

[source,console]
--------------------------------------------------
GET /_search
{
  "query": {
    "multi_match" : {
      "query" : "this is a test",
      "fields" : [ "subject^3", "message" ] <1>
    }
  }
}
--------------------------------------------------

<1> The query multiplies the `subject` field's score by three but leaves the
`message` field's score unchanged.

If no `fields` are provided, the `multi_match` query defaults to the `index.query.default_field`
index settings, which in turn defaults to `*`. `*` extracts all fields in the mapping that
are eligible to term queries and filters the metadata fields. All extracted fields are then
combined to build a query.

WARNING: There is a limit on the number of fields that can be queried
at once. It is defined by the `indices.query.bool.max_clause_count` <<search-settings>>
which defaults to 1024.

[[multi-match-types]]
[discrete]
==== Types of `multi_match` query:

The way the `multi_match` query is executed internally depends on the `type`
parameter, which can be set to:

[horizontal]
`best_fields`::     (*default*) Finds documents which match any field, but
                    uses the  `_score` from the best field.  See <<type-best-fields>>.

`most_fields`::     Finds documents which match any field and combines
                    the `_score` from each field.  See <<type-most-fields>>.

`combined_fields`:: Treats fields with the same `analyzer` as though they
                    were one big field. Looks for each word in *any*
                    field. See <<type-combined-fields>>.

`cross_fields`::    A legacy approach to combined-field scoring.
                    See <<type-cross-fields>>.

`phrase`::          Runs a `match_phrase` query on each field and uses the `_score`
                    from the best field.  See <<type-phrase>>.

`phrase_prefix`::   Runs a `match_phrase_prefix` query on each field and uses
                    the `_score` from the best field.  See <<type-phrase>>.

`bool_prefix`::     Creates a `match_bool_prefix` query on each field and
                    combines the `_score` from each field. See
                    <<type-bool-prefix>>.

[[type-best-fields]]
==== `best_fields`

The `best_fields` type is most useful when you are searching for multiple
words best found in the same field. For instance ``brown fox'' in a single
field is more meaningful than ``brown'' in one field and ``fox'' in the other.

The `best_fields` type generates a <<query-dsl-match-query,`match` query>> for
each field and wraps them in a <<query-dsl-dis-max-query,`dis_max`>> query, to
find the single best matching field.  For instance, this query:

[source,console]
--------------------------------------------------
GET /_search
{
  "query": {
    "multi_match" : {
      "query":      "brown fox",
      "type":       "best_fields",
      "fields":     [ "subject", "message" ],
      "tie_breaker": 0.3
    }
  }
}
--------------------------------------------------

would be executed as:

[source,console]
--------------------------------------------------
GET /_search
{
  "query": {
    "dis_max": {
      "queries": [
        { "match": { "subject": "brown fox" }},
        { "match": { "message": "brown fox" }}
      ],
      "tie_breaker": 0.3
    }
  }
}
--------------------------------------------------

Normally the `best_fields` type uses the score of the *single* best matching
field, but if `tie_breaker` is specified, then it calculates the score as
follows:

  * the score from the best matching field
  * plus `tie_breaker * _score` for all other matching fields

Also, accepts `analyzer`, `boost`, `operator`, `minimum_should_match`,
`fuzziness`, `lenient`, `prefix_length`, `max_expansions`, `fuzzy_rewrite`, `zero_terms_query`,
`auto_generate_synonyms_phrase_query` and `fuzzy_transpositions`,
as explained in <<query-dsl-match-query, match query>>.

[IMPORTANT]
[[operator-min]]
.`operator` and `minimum_should_match`
===================================================

The `best_fields` and `most_fields` types are _field-centric_ -- they generate
a `match` query *per field*.  This means that the `operator` and
`minimum_should_match` parameters are applied to each field individually,
which is probably not what you want.

Take this query for example:

[source,console]
--------------------------------------------------
GET /_search
{
  "query": {
    "multi_match" : {
      "query":      "Will Smith",
      "type":       "best_fields",
      "fields":     [ "first_name", "last_name" ],
      "operator":   "and" <1>
    }
  }
}
--------------------------------------------------

<1> All terms must be present.

This query is executed as:

      (+first_name:will +first_name:smith)
    | (+last_name:will  +last_name:smith)

In other words, *all terms* must be present *in a single field* for a document
to match.

See <<type-combined-fields>> for a better approach.

===================================================

[[type-most-fields]]
==== `most_fields`

The `most_fields` type is most useful when querying multiple fields that
contain the same text analyzed in different ways.  For instance, the main
field may contain synonyms, stemming and terms without diacritics. A second
field may contain the original terms, and a third field might contain
shingles. By combining scores from all three fields we can match as many
documents as possible with the main field, but use the second and third fields
to push the most similar results to the top of the list.

This query:

[source,console]
--------------------------------------------------
GET /_search
{
  "query": {
    "multi_match" : {
      "query":      "quick brown fox",
      "type":       "most_fields",
      "fields":     [ "title", "title.original", "title.shingles" ]
    }
  }
}
--------------------------------------------------

would be executed as:

[source,console]
--------------------------------------------------
GET /_search
{
  "query": {
    "bool": {
      "should": [
        { "match": { "title":          "quick brown fox" }},
        { "match": { "title.original": "quick brown fox" }},
        { "match": { "title.shingles": "quick brown fox" }}
      ]
    }
  }
}
--------------------------------------------------

The score from each `match` clause is added together, then divided by the
number of `match` clauses.

Also, accepts `analyzer`, `boost`, `operator`, `minimum_should_match`,
`fuzziness`, `lenient`, `prefix_length`, `max_expansions`, `fuzzy_rewrite`, and `zero_terms_query`.

[[type-combined-fields]]
==== `combined_fields`

The `combined_fields` type takes a term-centric view of the query. It first
analyzes the query string into individual terms, then looks for each term in
any of the fields, as though they were one combined field.

This type is particularly useful when a match could span multiple fields, for
example the `title`, `abstract` and `body` of an article. It takes a
principled approach to scoring based on the simple BM25F formula described in
http://www.staff.city.ac.uk/~sb317/papers/foundations_bm25_review.pdf[The Probabilistic Relevance Framework: BM25 and Beyond].

Unlike field-centric modes like <<type-most-fields>>, `operator` and
`minimum_should_match` are applied per-term, instead of per-field. For
example, a query like

[source,console]
--------------------------------------------------
GET /_search
{
  "query": {
    "multi_match" : {
      "query":      "database systems",
      "type":       "combined_fields",
      "fields":     [ "title", "abstract"],
      "operator":   "and"
    }
  }
}
--------------------------------------------------

is executed as

    +(combined("database", fields:["title", "abstract"]))
    +(combined("systems", fields:["title", "abstract"]))

In other words, *all terms* must be present *in at least one field* for a
document to match.  (Compare this to <<operator-min,the logic used for
`best_fields` and `most_fields`>>.)

When scoring matches, the `combined_fields` type combines term and collection
statistics across fields. This allows it to score each match as if the
specified fields had been indexed into a single combined field. (Note that
this is a best attempt -- `combined_fields` makes some approximations and
scores will not obey this model perfectly.)

This mode accepts the `analyzer`, `boost`, `operator`, `minimum_should_match`,
`lenient` and `zero_terms_query` options.

[IMPORTANT]
.`combined_fields` and `fuzziness`
===================================================
The `fuzziness` parameter cannot be used with the `combined_fields` or
`cross_fields` types.
===================================================

[NOTE]
.Custom similarities
===================================================
The `combined_fields` type only supports the `BM25` similarity, which is the
default unless a <<index-modules-similarity, custom similarity>>
configured. It also doesn't support <<similarity, per-field similarities>>.
Using `combined_fields` in either of these cases will result in an error.
===================================================

[[combined-fields-analysis]]
===== `combined_fields` and analysis

The `combined_fields` type can only work in term-centric mode on fields that
have the same analyzer. Fields with the same analyzer are grouped together
as in the example above, and scored as a single combined field. If there are
multiple groups, they are combined with a `bool` query.

For instance, if we have a `title` field which uses the standard analyzer,
and `abstract` and `body` which both add the `stemmer` filter, then this query

[source,console]
--------------------------------------------------
GET /_search
{
  "query": {
    "multi_match" : {
      "query":      "information",
      "type":       "combined_fields",
      "fields":     [
        "title", "abstract", "body"
      ]
    }
  }
}
--------------------------------------------------

would be executed as

    (combined("information", fields:["title"]))
    (combined("inform", fields:["abstract", "body"]))

In other words, `title` is treated as its own group, and `abstract` and `body`
are grouped together and treated as a single field. These analysis groups are
combined through a `should` boolean query, allowing either group to match.

Having multiple groups is fine, but when combined with `operator` or
`minimum_should_match`, it can suffer from the <<operator-min,same problem>>
as `most_fields` or `best_fields`.

[[type-cross-fields]]
==== `cross_fields`

The `cross_fields` type also takes a term-centric approach to scoring,
allowing each term to match any of the provided fields. It tries to pretend
that the content had been indexed into one combined field by _blending_ the
term statistics across fields. It also gives a slight scoring advantage to
fields that frequently contain the term, under the assumption that these
matches are most interesting.

The `cross_fields` type has a complex approach to blending field scores that
does not always produce well-formed scores (for example scores can become
negative). For this reason it's recommended to use `combined_fields`, which
combines field statistics in a more robust and principled way.

Note that `cross_fields` is usually only useful on short string fields
that all have a `boost` of `1`. Otherwise boosts, term freqs and length
normalization contribute to the score in such a way that the blending of term
statistics is not meaningful anymore.

The `cross_fields` mode accepts `analyzer`, `boost`, `operator`,
`minimum_should_match`, `lenient` and `zero_terms_query`.

As with `combined_fields`, the `cross_fields` type can only work in
term-centric mode on fields that have the same analyzer. Fields with the
same analyzer are grouped together.  If there are multiple groups, they
are combined with a `bool` query.

[[tie-breaker]]
===== `tie_breaker`

By default, each per-term `blended` query will use the best score returned by
any field in a group, then these scores are added together to give the final
score. The `tie_breaker` parameter can change the default behaviour of the
per-term `blended` queries. It accepts:

[horizontal]
`0.0`::             Take the single best score out of (eg) `first_name:will`
                    and `last_name:will` (default))
`1.0`::             Add together the scores for (eg) `first_name:will` and
                    `last_name:will`
`0.0 < n < 1.0`::   Take the single best score plus +tie_breaker+ multiplied
                    by each of the scores from other matching fields.

[[type-phrase]]
==== `phrase` and `phrase_prefix`

The `phrase` and `phrase_prefix` types behave just like <<type-best-fields>>,
but they use a `match_phrase` or `match_phrase_prefix` query instead of a
`match` query.

This query:

[source,console]
--------------------------------------------------
GET /_search
{
  "query": {
    "multi_match" : {
      "query":      "quick brown f",
      "type":       "phrase_prefix",
      "fields":     [ "subject", "message" ]
    }
  }
}
--------------------------------------------------

would be executed as:

[source,console]
--------------------------------------------------
GET /_search
{
  "query": {
    "dis_max": {
      "queries": [
        { "match_phrase_prefix": { "subject": "quick brown f" }},
        { "match_phrase_prefix": { "message": "quick brown f" }}
      ]
    }
  }
}
--------------------------------------------------

Also, accepts `analyzer`, `boost`, `lenient` and `zero_terms_query` as explained
in <<query-dsl-match-query>>, as well as `slop` which is explained in <<query-dsl-match-query-phrase>>.
Type `phrase_prefix` additionally accepts `max_expansions`.

[IMPORTANT]
[[phrase-fuzziness]]
.`phrase`, `phrase_prefix` and `fuzziness`
===================================================
The `fuzziness` parameter cannot be used with the `phrase` or `phrase_prefix` type.
===================================================

[[type-bool-prefix]]
==== `bool_prefix`

The `bool_prefix` type's scoring behaves like <<type-most-fields>>, but using a
<<query-dsl-match-bool-prefix-query,`match_bool_prefix` query>> instead of a
`match` query.

[source,console]
--------------------------------------------------
GET /_search
{
  "query": {
    "multi_match" : {
      "query":      "quick brown f",
      "type":       "bool_prefix",
      "fields":     [ "subject", "message" ]
    }
  }
}
--------------------------------------------------

The `analyzer`, `boost`, `operator`, `minimum_should_match`, `lenient`,
`zero_terms_query`, and `auto_generate_synonyms_phrase_query` parameters as
explained in <<query-dsl-match-query, match query>> are supported. The
`fuzziness`, `prefix_length`, `max_expansions`, `fuzzy_rewrite`, and
`fuzzy_transpositions` parameters are supported for the terms that are used to
construct term queries, but do not have an effect on the prefix query
constructed from the final term.

The `slop` parameter is not supported by this query type.
