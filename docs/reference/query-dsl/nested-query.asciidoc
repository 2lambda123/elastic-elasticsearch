[[query-dsl-nested-query]]
=== Nested query
++++
<titleabbrev>Nested</titleabbrev>
++++

Wraps another query to search <<nested,nested>> fields.

The `nested` query searches nested field objects as if they were indexed as
separate documents. If an object matches the search, the `nested` query returns
the root parent document.

[[nested-query-ex-request]]
==== Example request

[[nested-query-index-setup]]
===== Index setup

To use the `nested` query, your index must include a <<nested,nested>> field
mapping. For example:

[source,console]
----
PUT /my_index
{
    "mappings" : {
        "properties" : {
            "obj1" : {
                "type" : "nested"
            }
        }
    }
}

----

[[nested-query-ex-query]]
===== Example query

[source,console]
----
GET /my_index/_search
{
    "query":  {
        "nested" : {
            "path" : "obj1",
            "query" : {
                "bool" : {
                    "must" : [
                    { "match" : {"obj1.name" : "blue"} },
                    { "range" : {"obj1.count" : {"gt" : 5}} }
                    ]
                }
            },
            "score_mode" : "avg"
        }
    }
}
----
// TEST[continued]

[[nested-top-level-params]]
==== Top-level parameters for `nested`

`path`::
(Required, string) Path to the nested object you wish to search.

`query`::
+
--
(Required, query object) Query you wish to run on nested objects in the `path`.
If an object matches the search, the `nested` query returns the root parent
document.

You can search nested fields using dot notation that includes the complete path,
such as `obj1.name`.

Multi-level nesting is automatically supported, and detected, resulting in an
inner nested query to automatically match the relevant nesting level, rather
than root, if it exists within another nested query.

See <<multi-level-nested-query-ex>> for an example.
--

`score_mode`::
+
--
(Optional, string) Indicates how scores for matching child objects affect the
root parent document's <<relevance-scores,relevance score>>. Valid values
are:

`avg` (Default)::
Use the mean relevance score of all matching child objects.

`max`::
Uses the highest relevance score of all matching child objects.

`min`::
Uses the lowest relevance score of all matching child objects.

`none`::
Do not use the relevance scores of matching child objects. The query assigns
parent documents a score of `0`.

`sum`::
Add together the relevance scores of all matching child objects.
--

`ignore_unmapped`::
+
--
(Optional, boolean) Indicates whether to ignore an unmapped `path` and not
return any documents instead of an error. Defaults to `false`.

If `false`, {es} returns an error if the `path` is an unmapped field.

You can use this parameter to query multiple indices that may not contain the
field `path`.
--

[[nested-query-notes]]
==== Notes

[[multi-level-nested-query-ex]]
===== Multi-level nested queries

To see how multi-level nested queries work,
try the following example.

First, create an index, `drivers`,
with a nested field mapping.

[source,console]
----
PUT /drivers
{
    "mappings" : {
        "properties" : {
            "driver" : {
                "type" : "nested",
                "properties" : {
                    "vehicle" : {
                        "type" : "nested",
                        "properties" : {
                            "model" : {                 <1>
                                "type" : "keyword"
                            }
                        }
                    }
                }
            }
        }
    }
}
----

<1> Note the `model` field is nested as follows:
+
```
driver → vehicle → model
```

Next, index a document to the `drivers` index.

[source,console]
----
PUT /drivers/_doc/1?refresh
{
  "driver" : {
        "vehicle" : {
            "model" : "Canyonero"
        }
    }
}
----
// TEST[continued]

You can now use a search request with a multi-level nested query
to return documents based on the `model` field.

[source,console]
----
GET /drivers/_search
{
    "query" : {
        "nested" : {
            "path" : "driver",
            "query" : {
                "nested" : {
                    "path" :  "driver.vehicle",
                    "query" :  {
                       "match" : {
                           "driver.vehicle.model" : "Canyonero"
                        }
                    }
                }
            }
        }
    }
}
----
// TEST[continued]

The search request returns the following response:

[source,console-result]
----
{
  "took" : 75,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1,
      "relation" : "eq"
    },
    "max_score" : 0.2876821,
    "hits" : [
      {
        "_index" : "drivers",
        "_id" : "1",
        "_score" : 0.2876821,
        "_source" : {
          "driver" : {
            "vehicle" : {
              "model" : "Canyonero"
            }
          }
        },
      }
    ]
  }
}
----
// TESTRESPONSE[s/"took" : 75/"took": $body.took/]
