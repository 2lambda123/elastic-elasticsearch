[[docker]]
=== Install {es} with Docker

{es} is also available as Docker images.
The images use https://hub.docker.com/_/centos/[centos:7] as the base image.

A list of all published Docker images and tags is available at
https://www.docker.elastic.co[www.docker.elastic.co]. The source files
are in
https://github.com/elastic/elasticsearch/blob/{branch}/distribution/docker[Github].

These images are free to use under the Elastic license. They contain open source 
and free commercial features and access to paid commercial features.  
{stack-ov}/license-management.html[Start a 30-day trial] to try out all of the 
paid commercial features. See the 
https://www.elastic.co/subscriptions[Subscriptions] page for information about 
Elastic license levels.

==== Pulling the image

Obtaining {es} for Docker is as simple as issuing a +docker pull+ command
against the Elastic Docker registry.

ifeval::["{release-state}"=="unreleased"]

WARNING: Version {version} of {es} has not yet been released, so no
Docker image is currently available for this version.

endif::[]

ifeval::["{release-state}"!="unreleased"]

["source","sh",subs="attributes"]
--------------------------------------------
docker pull {docker-repo}:{version}
--------------------------------------------

Alternatively, you can download other Docker images that contain only features 
available under the Apache 2.0 license. To download the images, go to 
https://www.docker.elastic.co[www.docker.elastic.co]. 

endif::[]

[[docker-cli-run-dev-mode]]
==== Starting a single node cluster with Docker

ifeval::["{release-state}"=="unreleased"]

WARNING: Version {version} of the {es} Docker image has not yet been released.

endif::[]

ifeval::["{release-state}"!="unreleased"]

To start a single-node {es} cluster for development or testing, specify 
<<single-node-discovery,single-node discovery>> to bypass the <<bootstrap-checks,bootstrap checks>>:

["source","sh",subs="attributes"]
--------------------------------------------
docker run -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" {docker-image}
--------------------------------------------

endif::[]

[[docker-compose-file]]
==== Starting a multi-node cluster with Docker compose

To get a three-node {es} cluster up and running in Docker, 
you can use Docker Compose:

. Create a `docker-compose.yml` file:
ifeval::["{release-state}"=="unreleased"]
+
--
WARNING: Version {version} of {es} has not yet been released, so a
`docker-compose.yml` is not available for this version.

endif::[]

ifeval::["{release-state}"!="unreleased"]
["source","yaml",subs="attributes"]
--------------------------------------------
include::docker-compose.yml[]
--------------------------------------------
endif::[]

This sample Docker Compose file brings up a three-node {es} cluster. 
Node `es01` listens on `localhost:9200` and `es02` and `es03` talk to `es01` over a Docker network.

The  https://docs.docker.com/storage/volumes[Docker named volumes] 
`esdata01`, `esdata02`, and `esdata03` store the node data directories so 
the data persists across restarts. 
If they don't already exist, `docker-compose` creates them when you bring up the cluster.
--
. Make sure Docker Engine is allotted at least 4GiB of memory. 
In Docker Desktop, you configure resource usage on the Advanced tab in Preference (macOS)
or Settings (Windows).

. Run `docker-compose` to bring up the cluster:
+
["source","sh",subs="attributes"]
--------------------------------------------
docker-compose up
--------------------------------------------

. Submit a `_cat/nodes` request to see that the nodes are up and running:
+
[source,sh]
--------------------------------------------------
curl -X GET "localhost:9200/_cat/nodes?v&pretty"
--------------------------------------------------

Log messages go to the console and are handled by the configured Docker logging driver. 
By default you can access logs with `docker logs`.

To stop the cluster, run `docker-compose down`. 
The data in the Docker volumes is preserved and loaded 
when when you restart the cluster with `docker-compose up`.
To **delete the data volumes** when you bring down the cluster, 
specify the `-v` option: `docker-compose down -v`.

[NOTE]
`docker-compose` is not pre-installed with Docker on Linux.
For installation instructions, see
https://docs.docker.com/compose/install[Install Compose on Linux] on docs.docker.com.

[[docker-prod-prerequisites]]
==== Using the Docker images in production

IMPORTANT: The `vm.max_map_count` kernel setting must be set to at least `262144` for production use. 

How you set `vm.max_map_count` depends on your platform:

* Linux
+
--
The `vm.max_map_count` setting should be set permanently in `/etc/sysctl.conf`:
[source,sh]
--------------------------------------------
grep vm.max_map_count /etc/sysctl.conf
vm.max_map_count=262144
--------------------------------------------

To apply the setting on a live system run: 

[source,sh]
--------------------------------------------
sysctl -w vm.max_map_count=262144
--------------------------------------------
--

* macOS with  https://docs.docker.com/docker-for-mac[Docker for Mac]
+
--
The `vm.max_map_count` setting must be set within the xhyve virtual machine:

. From the command line, run:
+
["source","sh"]
--------------------------------------------
screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty
--------------------------------------------

. Press enter and use`sysctl` to configure `vm.max_map_count`:

["source","sh"]
--------------------------------------------
sysctl -w vm.max_map_count=262144
--------------------------------------------

. To exit the `screen` session, type `Ctrl a d`.
--

* Windows and macOS with https://www.docker.com/products/docker-desktop[Docker Desktop]
+
--
The `vm.max_map_count` setting must be set via docker-machine:

["source","txt"]
--------------------------------------------
docker-machine ssh
sudo sysctl -w vm.max_map_count=262144
--------------------------------------------
--

[[docker-configuration-methods]]
==== Configuring {es} with Docker

When you run in Docker, the <<config-files-location,{es} configuration files>> are loaded from 
`/usr/share/elasticsearch/config/`.

To use custom configuration files, you <<docker-config-bind-mount, bind-mount the files>>
over the configuration files in the image. 

You can set individual {es} configuration parameters using Docker environment variables. 
The <<docker-compose-file, sample compose file>> and the 
<<docker-cli-run-dev-mode, single-node example>>  use this method. 

You can also override the default command for the image to pass {es} configuration
parameters as command line options. For example:

["source","sh"]
--------------------------------------------
docker run <various parameters> bin/elasticsearch -Ecluster.name=mynewclustername
--------------------------------------------

While bind-mounting your configuration files is usually the preferred method in production, 
you can also <<docker-config-custom-image, create a custom Docker image>> 
that contains your configuration.

[[docker-config-bind-mount]]
===== Mounting {es} configuration files
Create your custom config file and mount this over the image's corresponding file.
For example, bind-mounting a `custom_elasticsearch.yml` with `docker run` can be
accomplished with the parameter:

["source","sh"]
--------------------------------------------
-v full_path_to/custom_elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml
--------------------------------------------
IMPORTANT: The container **runs {es} as user `elasticsearch` using
uid:gid `1000:1000`**. Bind mounted host directories and files, such as
`custom_elasticsearch.yml` above, **need to be accessible by this user**. For the <<path-settings, data and log dirs>>,
such as `/usr/share/elasticsearch/data`, write access is required as well.
Also see note 1 below.


[[docker-config-custom-image]]
===== Using custom Docker images
In some environments, it might make more sense to prepare a custom image that contains
your configuration. A `Dockerfile` to achieve this may be as simple as:

["source","sh",subs="attributes"]
--------------------------------------------
FROM docker.elastic.co/elasticsearch/elasticsearch:{version}
COPY --chown=elasticsearch:elasticsearch elasticsearch.yml /usr/share/elasticsearch/config/
--------------------------------------------

You could then build and try the image with something like:

["source","sh"]
--------------------------------------------
docker build --tag=elasticsearch-custom .
docker run -ti -v /usr/share/elasticsearch/data elasticsearch-custom
--------------------------------------------

Some plugins require additional security permissions. You have to explicitly accept
them either by attaching a `tty` when you run the Docker image and accepting yes at 
the prompts, or inspecting the security permissions separately and if you are 
comfortable with them adding the `--batch` flag to the plugin install command.
See {plugins}/_other_command_line_parameters.html[Plugin Management documentation]
for more details.


[[next-getting-started-tls-docker]]
==== Configuring SSL/TLS with the {es} Docker image

See <<configuring-tls-docker>>.

==== Notes for production use and defaults

We have collected a number of best practices for production use.
Any Docker parameters mentioned below assume the use of `docker run`.

. By default, {es} runs inside the container as user `elasticsearch` using
uid:gid `1000:1000`.
+
--
CAUTION: One exception is https://docs.openshift.com/container-platform/3.6/creating_images/guidelines.html#openshift-specific-guidelines[Openshift],
which runs containers using an arbitrarily assigned user ID. Openshift will
present persistent volumes with the gid set to `0` which will work without any
adjustments.

If you are bind-mounting a local directory or file, ensure it is readable by
this user, while the <<path-settings,data and log dirs>> additionally require
write access. A good strategy is to grant group access to gid `1000` or `0` for
the local directory. As an example, to prepare a local directory for storing
data through a bind-mount:

  mkdir esdatadir
  chmod g+rwx esdatadir
  chgrp 1000 esdatadir

As a last resort, you can also force the container to mutate the ownership of
any bind-mounts used for the <<path-settings,data and log dirs>> through the
environment variable `TAKE_FILE_OWNERSHIP`. In this case, they will be owned by
uid:gid `1000:0` providing read/write access to the {es} process as required.
--

. It is important to ensure increased ulimits for
<<setting-system-settings,nofile>> and <<max-number-threads-check,nproc>> are
available for the {es} containers. Verify the https://github.com/moby/moby/tree/ea4d1243953e6b652082305a9c3cda8656edab26/contrib/init[init system]
for the Docker daemon is already setting those to acceptable values and, if
needed, adjust them in the Daemon, or override them per container, for example
using `docker run`:
+
--
  --ulimit nofile=65535:65535

NOTE: One way of checking the Docker daemon defaults for the aforementioned
ulimits is by running:

  docker run --rm centos:7 /bin/bash -c 'ulimit -Hn && ulimit -Sn && ulimit -Hu && ulimit -Su'
--

. Swapping needs to be disabled for performance and node stability. This can be
achieved through any of the methods mentioned in the
<<setup-configuration-memory,{es} docs>>. If you opt for the
`bootstrap.memory_lock: true` approach, apart from defining it through any of
the <<docker-configuration-methods,configuration methods>>, you will
additionally need the `memlock: true` ulimit, either defined in the
https://docs.docker.com/engine/reference/commandline/dockerd/#default-ulimits[Docker Daemon]
or specifically set for the container. This is demonstrated above in the
<<docker-compose-file, sample compose file>>. If using `docker run`:
+
--
  -e "bootstrap.memory_lock=true" --ulimit memlock=-1:-1
--

. The image https://docs.docker.com/engine/reference/builder/#/expose[exposes]
TCP ports 9200 and 9300. For clusters it is recommended to randomize the
published ports with `--publish-all`, unless you are pinning one container per host.

. Use the `ES_JAVA_OPTS` environment variable to set heap size. For example, to
use 16GB, use `-e ES_JAVA_OPTS="-Xms16g -Xmx16g"` with `docker run`.
+
--
NOTE: You still need to <<heap-size,configure the heap size>> even if you are
https://docs.docker.com/config/containers/resource_constraints/#limit-a-containers-access-to-memory[limiting
memory access] to the container.
--

. Pin your deployments to a specific version of the {es} Docker image, for
example +docker.elastic.co/elasticsearch/elasticsearch:{version}+.

. Always use a volume bound on `/usr/share/elasticsearch/data`, as shown in the
<<docker-cli-run-prod-mode,production example>>, for the following reasons:

.. The data of your {es} node won't be lost if the container is killed

.. {es} is I/O sensitive and the Docker storage driver is not ideal for fast I/O

.. It allows the use of advanced
https://docs.docker.com/engine/extend/plugins/#volume-plugins[Docker volume plugins]

. If you are using the devicemapper storage driver, make sure you are not using
the default `loop-lvm` mode. Configure docker-engine to use
https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#configure-docker-with-devicemapper[direct-lvm]
instead.

. Consider centralizing your logs by using a different
https://docs.docker.com/engine/admin/logging/overview/[logging driver]. Also
note that the default json-file logging driver is not ideally suited for
production use.


include::next-steps.asciidoc[]
