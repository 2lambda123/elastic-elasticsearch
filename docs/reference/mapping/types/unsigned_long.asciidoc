[role="xpack"]
[testenv="basic"]

[[unsigned-long]]
=== Unsigned long data type
++++
<titleabbrev>Unsigned long</titleabbrev>
++++

Unsigned long is a numeric field type that represents an unsigned 64-bit
integer with a minimum value of 0 and a maximum value of +2^64^-1+
(from 0 to 18446744073709551615 inclusive).

[source,console]
--------------------------------------------------
PUT my_index
{
  "mappings": {
    "properties": {
      "my_counter": {
        "type": "unsigned_long"
      }
    }
  }
}
--------------------------------------------------

Unsigned long can be indexed in a numeric or string form,
representing integer values in the range [0, 18446744073709551615].
They can't have a decimal part.

[source,console]
--------------------------------
POST /my_index/_bulk?refresh
{"index":{"_id":1}}
{"my_counter": 0}
{"index":{"_id":2}}
{"my_counter": 9223372036854775808}
{"index":{"_id":3}}
{"my_counter": 18446744073709551614}
{"index":{"_id":4}}
{"my_counter": 18446744073709551615}
--------------------------------
//TEST[continued]

Term queries accept any numbers in a numeric or string form.

[source,console]
--------------------------------
GET /my_index/_search
{
    "query": {
        "term" : {
            "my_counter" : 18446744073709551615
        }
    }
}
--------------------------------
//TEST[continued]

Range query terms can contain values with decimal parts.
In this case {es} converts them to integer values:
`gte` and `gt` terms are converted to the nearest integer up inclusive,
and `lt` and `lte` ranges are converted to the nearest integer down inclusive.

It is recommended to pass ranges as strings to ensure they are parsed
without any loss of precision.

[source,console]
--------------------------------
GET /my_index/_search
{
    "query": {
        "range" : {
            "my_counter" : {
                "gte" : "9223372036854775808.5",
                "lte" : "18446744073709551615"
            }
        }
    }
}
--------------------------------
//TEST[continued]


For queries with sort on an `unsigned_long` field,
for a particular document {es} returns a sort value of the type `Long`
if the value of this document is within the range of long values,
or of the type `BigIntger` if the value exceeds this range.

WARNING: Not all {es} clients can properly handle big integer values.

[source,console]
--------------------------------
GET /my_index/_search
{
    "query": {
        "match_all" : {}
    },
    "sort" : {"my_counter" : "desc"}
}
--------------------------------
//TEST[continued]

Similarly to sort values, script values of an `unsigned_long` field
produce `BigInteger` or `Long` values. The same values: `BigInteger` or
`Long` are returned as keys for `terms` aggregation.

==== Queries with mixed numeric types

Search queries across several numeric types one of which `unsigned_long` are supported,
except queries with sort. Thus, a sort query across two indexes where the same field
is `unsigned_long` in one index, and `long` in another, doesn't produce correct results
and must be avoided. If there is a need for a such kind of sorting, script based
sorting can be used instead.
Aggregations across several numeric types one of which `unsigned_long` are supported,
except a terms aggregation.


[[unsigned-long-params]]
==== Parameters for unsigned long fields

The following parameters are accepted:

[horizontal]

<<doc-values,`doc_values`>>::

    Should the field be stored on disk in a column-stride fashion, so that it
    can later be used for sorting, aggregations, or scripting? Accepts `true`
    (default) or `false`.

<<ignore-malformed,`ignore_malformed`>>::

    If `true`, malformed numbers are ignored. If `false` (default), malformed
    numbers throw an exception and reject the whole document.

<<mapping-index,`index`>>::

    Should the field be searchable? Accepts `true` (default) and `false`.

<<null-value,`null_value`>>::

    Accepts a numeric value of the same `type` as the field which is
    substituted for any explicit `null` values.  Defaults to `null`, which
    means the field is treated as missing.

<<mapping-store,`store`>>::

    Whether the field value should be stored and retrievable separately from
    the <<mapping-source-field,`_source`>> field. Accepts `true` or `false`
    (default).

<<mapping-field-meta,`meta`>>::

    Metadata about the field.
