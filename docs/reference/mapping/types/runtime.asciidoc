[[runtime]]
=== Runtime

////
[source,console]
----
PUT /my-index
----
// TESTSETUP
////

Typically, you must index fields to {es} before they can be retrieved,
aggregated, or searched. With runtime fields, you can explicitly define a field
in the mapping and access it at search time without indexing your data during
ingest time.

Runtime fields beta[] are accessible from the search API like any other field that has
<<doc-values,doc_values>> and is searchable. You can retrieve and query these
fields, as well as aggregate on them.

Runtime fields help to alleviate several common issues when using {es}:

* Reindexing your data between development iterations is slow and can make
experimenting on large datasets difficult
* Indexing data before searching makes running one-off searches costly and
resource intensive
* Indexing all of your data instead of just the fields you want to search
requires more disk space to gain search time performance
* Reindexing data for time-based indices to ensure that existing indices
include any new fields in the index template is slow
* Determining how a field is evaluated in {kib} at index or search time is
difficult for scripted fields because they have different needs based on where
they are implemented

Because runtime fields aren't indexed, you can more quickly ingest raw data
into the Elastic Stack and immediately access it. By dynamically evaluating
runtime fields at search time, you can optimize disk space by choosing which
fields to index. You can also fix errors in indexed fields by overriding them
with runtime fields, rather than reindexing all of your data. If you later
decide that a runtime field is increasingly used for filtering or aggregation,
you can remove the runtime field from the mapping and index the field to gain
faster search speed.

Runtime fields incur performance costs at search time, depending
on the <<runtime-params-runtime-type,`runtime_type`>>. For example, let's say
you created an anomaly detection job that operates on the `@timestamp` field.
If the `@timestamp` field is a runtime field, the search cost would be extremely
high because the data isn't indexed and {es} must compute the value for each
document that matches the query.

Runtime fields are useful when working with log data, especially when you're
unsure about the data structure. Your search speed decreases, but your index
size is much smaller and you can more quickly process logs without having to
index them.

[[runtime-mapping-fields]]
==== Mapping a runtime field
When mapping a runtime field, indexing is disabled by default. You map runtime
fields by <<modules-scripting-using,defining a painless script>>. At search
time, the script runs and generates values for each scripted field. Runtime
scripts have access to the entire context of a document, the original
`_source`, and the mapped field plus its values (`doc_values`).

IMPORTANT: Updating a script while a query that relies on the script is running
can return inconsistent results.
+
Additionally, existing queries or visualizations that rely on runtime fields
can break if scripts are updated.

The script in the following request extracts the day of the week from the
`@timestamp` field, which is defined as a `date` data type.

[source,console]
----
PUT /my-index/_mappings
{
  "properties" : {
    "day_of_week" : {
      "type" : "runtime", <1>
      "runtime_type" : "keyword", <2>
      "script" : {
        "source" : "emit(doc['@timestamp'].value.dayOfWeekEnum.getDisplayName(TextStyle.FULL, Locale.ROOT))"
      }
    }
  }
}
----

<1> Runtime fields are of the `runtime` data type.
<2> Each runtime has its own field type, defined by `runtime_type`.

[[runtime-retrieving-fields]]
==== Retrieving a runtime field
Use the <<search-fields,`fields`>> parameter on the `_search` API to retrieve
the values of runtime fields. This API works for all fields, even those that
were not sent as part of the original `_source`.

NOTE: We highly recommended using the <<async-search,asynchronous search API>>
to run searches that use runtime fields.

The following request uses the search API to retrieve the `day_of_week` field
that the previous request defined in the mapping.

[source,console]
----
GET /my-index/_search
{
  "aggs": {
    "days_of_week": {
      "terms": {
        "field": "day_of_week"
      }
    }
  }
}
----

[[runtime-params]]
==== Parameters for `runtime` fields
Runtime fields accept the following parameters:

[[runtime-params-type]]
`type`::
The type of runtime computation to perform at query time. Currently, runtime
fields only support the `runtime` data type.

[[runtime-params-runtime-type]]
`runtime_type`::
The <<mapping-types,field type>> for each scripted field. {es}
supports `boolean`, `date`, `double`, `ip`, `keyword`, and `long`.
+
Runtime fields with a `runtime_type` of `date` can accept the
<<mapping-date-format,`format`>> parameter exactly as the `date` field type.

[[runtime-examples]]
==== Examples
Consider a large set of log data that you want to extract fields from.
Indexing the data is time consuming and uses a lot of disk space, and you just
want to explore the data structure without committing to a schema up front.

You know that your log data contains specific fields that you want to extract.
By using runtime fields, you can define scripts to calculate values at search
time for these fields.

You can start with a simple example by adding the `@timestamp` and `message`
fields to the `my-index` mapping. To remain flexible, use `wildcard` as the
field type for `message`.

[source,console]
----
PUT /my-index/_mappings
{
  "properties": {
    "@timestamp": {
    "format": "strict_date_optional_time||epoch_second",
    "type": "date"
  },
  "message": {
    "type": "wildcard"
  }
 }
}
----

After mapping the fields you want to retrieve, index a few records from
your log data into {es}. The following request uses the <<docs-bulk,bulk API>>
to index raw log data into `my-index`. Instead of indexing all of your log
data, you can use a small sample to experiment with runtime fields.

[source,console]
----
POST /my-index/_bulk
{ "index": {}}
{ "@timestamp": "2020-06-21T15:00:01-05:00", "message" : "211.11.9.0 - - [2020-06-21T15:00:01-05:00] \"GET /english/index.html HTTP/1.0\" 304 0"}
{ "index": {}}
{ "@timestamp": "2020-06-21T15:00:01-05:00", "message" : "211.11.9.0 - - [2020-06-21T15:00:01-05:00] \"GET /english/index.html HTTP/1.0\" 304 0"}
{ "index": {}}
{ "@timestamp": "2020-04-30T14:30:17-05:00", "message" : "40.135.0.0 - - [2020-04-30T14:30:17-05:00] \"GET /images/hm_bg.jpg HTTP/1.0\" 200 24736"}
{ "index": {}}
{ "@timestamp": "2020-04-30T14:30:53-05:00", "message" : "232.0.0.0 - - [2020-04-30T14:30:53-05:00] \"GET /images/hm_bg.jpg HTTP/1.0\" 200 24736"}
{ "index": {}}
{ "@timestamp": "2020-04-30T14:31:12-05:00", "message" : "26.1.0.0 - - [2020-04-30T14:31:12-05:00] \"GET /images/hm_bg.jpg HTTP/1.0\" 200 24736"}
{ "index": {}}
{ "@timestamp": "2020-04-30T14:31:19-05:00", "message" : "247.37.0.0 - - [2020-04-30T14:31:19-05:00] \"GET /french/splash_inet.html HTTP/1.0\" 200 3781"}
{ "index": {}}
{ "@timestamp": "2020-04-30T14:31:27-05:00", "message" : "252.0.0.0 - - [2020-04-30T14:31:27-05:00] \"GET /images/hm_bg.jpg HTTP/1.0\" 200 24736"}
{ "index": {}}
{ "@timestamp": "2020-04-30T14:31:29-05:00", "message" : "247.37.0.0 - - [2020-04-30T14:31:29-05:00] \"GET /images/hm_brdl.gif HTTP/1.0\" 304 0"}
{ "index": {}}
{ "@timestamp": "2020-04-30T14:31:29-05:00", "message" : "247.37.0.0 - - [2020-04-30T14:31:29-05:00] \"GET /images/hm_arw.gif HTTP/1.0\" 304 0"}
{ "index": {}}
{ "@timestamp": "2020-04-30T14:31:32-05:00", "message" : "247.37.0.0 - - [2020-04-30T14:31:32-05:00] \"GET /images/nav_bg_top.gif HTTP/1.0\" 200 929"}
{ "index": {}}
{ "@timestamp": "2020-04-30T14:31:43-05:00", "message" : "247.37.0.0 - - [2020-04-30T14:31:43-05:00] \"GET /french/images/nav_venue_off.gif HTTP/1.0\" 304 0"}
----

At this point, you can view how {es} stores your raw data.

[source,console]
----
GET /my-index
----

The mapping contains two fields: `@timestamp` and `message`.

[source,console-result]
----
{
  "my-index" : {
    "aliases" : { },
    "mappings" : {
      "properties" : {
        "@timestamp" : {
          "type" : "date",
          "format" : "strict_date_optional_time||epoch_second"
        },
        "message" : {
          "type" : "wildcard"
        }
      }
    },
    "settings" : {
      "index" : {
        "routing" : {
          "allocation" : {
            "include" : {
              "_tier" : "data_hot"
            }
          }
        },
        "number_of_shards" : "1",
        "provided_name" : "my-index",
        "creation_date" : "1601313565318",
        "number_of_replicas" : "1",
        "uuid" : "zpdFg3pXSNm4UBinOUc75A",
        "version" : {
          "created" : "7100099"
        }
      }
    }
  }
}
----

If you want to retrieve results that include `clientip`, you can add that field
as a runtime field in the mapping. The runtime script operates on the `clientip`
field at runtime to calculate values for that field.

[source,console]
----
PUT /my-index/_mappings
{
  "properties": {
    "clientip": {
      "type": "runtime",
      "runtime_type": "ip",
      "script" : {
      "source" : "String m = doc[\"message\"].value; int end = m.indexOf(\" \"); emit(m.substring(0, end));"
      }
    }
  }
}
----

Using the `clientip` runtime field, you can define a simple query to run a
search for a specific IP address and return all related fields.

[source,console]
----
GET my-index/_search
{
  "query": {
    "match": {
      "clientip": "211.11.9.0"
    }
  },
  "fields" : ["*"]
}
----

The API returns the following result. Without building your data structure in
advance, you can search and explore your data in meaningful ways to experiment
and determine which fields to index.

[source,console-result]
----
{
  "took" : 1,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 2,
      "relation" : "eq"
    },
    "max_score" : 1.0,
    "hits" : [
      {
        "_index" : "my-index",
        "_type" : "_doc",
        "_id" : "m4d6wXQBQVoWbakQ_rGg",
        "_score" : 1.0,
        "_source" : {
          "@timestamp" : "2020-06-21T15:00:01-05:00",
          "message" : """211.11.9.0 - - [2020-06-21T15:00:01-05:00] "GET /english/index.html HTTP/1.0" 304 0"""
        },
        "fields" : {
          "clientip" : [
            "211.11.9.0"
          ],
          "message" : [
            """211.11.9.0 - - [2020-06-21T15:00:01-05:00] "GET /english/index.html HTTP/1.0" 304 0"""
          ],
          "@timestamp" : [
            "2020-06-21T20:00:01.000Z"
          ]
        }
      },
      {
        "_index" : "my-index",
        "_type" : "_doc",
        "_id" : "nId6wXQBQVoWbakQ_rGg",
        "_score" : 1.0,
        "_source" : {
          "@timestamp" : "2020-06-21T15:00:01-05:00",
          "message" : """211.11.9.0 - - [2020-06-21T15:00:01-05:00] "GET /english/index.html HTTP/1.0" 304 0"""
        },
        "fields" : {
          "clientip" : [
            "211.11.9.0"
          ],
          "message" : [
            """211.11.9.0 - - [2020-06-21T15:00:01-05:00] "GET /english/index.html HTTP/1.0" 304 0"""
          ],
          "@timestamp" : [
            "2020-06-21T20:00:01.000Z"
          ]
        }
      }
    ]
  }
}
----

If you add the `day_of_week` field to the mapping using the request in
<<runtime-mapping-fields,mapping a runtime field>>, you can re-run the previous
search request and also retrieve the day of the week based on the `@timestamp`
field.

The value for this field was never indexed, and is calculated dynamically at
runtime. This flexibility allows you to modify the mapping without changing
any field values.

[source,console-result]
----
...
        "fields" : {
          "@timestamp" : [
            "2020-06-21T20:00:01.000Z"
          ],
          "clientip" : [
            "211.11.9.0"
          ],
          "message" : [
            """211.11.9.0 - - [2020-06-21T15:00:01-05:00] "GET /english/index.html HTTP/1.0" 304 0"""
          ],
          "day_of_week" : [
            "Sunday" <1>
          ]
        }
      },
  ...
----
// TEST[skip:not a complete result]

<1> This value was calculated at search time using the runtime script defined
in the mapping.
