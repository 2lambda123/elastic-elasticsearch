[[json]]
=== JSON datatype

experimental[The `json` field type is experimental and may be changed in a breaking way in future releases.]

The `json` mapping type allows an entire JSON object to be indexed as a single field, with support for simple
queries on the field's contents. A `json` field can be useful for modelling objects with a large number of
distinct subfields whose keys are not known in advance. This type of situation might arise arise when
some data is generated directly by users, or by an external third-party application.

NOTE: The `json` mapping type should **not** be used for indexing all JSON content. The default approach to
modelling documents, where each subfield of an object has its own entry in the mappings, works well in the
majority of cases. If an object's subfields are not known in advance, then they can be
<<dynamic-mapping, mapped dynamically>>. The `json` type provides limited search functionality and does not
support some features that other field types do, such as aggregations and sorting.

[source,js]
--------------------------------
PUT bug_reports
{
  "mappings": {
    "_doc": {
      "properties": {
        "title": {
          "type": "text"
        },
        "labels": {
          "type": "json"
        }
      }
    }
  }
}

POST bug_reports/_doc/1
{
  "title": "Results are not sorted correctly.",
  "labels": {
    "priority": "urgent",
    "release": ["v1.2.5", "v1.3.0"],
    "timestamp": {
      "created": 1541458026,
      "closed": 1541457010
    }
  }
}
--------------------------------
// CONSOLE

During indexing, the leaf values in the JSON object are parsed out and added as a distinct token. Each value is
indexed as a string keyword, without analysis or special handling of numeric and date values.

Querying the top-level `json` field searches all leaf values in the object:
[source,js]
--------------------------------
POST bug_reports/_search
{
  "query": {
    "term": {"labels": "urgent"}
  }
}
--------------------------------
// CONSOLE
// TEST[continued]

To query on a specific key in the JSON object, object dot notation is used:
[source,js]
--------------------------------
POST bug_reports/_search
{
  "query": {
    "term": {"labels.release": "v1.3.0"}
  }
}
--------------------------------
// CONSOLE
// TEST[continued]

==== Supported operations

Currently, `json` fields can be used with the following query types:

- `term`, `terms`, and `terms_set`
- `prefix`
- `range`
- `match` and `multi_match`
- `query_string` and `simple_query_string`
- `exists`

When querying, it is not possible to refer to field keys using wildcards, as in
`{ "term": {"labels.time*": 1541457010}}`. Note that all queries, including `range`, treat the values as
string keywords.

Aggregating, highlighting, or sorting on a `json` field is not supported.

Finally, because of the way leaf values are stored in the index, the null character `\0` is not allowed to
appear in the keys of the JSON object.

[[stored-fields]]
==== Stored fields

If the <<mapping-store,`store`>> option is enabled in the mappings, the entire JSON object will be stored
in pretty-printed format. It can be retrieved through the top-level `json` field:

[source,js]
--------------------------------
POST bug_reports/_search
{
  "query": { "match": { "title": "results not sorted" }},
  "stored_fields": ["labels"]
}
--------------------------------
// CONSOLE
// TEST[continued]

Field keys cannot be used to load stored content. For example, specifying
`"stored_fields": ["labels.timestamp"]` will return an empty list.

[[json-params]]
==== Parameters for JSON fields

Because of the similarities in the way values are indexed, the `json` type shares many mapping options
with <<keyword, `keyword`>>. The following parameters are accepted:

[horizontal]

<<mapping-boost,`boost`>>::

    Mapping field-level query time boosting. Accepts a floating point number, defaults
    to `1.0`.

`depth_limit`::

    The maximum allowed depth of the JSON field, in terms of nested inner objects.
    If a JSON field exceeds this limit, then an error will be thrown. Defaults to `20`.

<<ignore-above,`ignore_above`>>::

    Leaf values longer than this limit will not be indexed. By default, there is no limit
    and all values will be indexed. Note that this limit applies to the leaf values within
    the JSON field, and not the length of the entire field.

<<mapping-index,`index`>>::

    Determines if the field should be searchable. Accepts `true` (default) or `false`.

<<index-options,`index_options`>>::

    What information should be stored in the index for scoring purposes.
    Defaults to `docs` but can also be set to `freqs` to take term frequency
    into account when computing scores.

<<null-value,`null_value`>>::

    A string value which is substituted for any explicit `null` values within
    the JSON field. Defaults to `null`, which means null sfields are treated as
    if it were missing.

<<mapping-store,`store`>>::

    Whether the field value should be stored and retrievable separately from
    the <<mapping-source-field,`_source`>> field. Accepts `true` or `false`
    (default).

<<similarity,`similarity`>>::

    Which scoring algorithm or _similarity_ should be used. Defaults
    to `BM25`.

`split_queries_on_whitespace`::

    Whether <<full-text-queries,full text queries>> should split the input on whitespace
    when building a query for this field. Accepts `true` or `false` (default).
