[[dynamic-field-mapping]]
=== Dynamic field mapping

When {es} detects a new field in a document, it automatically adds the field to
the type mapping. The <<dynamic,`dynamic`>> parameter controls whether new
fields are added dynamically.

You can disable this behavior, both at the document and at the
<<object,`object`>> level. Setting the `dynamic` parameter to
`false` ignores new fields, and `strict` throws an exception if {es} encounters
an unknown field.

When dynamic field mapping is enabled, {es} uses the following rules to
determine how to map data types for each field.

[horizontal]
*JSON data type*::                  *Elasticsearch data type*

`null`::                            No field is added.
`true` or `false`::                 <<boolean,`boolean`>> field
floating{nbsp}point{nbsp}number::   <<number,`float`>> indexed field or <<number,`double`>> runtime field
integer::                           <<number,`long`>> field
object::                            <<object,`object`>> field
+
Objects are always mapped as part of the `properties` section, even when the `dynamic` parameter is set to `runtime`.
array::                             Depends on the first non-`null` value in the array.
string::                            Either a <<date,`date`>> field (if the value passes <<date-detection,date detection>>), a <<number,`double`>> or <<number,`long`>> field (if the value passes <<numeric-detection,numeric detection>>), or a <<text,`text`>> field with a <<keyword,`keyword`>> sub-field.

NOTE: These are the only <<mapping-types,field data types>> that {es} detects
dynamically. All other data types must be mapped explicitly.

Besides the following options, you can customize dynamic field mapping rules
with <<dynamic-templates,`dynamic_templates`>>.

[[date-detection]]
==== Date detection

If `date_detection` is enabled (default), then new string fields are checked
to see whether their contents match any of the date patterns specified in
`dynamic_date_formats`.  If a match is found, a new <<date,`date`>> field is
added with the corresponding format.

The default value for `dynamic_date_formats` is:

&#91; <<strict-date-time,`"strict_date_optional_time"`>>,`"yyyy/MM/dd HH:mm:ss Z||yyyy/MM/dd Z"`]

For example:


[source,console]
--------------------------------------------------
PUT my-index-000001/_doc/1
{
  "create_date": "2015/09/02"
}

GET my-index-000001/_mapping <1>
--------------------------------------------------

<1> The `create_date` field has been added as a <<date,`date`>>
    field with the <<mapping-date-format,`format`>>: +
    `"yyyy/MM/dd HH:mm:ss Z||yyyy/MM/dd Z"`.

===== Disabling date detection

Dynamic date detection can be disabled by setting `date_detection` to `false`:

[source,console]
--------------------------------------------------
PUT my-index-000001
{
  "mappings": {
    "date_detection": false
  }
}

PUT my-index-000001/_doc/1 <1>
{
  "create": "2015/09/02"
}
--------------------------------------------------

<1> The `create_date` field has been added as a <<text,`text`>> field.

===== Customising detected date formats

Alternatively, the `dynamic_date_formats` can be customised to support your
own <<mapping-date-format,date formats>>:

[source,console]
--------------------------------------------------
PUT my-index-000001
{
  "mappings": {
    "dynamic_date_formats": ["MM/dd/yyyy"]
  }
}

PUT my-index-000001/_doc/1
{
  "create_date": "09/25/2015"
}
--------------------------------------------------


[[numeric-detection]]
==== Numeric detection

While JSON has support for native floating point and integer data types, some
applications or languages may sometimes render numbers as strings. Usually the
correct solution is to map these fields explicitly, but numeric detection
(which is disabled by default) can be enabled to do this automatically:


[source,console]
--------------------------------------------------
PUT my-index-000001
{
  "mappings": {
    "numeric_detection": true
  }
}

PUT my-index-000001/_doc/1
{
  "my_float":   "1.0", <1>
  "my_integer": "1" <2>
}
--------------------------------------------------

<1> The `my_float` field is added as a <<number,`float`>> field.
<2> The `my_integer` field is added as a <<number,`long`>> field.
