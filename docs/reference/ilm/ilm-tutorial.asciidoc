[role="xpack"]
[testenv="basic"]
[[getting-started-index-lifecycle-management]]
== Tutorial: Automate rollover with {ilm-init}

++++
<titleabbrev>Automate rollover</titleabbrev>
++++

This tutorial demonstrates how to use {ilm} 
({ilm-init}) to manage indices that contain time-series data.

When you continuously index timestamped documents into {es},
you typically a data stream so you can periodically roll over to a
new index.
This enables you to implement a hot-warm-cold architecture to meet your performance
requirements for your newest data, control costs over time, enforce retention policies,
and still get the most out of your data.

To automate rollover and management of time-series indices with {ilm-init}, you:

. <<ilm-gs-create-policy, Create a lifecycle policy>> that defines the appropriate
phases and actions.
. <<ilm-gs-apply-policy, Create a composable template>> to create the data stream and
apply the ILM policy and the indices settings and mappings configurations for the backing
indices.
. <<ilm-gs-check-progress, Verify indices are moving through the lifecycle phases>>
as expected.

For an introduction to rolling indices, see <<index-rollover>>. 

IMPORTANT: When you enable {ilm} for {beats} or the {ls} {es} output plugin,
lifecycle policies are set up automatically.
You do not need to take any other actions.
You can modify the default policies through
{kibana-ref}/example-using-index-lifecycle-policy.html[{kib} Management]
or the {ilm-init} APIs.

[discrete]
[[ilm-gs-create-policy]]
=== Create a lifecycle policy

A lifecycle policy specifies the phases in the index lifecycle
and the actions to perform in each phase. A lifecycle can have up to four phases:
`hot`, `warm`, `cold`, and `delete`. 

You can define and manage policies through {kib} Management or with the 
<<ilm-put-lifecycle, put policy>> API.

For example, you might define a `timeseries_policy` that has two phases:
 
* A `hot` phase that defines a rollover action to specify that an index rolls over when it 
reaches either a `max_size` of 50 gigabytes or a `max_age` of 30 days.
* A `delete` phase that sets `min_age` to remove the index 90 days after rollover.
Note that this value is relative to the rollover time, not the index creation time. 

The underlying put policy request looks like this:

[source,console]
------------------------
PUT _ilm/policy/timeseries_policy
{
  "policy": {
    "phases": {
      "hot": {                      <1>
        "actions": {
          "rollover": {
            "max_size": "50GB",     <2>
            "max_age": "30d"
          }
        }
      },
      "delete": {
        "min_age": "90d",           <3>
        "actions": {
          "delete": {}              <4>
        }
      }
    }
  }
}
------------------------
<1> The `min_age` defaults to `0ms`, so new indices enter the `hot` phase immediately.
<2> Trigger the `rollover` action when either of the conditions are met.
<3> Move the index into the `delete` phase 90 days after rollover.
<4> Trigger the `delete` action when the index enters the delete phase.

You can also invoke this API directly to add lifecycle policies.

For the complete list of actions that {ilm} can perform, see <<ilm-actions>>.

[discrete]
[[ilm-gs-apply-policy]]
=== Create a composable template to create the data stream and apply the lifecycle policy

To create a data stream we'll create a composable template with a `data_stream` definition
that will specify the lifecycle policy.

For example, you might create a `timeseries_template` that is will bootstrap a data stream
named `timeseries`.

To enable the ILM to manage the data stream, the template configures one {ilm-init} setting:

* `index.lifecycle.name` specifies the name of the lifecycle policy to apply to the data stream.

You can use the {kib} Create template wizard to add the template.
This wizard invokes the put _index_template API to create the <<indices-templates,composable index template>>
with the options you specify.

The underlying request looks like this:

[source,console]
-----------------------
PUT _index_template/timeseries_template
{
  "index_patterns": ["timeseries"],                 <1>
  "data_stream": {
    "timestamp_field": "@timestamp"                  <2>
  },
  "template": {
    "settings": {
      "number_of_shards": 1,
      "number_of_replicas": 1,
      "index.lifecycle.name": "timeseries_policy"     <3>
    }
  }
}
-----------------------
// TEST[continued]

<1> Apply the template when a document is indexed into the `timeseries` target.
<2> Identifies the timestamp field for the data source, a field that must be present
in all documents indexed into the `timeseries` data stream.
<3> The name of the ILM policy used to manage the data stream.

You can also invoke this API directly to add templates.


//////////////////////////

[source,console]
--------------------------------------------------
DELETE /_template/timeseries_template
--------------------------------------------------
// TEST[continued]

//////////////////////////

[discrete]
[[ilm-gs-bootstrap]]
=== Bootstrap the data stream

To get things started, you simply index a document into the name or wildcard pattern defined
in the `index_patterns` of the <<indices-templates,composable index template>> that will
create the data stream.
{es} will automatically create the corresponding data stream and will index the document into
the first backing index.

For example, the following request creates the `timeseries` data stream and the first generation
backing index called `.ds-timeseries-000001`.

[source,console]
-----------------------
POST timeseries/_doc
{
  "message": "logged the request",
  "@timestamp": "1591890611"
}

-----------------------
// TEST[continued]

When the rollover conditions are met, the `rollover` action:

* Creates the second generation backing index, name `.ds-timeseries-000002`.
As it is the backing index of the `timeseries` data stream which was created using the `timeseries_template`
the template configuration will be applied to the new index.
* As it is the latest generation index of the `timeseries` data stream, the newly created
backing index `.ds-timeseries-000002` becomes the data stream's write index.

This process repeats each time rollover conditions are met.
You can search across all of the data stream's backing indices, managed by the `timeseries_policy`,
with the `timeseries` data stream name.
Write operations are routed to the current write index, whilst read operations will be handled by all
backing indices.

[discrete]
[[ilm-gs-check-progress]]
=== Check lifecycle progress

To get status information for managed indices, you use the {ilm-init} explain API.
This lets you find out things like:

* What phase an index is in and when it entered that phase.
* The current action and what step is being performed.
* If any errors have occurred or progress is blocked.

For example, the following request gets information about the `timeseries` indices:

[source,console]
--------------------------------------------------
GET .ds-timeseries-*/_ilm/explain
--------------------------------------------------
// TEST[continued]

The response below shows that the data stream's first generation backing index is waiting in the `hot`
phase's `rollover` action.
It remains in this state and {ilm-init} continues to call `attempt-rollover` until the rollover conditions
are met.

// [[36818c6d9f434d387819c30bd9addb14]]
[source,console-result]
--------------------------------------------------
{
  "indices": {
    ".ds-timeseries-000001": {
      "index": ".ds-timeseries-000001",
      "managed": true,
      "policy": "timeseries_policy",             <1>
      "lifecycle_date_millis": 1538475653281,
      "age": "30s",                              <2>
      "phase": "hot",
      "phase_time_millis": 1538475653317,
      "action": "rollover",
      "action_time_millis": 1538475653317,
      "step": "attempt-rollover",                <3>
      "step_time_millis": 1538475653317,
      "phase_execution": {
        "policy": "timeseries_policy",
        "phase_definition": {                    <4>
          "min_age": "0ms",
          "actions": {
            "rollover": {
              "max_size": "50gb",
              "max_age": "30d"
            }
          }
        },
        "version": 1,
        "modified_date_in_millis": 1539609701576
      }
    }
  }
}
--------------------------------------------------
// TESTRESPONSE[skip:no way to know if we will get this response immediately]

<1> The policy used to manage the index
<2> The age of the index
<3> The step {ilm-init} is performing on the index
<4> The definition of the current phase (the `hot` phase)
