---
teardown:
  - do:
      raw:
        method: POST
        path: "follower_index/_ccr/pause_follow"
---
"line_24":
  - skip:
      features:
        - default_shards
        - stash_in_key
        - stash_in_path
        - stash_path_replace
        - warnings
# Named setup remote_cluster_and_leader_index

  # Fetch the http host. We use the host of the master because we know there will always be a master.
  - do:
      cluster.state: {}
  - set: { master_node: master }
  - do:
      nodes.info:
        metric: [ http, transport ]
  - set: {nodes.$master.http.publish_address: host}
  - set: {nodes.$master.transport.publish_address: transport_host}

  - do:
      cluster.put_settings:
        body:
          persistent:
            cluster.remote.remote_cluster.seeds: $transport_host

  - do:
      indices.create:
        index: leader_index
        body:
          settings:
            index.number_of_replicas: 0
            index.number_of_shards: 1
            index.soft_deletes.enabled: true

  - do:
      raw:
        method: PUT
        path: "follower_index/_ccr/follow"
        wait_for_active_shards: "1"
        body: |
          {
            "remote_cluster" : "remote_cluster",
            "leader_index" : "leader_index"
          }
  - is_false: _shards.failures
---
"line_89":
  - skip:
      features:
        - default_shards
        - stash_in_key
        - stash_in_path
        - stash_path_replace
        - warnings
        - always_skip
      reason: no setup
  - do:
      raw:
        method: PUT
        path: ".ds-logs-mysql-default_copy-2022-01-01-000001/_ccr/follow"
        body: |
          {
            "remote_cluster" : "remote_cluster",
            "leader_index" : ".ds-logs-mysql-default-2022-01-01-000001",
            "data_stream_name": "logs-mysql-default_copy"
          }
  - is_false: _shards.failures
---
"line_112":
  - skip:
      features:
        - default_shards
        - stash_in_key
        - stash_in_path
        - stash_path_replace
        - warnings
# Named setup remote_cluster_and_leader_index

  # Fetch the http host. We use the host of the master because we know there will always be a master.
  - do:
      cluster.state: {}
  - set: { master_node: master }
  - do:
      nodes.info:
        metric: [ http, transport ]
  - set: {nodes.$master.http.publish_address: host}
  - set: {nodes.$master.transport.publish_address: transport_host}

  - do:
      cluster.put_settings:
        body:
          persistent:
            cluster.remote.remote_cluster.seeds: $transport_host

  - do:
      indices.create:
        index: leader_index
        body:
          settings:
            index.number_of_replicas: 0
            index.number_of_shards: 1
            index.soft_deletes.enabled: true

  - do:
      raw:
        method: PUT
        path: "follower_index/_ccr/follow"
        wait_for_active_shards: "1"
        body: |
          {
            "remote_cluster" : "remote_cluster",
            "leader_index" : "leader_index",
            "settings": {
              "index.number_of_replicas": 0
            },
            "max_read_request_operation_count" : 1024,
            "max_outstanding_read_requests" : 16,
            "max_read_request_size" : "1024k",
            "max_write_request_operation_count" : 32768,
            "max_write_request_size" : "16k",
            "max_outstanding_write_requests" : 8,
            "max_write_buffer_count" : 512,
            "max_write_buffer_size" : "512k",
            "max_retry_delay" : "10s",
            "read_poll_timeout" : "30s"
          }
  - is_false: _shards.failures
  - match:
      $body:
        {
          "follow_index_created" : true,
          "follow_index_shards_acked" : true,
          "index_following_started" : true
        }
