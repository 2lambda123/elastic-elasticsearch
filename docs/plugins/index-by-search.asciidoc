[[plugins-index-by-search]]
=== Index by Search Plugin

The index-by-search plugin adds support for indexing all documents that match
a query. Internally it uses {ref}/search-request-scroll.html[Scroll] and
{ref}/docs-bulk.html[Bulk] APIs much like
{ref}/plugin-delete-by-query[Delete by Query] though it might not use that
implementation in the future. Regardless of how it does its work its safe to
think of it as doing a scroll and then building bulk requests from each batch.

[float]
==== Installation

This plugin can be installed using the plugin manager:

[source,sh]
----------------------------------------------------------------
sudo bin/plugin install index-by-search
----------------------------------------------------------------

The plugin must be installed on every node in the cluster, and each node must
be restarted after installation.

[float]
==== Removal

The plugin can be removed with the following command:

[source,sh]
----------------------------------------------------------------
sudo bin/plugin remove index-by-search
----------------------------------------------------------------

The node must be stopped before removing the plugin.

[[index-by-search-usage]]
==== Using Index-by-Search

The simplest way to use index-by-search is to copy an entire index into another
index. This will copy all documents in the `twitter` index into the
`new_twitter` index:

[source,js]
--------------------------------------------------
POST /_index_by_search
{
  "source": {
    "index": "twitter"
  },
  "index": {
    "index": "new_twitter"
  }
}
--------------------------------------------------
// AUTOSENSE

You can limit the copy to a single type. This will only copy `tweet`s
from the `twitter` index:

[source,js]
--------------------------------------------------
POST /_index_by_search
{
  "source": {
    "index": "twitter",
    "type": "tweet"
  },
  "index": {
    "index": "new_twitter"
  }
}
--------------------------------------------------
// AUTOSENSE

You can limit using the {ref}/query-dsl.html[Query DSL]. This will copy
all documents from the `twitter` index for the user `kimchy` into the
new_twitter index:

[source,js]
--------------------------------------------------
POST /_index_by_search
{
  "source": {
    "index": "twitter",
    "search": {
      "query": { <1>
        "term": {
          "user": "kimchy"
        }
      }
    }
  },
  "index": {
    "index": "new_twitter"
  }
}
--------------------------------------------------
// AUTOSENSE

<1> The query must be passed as a value to the `query` key, in the same
way as the {ref}/search-search.html[search api].

By default the newly indexed documents will have the same type as the
original documents but you can override the type. This will copy all
`tweet`s in the `twitter` index back into the `twitter` index with the
type `chirp`:

[source,js]
--------------------------------------------------
POST /_index_by_search
{
  "source": {
    "index": "twitter",
    "type": "tweet"
  },
  "index": {
    "index": "twitter",
    "type": "chirp"
  }
}
--------------------------------------------------
// AUTOSENSE

`index` and `type` in `source` can be multiple values, allowing you to
copy from lots of sources in one request. This will copy documents from
the `tweet` and `post` types in the `twitter` and `blog` index. Note that
this includes the `post` type in the `twitter` index. If you want to be
more specific you'll need to use the `query`.
[source,js]
--------------------------------------------------
POST /twitter,blog/_index_by_search
{
  "source": {
    "index": ["twitter", "blog"],
    "type": ["tweet", "post"]
  },
  "index": {
    "index": "all_together"
  }
}
--------------------------------------------------
// AUTOSENSE

NOTE: This request makes no effort to prevent writing duplicates so if it
sees two documents with the same type and id then only one will make it.

Its also possible to limit the number of processed documents by setting
`size`. This will only copy a single document from `twitter` to
`new_twitter`:

[source,js]
--------------------------------------------------
POST /_index_by_search
{
  "size": 1,
  "source": {
    "index": "twitter"
  },
  "index": {
    "index": "new_twitter"
  }
}
--------------------------------------------------
// AUTOSENSE

If you want a particular set of documents from the twitter index you'll
need to sort. Sorting makes the scroll less efficient but in some contexts
its worth it. This will copy 10000 documents from `twitter` into
`new_twitter`:

[source,js]
--------------------------------------------------
POST /_index_by_search
{
  "size": 10000,
  "source": {
    "index": "twitter"
    "search": {
      "sort": { "date": "desc" }
    }
  },
  "index": {
    "index": "new_twitter"
  }
}
--------------------------------------------------
// AUTOSENSE

By default the request is terminated the first time it hits an indexing error
that isn't a version conflict. To make it more tolerant of errors set
`failures_cause_abort` to something greater than 0. Note that aborting is done
per bulk batch so the response might contain more than the number of failures
you asked for. Below is an example of setting it. See the bottom of this page
for the response format.

[source,js]
--------------------------------------------------
POST /_index_by_search
{
  "failures_cause_abort": 100,
  "source": {
    "index": "twitter"
  },
  "index": {
    "index": "new_twitter"
  }
}
--------------------------------------------------
// AUTOSENSE

If you want version conflicts to count against `failures_cause_abort` then set
`"save_version_conflicts": true` and they will be sent in the `failures`
portion of the response. Here is an example that will abort after it sees ten
failures, including version conflicts:

[source,js]
--------------------------------------------------
POST /_index_by_search
{
  "failures_cause_abort": 100,
  "save_version_conflicts": true,
  "source": {
    "index": "twitter"
  },
  "index": {
    "index": "new_twitter"
  }
}
--------------------------------------------------
// AUTOSENSE


[float]
=== Query-string parameters

This request supports no query string parameters beyond the standard
parameters like `pretty`.

[float]
=== Versioning

Just as the {ref}/docs-index.html[Index API] supports optimistic concurrency
control, so does index-by-search. Its has two default behaviors, depending on
how you use it.

"Reindexing" defaults to `"version_type": "external_exact"` meaning that
documents are only touched if their version number matches the version number
the document has when the scan snapshots it. Index-by-search thinks you are
"reindexing" when you set the source and destination to the same things. Like
this:

[source,js]
--------------------------------------------------
POST /_index_by_search
{
  "source": {
    "index": "test"
  }
  "index": {
    "index": "test"
  }
}
--------------------------------------------------
// AUTOSENSE

or this:

[source,js]
--------------------------------------------------
POST /_index_by_search
{
  "source": {
    "index": "test_index",
    "type": "test_type"
  }
  "index": {
    "index": "test_index",
    "type": "test_type"
  }
}
--------------------------------------------------
// AUTOSENSE

All other index-by-search operations default to `"op_type": "create"` meaning
that existing documents aren't modified but documents not found in the
destination are created.

These defaults were chosen because they cover common use cases and are simple
to think about. "Reindexing" was designed to `touch` documents so they pick up
mapping changes like new fields. The other default was chosen because its
simple to explain. There are many other configurations though.

[float]
==== Always write the document

You cause index-by-search to always write the documents it sees by setting
`"version": "not_set"` like so:

[source,js]
--------------------------------------------------
POST /_index_by_search
{
  "source": {
    "index": "source"
  }
  "index": {
    "index": "dest",
    "version": "not_set"
  }
}
--------------------------------------------------
// AUTOSENSE

This will cause Elasticsearch to totally ignore optimistic concurrency control
by sending all the index requests without a version.

[float]
==== Preserve external versions on copy

You cause index-by-search to preserve external versions on copy style
operations by setting `"version_type": "external"` like so:

[source,js]
--------------------------------------------------
POST /_index_by_search
{
  "source": {
    "index": "source"
  }
  "index": {
    "index": "dest",
    "version_type": "external"
  }
}
--------------------------------------------------
// AUTOSENSE

This will cause Elasticsearch to send all the index requests as though they
were index operations received with `version_type=external` on the url. This
also has the side effect of overwriting documents that have version numbers
less than the version number in the source index.

[float]
=== Routing

By default if the documents returned by the search have a routing then the
routing is preserved. You can set `routing` on the `index` request to
changes this:

`keep`::

Sets the routing on the bulk request sent for each match to the routing on
the match. The default.

`discard`::

Sets the routing on the bulk request sent for each match to null.

`=<some text>`::

Sets the routing on the bulk request sent for each match to all text after
the `=`.

For example, you can use the following query to copy all documents from
the `src` index with the company name `cat` into the `dest` index with
routing set to `cat`.
[source,js]
--------------------------------------------------
POST /_index_by_search
{
  "source": {
    "index": "src"
    "search": {
      "query": {
        "match": {
          "company": "cat"
        }
      }
    }
  }
  "index": {
    "index": "dest",
    "routing": "=cat"
  }
}
--------------------------------------------------
// AUTOSENSE

[float]
=== Search

You may have noticed the `search` component of the `source` in the
request body and thought "why am I typing this?" The truth is that that
`search` is actually the search that initiates scroll. You can add all
kinds of things to it just like you'd set up a scroll request:

`size`::

The number of hits returned by the
{ref}/search-request-scroll.html[scroll] request. Defaults to 100.

`sort`::

The order in which documents are processed. Defaults to `_doc` for most
efficient scrolling.

Note: `from` is not supported by scroll so its not supported here.

[float]
=== Response body

The JSON response looks like this:

[source,js]
--------------------------------------------------
{
  "took" : 639,
  "created": 123,
  "indexed": 0,
  "version_conflicts": 2,
  "failures" : [ ]  // NOCOMMIT add this
}
--------------------------------------------------

`took`::

The number of milliseconds from start to end of the whole operation.

`created`::

The number of documents that were successfully created.

`updated`::

The number of documents that were successfully updated.

`version_conflicts`::

The number of version conflicts that the process hit.

`failures`::

Array of description of all indexing failures. By default version conflicts are
not included in this list, only the counter is incremented. Set
`"save_version_conflicts": true` to keep them.
