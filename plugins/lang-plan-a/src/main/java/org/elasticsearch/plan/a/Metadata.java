/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.elasticsearch.plan.a;

import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ParseTree;
import org.elasticsearch.plan.a.Definition.Cast;
import org.elasticsearch.plan.a.Definition.Type;
import org.elasticsearch.plan.a.PlanAParser.ExpressionContext;
import org.elasticsearch.plan.a.PlanAParser.PrecedenceContext;

import java.util.HashMap;
import java.util.Map;

/**
 * Metadata is a wrapper for all the data that is collected by the {@link Analyzer}.  Each node in the ANTLR parse tree
 * will have one of the types of metadata to store information used either in a different node by the analyzer
 * or by the {@link Writer} during the byte code generation.  Metadata also contains several objects passed into the
 * {@link Analyzer} and {@link Writer} used during compilation including the {@link Definition}, the source code,
 * the root of the ANTLR parse tree, and the {@link CompilerSettings}.
 */
class Metadata {

    /**
     * StatementMetadata is used to store data mostly about
     * control flow for ANTLR nodes related to if/else, do, while, for, etc.
     */
    static class StatementMetadata {
        /**
         * The source variable is the ANTLR node used to generate this metadata.
         */
        final ParserRuleContext source;

        /**
         * The lastSource variable will be set to true when the final statement is about to be visited from the root
         * ANTLR node.  This is used to determine whether or not the auto-return feature is allowed to be used,
         * and if a null return value needs to be generated automatically since a return value is always required.
         */
        boolean lastSource = false;

        /**
         * The topLoop variable will be set to true when a loop node is initially visited.  This will not be
         * propagated down the parse tree afterwards, though.  This is used to determine
         * whether or not inLoop should be set further down the tree.  Note that inLoop alone is not enough
         * information to determine whether we are in the last statement of a loop because we may already be inside
         * a loop, so this variable is necessary.
         */
        boolean topLoop = false;

        /**
         * The inLoop variable is set to true when inside a loop.  This will be propagated down the parse tree.  This
         * is used to determine whether or not continue and break statements are legal.
         */
        boolean inLoop = false;

        /**
         * The lastLoop variable is set to true when the final statement of a loop is reached.  This will be
         * propagated down the parse tree until another loop is reached and then will be reset.  This is used
         * to determine whether or not a continue statement is superfluous.
         */
        boolean lastLoop = false;

        /**
         * The methodEscape variable is set to true when a statement would cause the method to potentially exit.  This
         * includes return and throw, and continuous loop statements.  Note that a catch statement may possibly
         * reset this to false after a throw statement.  This will be propagated up the tree as far as necessary.
         * This is used by the {@link Writer} to ensure that superfluous statements aren't unnecessarily written
         * into generated bytecode.
         */
        boolean methodEscape = false;

        /**
         * The loopEscape variable is set to true when a loop is going to be exited.  This may be caused by a number of
         * different statements including continue, break, return, etc.  This will only be propagated as far as the
         * loop node.  This is used to ensure that in certain case an infinite loop will be caught at
         * compile-time rather than run-time.
         */
        boolean loopEscape = false;

        /**
         * The allLast variable is set whenever a final statement in a block is reached. This includes the end of loop,
         * if, else, etc.  This will be only propagated to the top of the block statement node.
         * This is used to ensure that there are no unreachable statements within the script.
         */
        boolean allLast = false;

        /**
         * The anyContinue will be set to true when a continue statement is visited.  This will be propagated to the
         * loop node it's within.  This is used to ensure that in certain case an infinite loop will be caught at
         * compile-time rather than run-time.
         */
        boolean anyContinue = false;

        /**
         * The anyBreak will be set to true when a break statement is visited.  This will be propagated to the
         * loop node it's within.  This is used to in conjuction with methodEscape to ensure there are no unreachable
         * statements within the script.
         */
        boolean anyBreak = false;

        /**
         * The count variable is used as a rudimentary count of statements within a loop.  This will be used in
         * the {@link Writer} to keep a count of statements that have been executed at run-time to ensure that a loop
         * will exit if it runs too long.
         */
        int count = 0;

        /**
         * The exception variable is used to store the exception type when a throw node is visited.  This is used by
         * the {@link Writer} to write the correct type of exception in the generated byte code.
         */
        Type exception = null;

        /**
         * The slot variable is used to store the place on the stack of where a thrown exception will be stored to.
         * This is used by the {@link Writer}.
         */
        int slot = -1;

        private StatementMetadata(final ParserRuleContext source) {
            this.source = source;
        }
    }

    static class ExpressionMetadata {
        final ParserRuleContext source;

        boolean read = true;
        boolean statement = false;

        Object preConst = null;
        Object postConst = null;
        boolean isNull = false;

        Type to = null;
        Type from = null;
        boolean explicit = false;
        boolean typesafe = true;

        Cast cast = null;

        private ExpressionMetadata(final ParserRuleContext source) {
            this.source = source;
        }
    }

    static class ExternalMetadata {
        final ParserRuleContext source;

        boolean read = false;
        ParserRuleContext storeExpr = null;
        int token = 0;
        boolean pre = false;
        boolean post = false;

        int scope = 0;
        Type current = null;
        boolean statik = false;
        boolean statement = false;
        Object constant = null;

        private ExternalMetadata(final ParserRuleContext source) {
            this.source = source;
        }
    }

    static class ExtNodeMetadata {
        final ParserRuleContext parent;
        final ParserRuleContext source;

        Object target = null;
        boolean last = false;

        Type type = null;
        Type promote = null;

        Cast castFrom = null;
        Cast castTo = null;

        private ExtNodeMetadata(final ParserRuleContext parent, final ParserRuleContext source) {
            this.parent = parent;
            this.source = source;
        }
    }

    static String error(final ParserRuleContext ctx) {
        return "Error [" + ctx.getStart().getLine() + ":" + ctx.getStart().getCharPositionInLine() + "]: ";
    }

    final Definition definition;
    final String source;
    final ParserRuleContext root;
    final CompilerSettings settings;

    int inputValueSlot = -1;
    int scoreValueSlot = -1;
    int loopCounterSlot = -1;

    private final Map<ParserRuleContext, StatementMetadata> statementMetadata = new HashMap<>();
    private final Map<ParserRuleContext, ExpressionMetadata> expressionMetadata = new HashMap<>();
    private final Map<ParserRuleContext, ExternalMetadata> externalMetadata = new HashMap<>();
    private final Map<ParserRuleContext, ExtNodeMetadata> extNodeMetadata = new HashMap<>();

    Metadata(final Definition definition, final String source, final ParserRuleContext root, final CompilerSettings settings) {
        this.definition = definition;
        this.source = source;
        this.root = root;
        this.settings = settings;
    }

    StatementMetadata createStatementMetadata(final ParserRuleContext source) {
        final StatementMetadata sourcesmd = new StatementMetadata(source);
        statementMetadata.put(source, sourcesmd);

        return sourcesmd;
    }

    StatementMetadata getStatementMetadata(final ParserRuleContext source) {
        final StatementMetadata sourcesmd = statementMetadata.get(source);

        if (sourcesmd == null) {
            throw new IllegalStateException(error(source) + "Statement metadata does not exist at" +
                " the parse node with text [" + source.getText() + "].");
        }

        return sourcesmd;
    }

    ExpressionContext updateExpressionTree(ExpressionContext source) {
        if (source instanceof PrecedenceContext) {
            final ParserRuleContext parent = source.getParent();
            int index = 0;

            for (final ParseTree child : parent.children) {
                if (child == source) {
                    break;
                }

                ++index;
            }

            while (source instanceof PrecedenceContext) {
                source = ((PrecedenceContext)source).expression();
            }

            parent.children.set(index, source);
        }

        return source;
    }

    ExpressionMetadata createExpressionMetadata(ParserRuleContext source) {
        final ExpressionMetadata sourceemd = new ExpressionMetadata(source);
        expressionMetadata.put(source, sourceemd);

        return sourceemd;
    }

    ExpressionMetadata getExpressionMetadata(final ParserRuleContext source) {
        final ExpressionMetadata sourceemd = expressionMetadata.get(source);

        if (sourceemd == null) {
            throw new IllegalStateException(error(source) + "Expression metadata does not exist at" +
                " the parse node with text [" + source.getText() + "].");
        }

        return sourceemd;
    }

    ExternalMetadata createExternalMetadata(final ParserRuleContext source) {
        final ExternalMetadata sourceemd = new ExternalMetadata(source);
        externalMetadata.put(source, sourceemd);

        return sourceemd;
    }

    ExternalMetadata getExternalMetadata(final ParserRuleContext source) {
        final ExternalMetadata sourceemd = externalMetadata.get(source);

        if (sourceemd == null) {
            throw new IllegalStateException(error(source) + "External metadata does not exist at" +
                " the parse node with text [" + source.getText() + "].");
        }

        return sourceemd;
    }

    ExtNodeMetadata createExtNodeMetadata(final ParserRuleContext parent, final ParserRuleContext source) {
        final ExtNodeMetadata sourceemd = new ExtNodeMetadata(parent, source);
        extNodeMetadata.put(source, sourceemd);

        return sourceemd;
    }

    ExtNodeMetadata getExtNodeMetadata(final ParserRuleContext source) {
        final ExtNodeMetadata sourceemd = extNodeMetadata.get(source);

        if (sourceemd == null) {
            throw new IllegalStateException(error(source) + "External metadata does not exist at" +
                " the parse node with text [" + source.getText() + "].");
        }

        return sourceemd;
    }
}
