/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.elasticsearch.painless;

import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Type;
import org.objectweb.asm.commons.GeneratorAdapter;
import org.objectweb.asm.commons.Method;
import sun.misc.Unsafe;

import java.lang.invoke.CallSite;
import java.lang.invoke.ConstantCallSite;
import java.lang.invoke.LambdaConversionException;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.lang.reflect.Constructor;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.SecureClassLoader;
import java.util.BitSet;

import static org.elasticsearch.painless.WriterConstants.CLASS_NAME;
import static org.elasticsearch.painless.WriterConstants.CLASS_VERSION;
import static org.objectweb.asm.Opcodes.ACC_FINAL;
import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
import static org.objectweb.asm.Opcodes.ACC_STATIC;
import static org.objectweb.asm.Opcodes.ACC_SUPER;
import static org.objectweb.asm.Opcodes.ACC_SYNTHETIC;
import static org.objectweb.asm.Opcodes.ACONST_NULL;

public class LambdaBootstrap {
    static final class Loader extends SecureClassLoader {
        /**
         * @param parent The parent ClassLoader.
         */
        Loader(ClassLoader parent) {
            super(parent);
        }

        /**
         * Generates a Class object from the generated byte code.
         * @param name The name of the class.
         * @param bytes The generated byte code.
         * @return A Class object extending {@link PainlessScript}.
         */
        Class<?> define(String name, byte[] bytes) {
            return defineClass(name, bytes, 0, bytes.length);
        }
    }

    public static CallSite bootstrap(MethodHandles.Lookup lookup, String name, MethodType type, Object... args) {
        try {
            String baseClassName = "java/lang/Object";
            String lambdaClassName = lookup.lookupClass().getName().replace('.', '/') + "$$" + ((String)args[1]).replace('l', 'L');
            String lambdaInterfaceName = type.returnType().getName().replace('.', '/');
            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
            cw.visit(CLASS_VERSION, ACC_PUBLIC | ACC_STATIC | ACC_SUPER | ACC_FINAL | ACC_SYNTHETIC, lambdaClassName, null, baseClassName, new String[]{lambdaInterfaceName});

            String conName = "<init>";
            String conDesc = type.changeReturnType(void.class).toMethodDescriptorString();
            Method conMeth = getAsmMethod(void.class, conName);
            Type baseConType = Type.getType(Object.class);
            Method baseConMeth = getAsmMethod(void.class, conName);
            GeneratorAdapter constructor = new GeneratorAdapter(ACC_PUBLIC, conMeth, cw.visitMethod(ACC_PUBLIC, conName, conDesc, null, null));
            constructor.visitCode();
            constructor.loadThis();
            constructor.invokeConstructor(baseConType, baseConMeth);
            constructor.returnValue();
            constructor.endMethod();

            Type scriptClassType = Type.getType(lookup.lookupClass());
            Method lambdaMethod = new Method((String)args[1], ((MethodType)args[2]).toMethodDescriptorString());
            Method delegateMethod = new Method(name, ((MethodType)args[0]).toMethodDescriptorString());
            MethodWriter delegate = new MethodWriter(ACC_PUBLIC, delegateMethod, cw, null, null);
            delegate.visitCode();
            delegate.invokeStatic(scriptClassType, lambdaMethod);
            delegate.returnValue();
            delegate.endMethod();

            cw.visitEnd();

            final byte[] classBytes = cw.toByteArray();

            final Class<?> lambdaClass = AccessController.doPrivileged(
                new PrivilegedAction<Class<?>>() {
                    @Override
                    public Class<?> run() {
                        Loader loader = new Loader(lookup.lookupClass().getClassLoader());
                        return loader.define(lambdaClassName.replace('/', '.'), classBytes);
                    }
                });

            final Constructor<?> ctr = AccessController.doPrivileged(
                new PrivilegedAction<Constructor<?>>() {
                    @Override
                    public Constructor<?> run() {
                        try {
                            return lambdaClass.getConstructor();
                        } catch (Exception exception) {
                            throw new RuntimeException(exception);
                        }
                    }
                });

            try {
                Object inst = ctr.newInstance();
                return new ConstantCallSite(MethodHandles.constant(type.returnType(), inst));
            }
            catch (ReflectiveOperationException e) {
                throw new LambdaConversionException("Exception instantiating lambda object", e);
            }
        } catch (Exception exception) {
            throw new RuntimeException(exception);
        }
    }

    private static Method getAsmMethod(final Class<?> rtype, final String name, final Class<?>... ptypes) {
        return new Method(name, MethodType.methodType(rtype, ptypes).toMethodDescriptorString());
    }
}
