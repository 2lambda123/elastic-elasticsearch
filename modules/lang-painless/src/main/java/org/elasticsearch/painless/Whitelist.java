/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.elasticsearch.painless;

import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;

/**
 * Whitelist contains data structures and methods designed to either load or generate a white-list of
 * Java classes, methods, and fields that can be used within a Painless script.  Whitelist is used directly
 * to create a new {@link Definition} and is passed into {@link Definition#Definition(Whitelist)}.
 * {@link Definition}'s are then used as part of each Painless script at both compile-time and
 * run-time to determine what a script is allowed to execute.
 *
 * Several single letters are used as prefixes for many variables in this class.  They mean the following:
 * p - Used as part of the Painless typing system
 * j - Used as part of the Java typing system
 * w = Used as part of the Whitelist typing system
 *
 * A Whitelist consists of two pieces.  The first is a list {@link Whitelist#pDynamicTypeNames} of {@link String}s
 * that represent the allowed name(s) of dynamic types in Painless.  The second is a list of {@link WStruct}s
 * that represent the equivalent of a Java class in Painless known as a struct.  These will be the types
 * available for use in Painless scripts compiled using a {@link Definition} generated by this Whitelist.
 */
public final class Whitelist {

    /**
     * WStruct represents the equivalent of a Java class in Painless complete with super classes,
     * constructors, methods, and fields.  In Painless a class is known as a struct primarily to avoid
     * naming conflicts internally.
     *
     * Structs in Painless allow for arity overloading for constructors and methods.  Arity overloading
     * means that multiple constructors are allowed for a single struct as long as they have a different
     * number of parameter types, and multiples methods with the same name are allowed for a single struct
     * as long as they have the same return type and a different number of parameter types.
     *
     * Structs are allowed to extend other structs, known as a super struct, in which they will have
     * available all of the methods and fields from a super struct.
     */
    static class WStruct {

        /** The Painless name of this struct which will also be the name of a type in a Painless script.  */
        final String pTypeName;

        /** The Java class this struct represents. */
        final Class<?> jClass;

        /** The {@link List} of Painless structs, as names, this struct extends. */
        final List<String> pSuperTypeNames;

        /** The {@link Set} of white-listed constructors ({@link WConstructor}s) available to this struct. */
        final Set<WConstructor> wConstructors;

        /** The {@link Set} of white-listed methods ({@link WMethod}s) available to this struct. */
        final Set<WMethod> wMethods;

        /** The {@link Set} of white-listed fields ({@link WField}s) available to this struct. */
        final Set<WField> wFields;

        /** Standard constructor. All values must be not {@code null}. */
        private WStruct(String pTypeName, Class<?> jClass, List<String> pSuperTypeNames,
                       Set<WConstructor> wConstructors, Set<WMethod> wMethods, Set<WField> wFields) {
            this.pTypeName = Objects.requireNonNull(pTypeName);
            this.jClass = Objects.requireNonNull(jClass);
            this.pSuperTypeNames = Collections.unmodifiableList(Objects.requireNonNull(pSuperTypeNames));

            this.wConstructors = Collections.unmodifiableSet(Objects.requireNonNull(wConstructors));
            this.wMethods = Collections.unmodifiableSet(Objects.requireNonNull(wMethods));
            this.wFields = Collections.unmodifiableSet(Objects.requireNonNull(wFields));
        }
    }

    /**
     * WConstructor represents the equivalent of a Java constructor available as a white-listed struct
     * constructor within Painless.  Constructors for Painless structs may be accessed exactly as
     * constructors for Java classes are using the 'new' keyword.  Painless structs may have multiple
     * constructors as long as they comply with arity overloading described for {@link WStruct}.
     */
    static class WConstructor {

        /** The Java reflection {@link Constructor} available as a Painless struct constructor. */
        final Constructor<?> jConstructor;

        /** The {@link List} of this constructor's parameter types as Painless struct names. */
        final List<String> pParameterTypeNames;

        /** Standard constructor. All values must be not {@code null}. */
        private WConstructor(Constructor<?> jConstructor, List<String> pParameterTypeNames) {
            this.jConstructor = Objects.requireNonNull(jConstructor);
            this.pParameterTypeNames = Collections.unmodifiableList(Objects.requireNonNull(pParameterTypeNames));
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            WConstructor that = (WConstructor)o;

            return jConstructor.equals(that.jConstructor);
        }

        @Override
        public int hashCode() {
            return jConstructor.hashCode();
        }
    }

    /**
     * WMethod represents the equivalent of a Java method available as a white-listed struct method
     * within Painless.  Methods for Painless structs may be accessed exactly as methods for Java classes
     * are using the '.' operator on an existing struct variable/field.  Painless structs may have multiple
     * methods with the same name as long as they comply with arity overloading described for {@link WMethod}.
     *
     * Structs may also have additional methods that are not part of the Java class the struct represents -
     * these are known as augmented methods.  An augmented method can be added to a struct as a part of any
     * Java class as long as the method is static and the first parameter of the method is the Java class
     * represented by the struct.  Note that the augmented method's parent Java class does not need to be
     * white-listed.
     */
    static class WMethod {

        /** The Java reflection {@link Method} available as a Painless struct method. */
        final Method jMethod;

        /** The Java {@link Class} owner for an augmented method.  If the method is not augmented this should be {@code null}. */
        final Class<?> jAugmentedClass;

        /** The return type as a Painless struct name. */
        final String pReturnTypeName;

        /** The {@link List} of this constructor's parameter types as Painless struct names. */
        final List<String> pParameterTypeNames;

        /**
         * Standard constructor. All values must be not {@code null} with the exception of jAugmentedClass;
         * jAugmentedClass will be {@code null} unless the method is augmented as described in the class documentation.
         */
        private WMethod(Method jMethod, Class<?> jAugmentedClass, String pReturnTypeName, List<String> pParameterTypeNames) {
            this.jMethod = Objects.requireNonNull(jMethod);
            this.jAugmentedClass = jAugmentedClass;
            this.pReturnTypeName = Objects.requireNonNull(pReturnTypeName);
            this.pParameterTypeNames = Collections.unmodifiableList(Objects.requireNonNull(pParameterTypeNames));
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            WMethod wMethod = (WMethod)o;

            return jMethod.equals(wMethod.jMethod);
        }

        @Override
        public int hashCode() {
            return jMethod.hashCode();
        }
    }

    /**
     * WField represents the equivalent of a Java field available as a white-listed struct field
     * within Painless.  Fields for Painless structs may be accessed exactly as fields for Java classes
     * are using the '.' operator on an existing struct variable/field.
     */
    static class WField {

        /** The Java reflection {@link Field} available as a Painless struct field. */
        final Field jField;

        /** The field type as a Painless struct name. */
        final String pTypeName;

        /** Standard constructor. All values must be not {@code null}. */
        private WField(Field jField, String pTypeName) {
            this.jField = Objects.requireNonNull(jField);
            this.pTypeName = Objects.requireNonNull(pTypeName);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            WField wField = (WField)o;

            return jField.equals(wField.jField);
        }

        @Override
        public int hashCode() {
            return jField.hashCode();
        }
    }

    /**
     * Loads and creates a {@link Whitelist} from one to many text files.  The file paths are passed in as a
     * {@link Map} with keys of {@link Class} and values of {@link List}s of {@link String}s where each {@link String}
     * is the path of a single text file.  The key {@link Class} for each {@link List} of file paths will be
     * used to load each file path in the {@link List} as a resource and then the key {@link Class}'s
     * {@link ClassLoader} will be used to lookup the Java reflection objects for each individual {@link Class},
     * {@link Constructor}, {@link Method}, and {@link Field} specified as part of the white-list in the text file.
     *
     * Two passes are made through each specified text file.  The first pass will load both the dynamic Painless
     * type names and static Painless type names that can then be used during a second pass as a lookup for Painless
     * constructor/method/field return and parameter type names.  The second pass will load each individual
     * constructor, method, and field that will be white-listed for use in Painless scripts.
     *
     * The following can be parsed:
     * - Blank lines will be ignored by the parser.
     * - Comments may be created starting with a pound '#; symbol and end with a newline.  These will
     *   be ignored by the parser.
     * - Dynamic types may be specified starting with 'dynamic' and followed by a single Painless type
     *   name and a newline.
     * - Primitive types may be specified starting with 'class' and followed by the Painless type
     *   name (often the same as the Java type name), an arrow symbol, the Java type name,
     *   an opening bracket, a newline, a closing bracket, and a final newline.
     * - Complex types may be specified starting with 'class' and followed by the Painless type name,
     *   an arrow symbol, the Java class name, a opening bracket, a newline, constructor/method/field
     *   specifications, a closing bracket, and a final newline. Within a complex type the following
     *   may be parsed:
     *   -- A constructor may be specified starting with an opening parenthesis, followed by a
     *      comma-delimited list of Painless type names corresponding to the type/class names for
     *      the equivalent Java parameter types (these must be white-listed as well), a closing
     *      parenthesis, and a newline.
     *   -- A method may be specified starting with a Painless type name for the return type,
     *      followed by the Java name of the method (which will also be the Painless name for the
     *      method), an opening parenthesis, a comma-delimited list of Painless type names
     *      corresponding to the type/class names for the equivalent Java parameter types
     *      (these must be white-listed as well), a closing parenthesis, and a newline.
     *   -- An augmented method may be specified starting with a Painless type name for the return
     *      type, followed by the fully qualified Java name of the class the augmented method is
     *      part of (this class does not need to be white-listed), the Java name of the method
     *      (which will also be the Painless name for the method), an opening parenthesis, a
     *      comma-delimited list of Painless type names corresponding to the type/class names
     *      for the equivalent Java parameter types (these must be white-listed as well), a closing
     *      parenthesis, and a newline.
     *   -- A field may be specified starting with a Painless type name for the equivalent Java type
     *      of the field, followed by the Java name of the field (which all be the Painless name
     *      for the field), and a newline.
     *
     * Note there must be a one-to-one correspondence of Painless type names to Java type/class names.
     * If the same Painless type is defined across multiple files and the Java class is the same, all
     * specified constructors, methods, and fields will be merged into a single Painless type.  Dynamic
     * types will always be equivalent to an {@link Object} as a base, but resolution of method calls
     * and field access will be determined at run-time.
     *
     * The following example is used to create a single white-list text file:
     *
     * {@code
     * # dynamic types
     *
     * dynamic def
     *
     * # primitive types
     *
     * class int -> int {
     * }
     *
     * # complex types
     *
     * class Example -> my.package.Example {
     *   # constructors
     *   ()
     *   (int)
     *   (Example)
     *
     *   # method
     *   Example add(int)
     *   int add(Example, Example)
     *   void example()
     *
     *   # augmented
     *   Example some.other.Class sub(int)
     *
     *   # fields
     *   int value0
     *   int value1
     * }
     * }
     */
    public static Whitelist loadFromResourceFiles(Map<Class<?>, List<String>> resourcesToFiles) {
        Set<String> pDynamicTypeNames = new HashSet<>();
        Map<String, Class<?>> pTypeNamesToJClasses = new HashMap<>();

        // Execute a first-pass through the white-list text files.  This will gather
        // all the Painless dynamic type names and create a map of Painless type names
        // to their corresponding Java types/classes for later use during lookup of
        // return and parameter types for constructors, fields, and methods.
        for (Entry<Class<?>, List<String>> resourceToFiles : resourcesToFiles.entrySet()) {
            Class<?> resource = resourceToFiles.getKey();
            List<String> filepaths = resourceToFiles.getValue();

            for (String filepath : filepaths) {
                String line;
                int number = -1;

                try (LineNumberReader reader = new LineNumberReader(
                    new InputStreamReader(resource.getResourceAsStream(filepath), StandardCharsets.UTF_8))) {

                    while ((line = reader.readLine()) != null) {
                        number = reader.getLineNumber();
                        line = line.trim();

                        // Skip any lines that are either blank or comments.
                        if (line.length() == 0 || line.charAt(0) == '#') {
                            continue;
                        }

                        // Handle the case where Painless dynamic type names are listed.
                        // Expects the following format: 'dynamic' ID '\n'
                        if (line.startsWith("dynamic ")) {
                            // Parse based on the expected format.
                            String[] tokens = line.split("\\s+");

                            // Ensure the correct number of tokens.
                            if (tokens.length != 2) {
                                throw new IllegalArgumentException("invalid dynamic definition: unexpected format [" + line + "]");
                            }

                            String pDynamicTypeName = tokens[1];

                            // Ensure a non-dynamic type name hasn't already been defined with the same type name.
                            if (pTypeNamesToJClasses.containsKey(pDynamicTypeName)) {
                                throw new IllegalArgumentException(
                                    "invalid dynamic definition: name [" + pDynamicTypeName + "] already defined as a struct");
                            }

                            pDynamicTypeNames.add(pDynamicTypeName);

                        // Handle the case where Painless primitive/complex type names are listed.
                        // Expects the following format: 'class' ID -> ID ( 'extends' ID ( ',' ID )* )? '{'
                        } else if (line.startsWith("class ")) {
                            // Ensure the final token of the line is '{'.
                            if (line.endsWith("{") == false) {
                                throw new IllegalArgumentException(
                                    "invalid struct definition: failed to parse class opening bracket [" + line + "]");
                            }

                            // Parse based on the expected format prior to the 'extends' token.
                            int extendsIndex = line.indexOf(" extends ");
                            String[] tokens =
                                line.substring(5, extendsIndex == -1 ? line.length() - 1 : extendsIndex).replaceAll("\\s+", "").split("->");

                            // Ensure the correct number of tokens.
                            if (tokens.length < 1 || tokens.length > 2) {
                                throw new IllegalArgumentException("invalid struct definition: failed to parse class name [" + line + "]");
                            }

                            String pTypeName = tokens[0];

                            if (pDynamicTypeNames.contains(pTypeName)) {
                                throw new IllegalArgumentException(
                                    "invalid struct definition: [" + pTypeName + "] already defined as a dynamic type name");
                            }

                            String jClassName = tokens.length == 2 ? tokens[1] : pTypeName;
                            Class<?> jClass;

                            // Retrieve the Java class from the Java class name using the ClassLoader from
                            // the current resource class to ensure the Java class exists.
                            if ("void".equals(jClassName)) {
                                jClass = void.class;
                            } else if ("boolean".equals(jClassName)) {
                                jClass = boolean.class;
                            } else if ("byte".equals(jClassName)) {
                                jClass = byte.class;
                            } else if ("short".equals(jClassName)) {
                                jClass = short.class;
                            } else if ("char".equals(jClassName)) {
                                jClass = char.class;
                            } else if ("int".equals(jClassName)) {
                                jClass = int.class;
                            } else if ("long".equals(jClassName)) {
                                jClass = long.class;
                            } else if ("float".equals(jClassName)) {
                                jClass = float.class;
                            } else if ("double".equals(jClassName)) {
                                jClass = double.class;
                            } else {
                                jClass = Class.forName(jClassName, true, resource.getClassLoader());
                            }

                            Class<?> jDuplicateClass = pTypeNamesToJClasses.get(pTypeName);

                            // Ensure that if a Java class has already been associated with a Painless type name,
                            // the same association is made if there are duplicate definitions.
                            if (jDuplicateClass != null && jDuplicateClass.equals(jClass) == false) {
                                throw new IllegalArgumentException("invalid struct definition: name [" + pTypeName + "] has been defined" +
                                    " to be at least two different classes [" + jDuplicateClass + "] and [" + jClass + "]");
                            }

                            pTypeNamesToJClasses.put(pTypeName, jClass);
                        }
                    }
                } catch (Exception exception) {
                    throw new RuntimeException("error in [" + filepath + "] at line [" + number + "]", exception);
                }
            }
        }

        Map<String, WStruct> wStructs = new HashMap<>();

        // Execute a second-pass through the white-list text files.  This will gather all the
        // constructors, methods, augmented methods, and fields for each white-listed struct.
        // Previously gathered data from the first-pass is used to ensure that all the type names
        // specified for both Painless and Java are valid.
        for (Entry<Class<?>, List<String>> resourceToFiles : resourcesToFiles.entrySet()) {
            Class<?> resource = resourceToFiles.getKey();
            List<String> files = resourceToFiles.getValue();

            // Function to retrieve a Java class from a Painless type name with support
            // for array-types using the ClassLoader from the current resource class to
            // ensure the Java class exists.
            Function<String, Class<?>> getJClassFromPTypeName = pTypeName -> {
                int arrayDimensions = 0;
                int firstBraceIndex = pTypeName.indexOf('[');
                String pNonArrayTypeName = pTypeName;

                // Count the number of dimensions for a possible array type, and set the appropriate non-array type.
                if (firstBraceIndex != -1) {
                    int length = pTypeName.length();

                    while (firstBraceIndex < length) {
                        if (pTypeName.charAt(firstBraceIndex) == '[' && ++firstBraceIndex < length &&
                                pTypeName.charAt(firstBraceIndex++) == ']') {
                            ++arrayDimensions;
                        } else {
                            throw new IllegalArgumentException("invalid struct/dynamic name [" + pTypeName + "]");
                        }
                    }

                    pNonArrayTypeName = pTypeName.substring(0, pTypeName.length() - arrayDimensions*2);
                }

                // Look up the non-array class using Object if the type is a dynamic.
                Class<?> jClass =
                    pDynamicTypeNames.contains(pNonArrayTypeName) ? Object.class : pTypeNamesToJClasses.get(pNonArrayTypeName);

                // Ensure the class has been white-listed.
                if (jClass == null) {
                    throw new IllegalArgumentException("invalid struct/dynamic name [" + pTypeName + "]");
                }

                // If the Painless type name is an array type, look up the Java class for the array type.
                if (arrayDimensions > 0) {
                    String jNonArrayTypeName = jClass.getName();

                    if ("boolean".equals(jNonArrayTypeName)) {
                        jNonArrayTypeName = "Z";
                    } else if ("byte".equals(jNonArrayTypeName)) {
                        jNonArrayTypeName = "B";
                    } else if ("short".equals(jNonArrayTypeName)) {
                        jNonArrayTypeName = "S";
                    } else if ("char".equals(jNonArrayTypeName)) {
                        jNonArrayTypeName = "C";
                    } else if ("int".equals(jNonArrayTypeName)) {
                        jNonArrayTypeName = "I";
                    } else if ("long".equals(jNonArrayTypeName)) {
                        jNonArrayTypeName = "J";
                    } else if ("float".equals(jNonArrayTypeName)) {
                        jNonArrayTypeName = "F";
                    } else if ("double".equals(jNonArrayTypeName)) {
                        jNonArrayTypeName = "D";
                    } else if ("void".equals(jNonArrayTypeName)) {
                        jNonArrayTypeName = "V";
                    } else {
                        jNonArrayTypeName = "L" + jNonArrayTypeName + ";";
                    }

                    StringBuilder jArrayTypeName = new StringBuilder();

                    for (int dimension = 0; dimension < arrayDimensions; ++dimension) {
                        jArrayTypeName.append('[');
                    }

                    jArrayTypeName.append(jNonArrayTypeName);

                    try {
                        jClass = Class.forName(jArrayTypeName.toString(), true, resource.getClassLoader());
                    } catch (ClassNotFoundException cnfe) {
                        throw new IllegalArgumentException("invalid struct/dynamic name [" + pTypeName + "]", cnfe);
                    }
                }

                return jClass;
            };

            for (String file : files) {
                String line;
                int number = -1;

                try (LineNumberReader reader = new LineNumberReader(
                    new InputStreamReader(resource.getResourceAsStream(file), StandardCharsets.UTF_8))) {

                    String pTypeName = null;
                    Class<?> jClass = null;
                    List<String> pSuperTypeNames = null;
                    Set<WConstructor> wConstructors = null;
                    Set<WMethod> wMethods = null;
                    Set<WField> wFields = null;

                    while ((line = reader.readLine()) != null) {
                        number = reader.getLineNumber();
                        line = line.trim();

                        // Skip any lines that are either blank or comments.  Also skip any dynamic headers
                        // as there is no more useful information to gather from them in a second-pass.
                        if (line.length() == 0 || line.charAt(0) == '#' || line.startsWith("dynamic ")) {
                            continue;
                        }

                        // Handle a new Painless struct by resetting all the variables necessary to
                        // construct a new WStruct for the white-list.
                        // Expects the following format: 'class' ID -> ID ( 'extends' ID ( ',' ID )* )? '{'
                        if (line.startsWith("class ")) {
                            int extendsIndex = line.indexOf(" extends ");
                            String[] tokens =
                                line.substring(5, extendsIndex == -1 ? line.length() - 1 : extendsIndex).replaceAll("\\s+", "").split("->");

                            // Reset all the variables to support a new struct.
                            pTypeName = tokens[0];
                            jClass = pTypeNamesToJClasses.get(pTypeName);
                            pSuperTypeNames = Collections.emptyList();
                            wConstructors = new HashSet<>();
                            wMethods = new HashSet<>();
                            wFields = new HashSet<>();

                            // If the Painless type extends other Painless types, parse the list of type names and store them.
                            if (extendsIndex != -1) {
                                tokens = line.substring(extendsIndex + 9, line.length() - 1).replaceAll("\\s+", "").split(",");
                                pSuperTypeNames = Arrays.asList(tokens);
                            }

                        // Handle the end of a Painless struct, by creating a new WStruct with all the previously gathered
                        // constructors, methods, augmented methods, and fields, and adding it the list of white-listed structs.
                        } else if (line.equals("}")) {
                            if (pTypeName == null) {
                                throw new IllegalArgumentException("invalid struct definition: extraneous closing bracket");
                            }

                            WStruct wStruct = wStructs.get(pTypeName);

                            // If this Painless struct has already been defined, merge the new constructors, methods, augmented
                            // methods, and fields with the previous ones.
                            if (wStruct != null) {
                                // Ensure the super types are identical between the new struct and the old struct or merging
                                // cannot be completed.
                                if (pSuperTypeNames.equals(wStruct.pSuperTypeNames) == false) {
                                    throw new IllegalArgumentException("invalid struct definition: when attempting to merge " +
                                        "type [" + pTypeName + "] from multiple files, super types do not match");
                                }

                                wConstructors.addAll(wStruct.wConstructors);
                                wMethods.addAll(wStruct.wMethods);
                                wFields.addAll(wStruct.wFields);
                            }

                            wStructs.put(pTypeName, new WStruct(pTypeName, jClass, pSuperTypeNames, wConstructors, wMethods, wFields));

                            // Set all the variables to null to ensure a new struct definition is found before other parsable values.
                            pTypeName = null;
                            jClass = null;
                            pSuperTypeNames = null;
                            wConstructors = null;
                            wMethods = null;
                            wFields = null;

                        // Handle all other valid cases.
                        } else {
                            // Ensure we have a defined struct before adding any constructors, methods, augmented methods, or fields.
                            if (pTypeName == null) {
                                throw new IllegalArgumentException("invalid object definition: expected a class name [" + line + "]");
                            }


                            if (line.startsWith("(")) {
                                if (line.endsWith(")") == false) {
                                    throw new IllegalArgumentException(
                                        "invalid constructor definition: expected a closing parenthesis [" + line + "]");
                                }

                                String[] elements = line.substring(1, line.length() - 1).replaceAll("\\s+", "").split(",");

                                if ("".equals(elements[0])) {
                                    elements = new String[0];
                                }

                                Class<?>[] jparameters = new Class<?>[elements.length];

                                for (int parameter = 0; parameter < jparameters.length; ++parameter) {
                                    try {
                                        jparameters[parameter] = getJClassFromPTypeName.apply(elements[parameter]);
                                    } catch (IllegalArgumentException iae) {
                                        throw new IllegalArgumentException(
                                            "invalid constructor definition: invalid parameter [" + elements[parameter] + "]", iae);
                                    }
                                }

                                Constructor<?> jconstructor;

                                try {
                                    jconstructor = jClass.getConstructor(jparameters);
                                } catch (NoSuchMethodException nsme) {
                                    throw new IllegalArgumentException(
                                        "invalid constructor definition: failed to look up constructor [" + line + "]", nsme);
                                }

                                wConstructors.add(new WConstructor(jconstructor, Arrays.asList(elements)));
                            } else if (line.contains("(")) {
                                if (line.endsWith(")") == false) {
                                    throw new IllegalArgumentException(
                                        "invalid method definition: expected a closing parenthesis [" + line + "]");
                                }

                                int index = line.indexOf('(');
                                String[] elements = line.substring(0, index).split("\\s+");
                                String methodname;
                                Class<?> augmented;

                                if (elements.length == 2) {
                                    methodname = elements[1];
                                    augmented = null;
                                } else if (elements.length == 3) {
                                    methodname = elements[2];

                                    try {
                                        augmented = Class.forName(elements[1], true, resource.getClassLoader());
                                    } catch (ClassNotFoundException cnfe) {
                                        throw new IllegalArgumentException(
                                            "invalid method definition: augmented class [" + elements[1] + "] does not exist", cnfe);
                                    }
                                } else {
                                    throw new IllegalArgumentException("invalid method definition: unexpected format [" + line + "]");
                                }

                                String preturn = elements[0];

                                try {
                                    getJClassFromPTypeName.apply(preturn);
                                } catch (IllegalArgumentException iae) {
                                    throw new IllegalArgumentException("invalid method definition: invalid return [" + preturn + "]", iae);
                                }

                                elements = line.substring(index + 1, line.length() - 1).replaceAll("\\s+", "").split(",");
                                Class<?>[] jparameters;

                                if ("".equals(elements[0])) {
                                    elements = new String[0];
                                }

                                if (augmented == null) {
                                    jparameters = new Class<?>[elements.length];

                                    for (int parameter = 0; parameter < jparameters.length; ++parameter) {
                                        try {
                                            jparameters[parameter] = getJClassFromPTypeName.apply(elements[parameter]);
                                        } catch (IllegalArgumentException iae) {
                                            throw new IllegalArgumentException(
                                                "invalid method definition: invalid parameter [" + elements[parameter] + "]", iae);
                                        }
                                    }
                                } else {
                                    jparameters = new Class<?>[1 + elements.length];
                                    jparameters[0] = jClass;

                                    for (int parameter = 1; parameter < jparameters.length; ++parameter) {
                                        try {
                                            jparameters[parameter] = getJClassFromPTypeName.apply(elements[parameter - 1]);
                                        } catch (IllegalArgumentException iae) {
                                            throw new IllegalArgumentException(
                                                "invalid method definition: invalid parameter [" + elements[parameter - 1] + "]", iae);
                                        }
                                    }
                                }

                                Method jmethod;

                                try {
                                    jmethod = (augmented == null ? jClass : augmented).getMethod(methodname, jparameters);
                                } catch (NoSuchMethodException nsme) {
                                    throw new IllegalArgumentException(
                                        "invalid method definition: failed to look up method [" + line + "]", nsme);
                                }

                                wMethods.add(new WMethod(jmethod, augmented, preturn, Arrays.asList(elements)));
                            } else {
                                String[] elements = line.split("\\s+");

                                if (elements.length != 2) {
                                    throw new IllegalArgumentException("invalid field definition: unexpected format [" + line + "]");
                                }

                                try {
                                    getJClassFromPTypeName.apply(elements[0]);
                                } catch (IllegalArgumentException iae) {
                                    throw new IllegalArgumentException("invalid field definition: invalid type [" + elements[0] + "]", iae);
                                }

                                Field jfield;

                                try {
                                    jfield = jClass.getField(elements[1]);
                                } catch (NoSuchFieldException nsfe) {
                                    throw new IllegalArgumentException(
                                        "invalid field definition: field [" + elements[0] + "] does not exist", nsfe);
                                }

                                wFields.add(new WField(jfield, elements[0]));
                            }
                        }
                    }

                    if (pTypeName != null) {
                        throw new IllegalArgumentException("invalid struct definition: expected closing bracket");
                    }
                } catch (Exception exception) {
                    throw new RuntimeException("error in [" + file + "] at line [" + number + "]", exception);
                }
            }
        }

        return new Whitelist(pDynamicTypeNames, wStructs.values());
    }

    final Set<String> pDynamicTypeNames;
    final Collection<WStruct> wStructs;

    private Whitelist(Set<String> pDynamicTypeNames, Collection<WStruct> wStructs) {
        this.pDynamicTypeNames = Collections.unmodifiableSet(Objects.requireNonNull(pDynamicTypeNames));
        this.wStructs = Collections.unmodifiableCollection(Objects.requireNonNull(wStructs));
    }
}
