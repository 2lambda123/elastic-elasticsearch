/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.elasticsearch.painless;

import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;

/**
 * Whitelist contains data structures and methods designed to either load or generate a white-list of
 * Java classes, methods, and fields that can be used within a Painless script.  Whitelist is used directly
 * to create a new {@link Definition} and is passed into {@link Definition#Definition(Whitelist)}.
 * {@link Definition}'s are then used as part of each Painless script at both compile-time and
 * run-time to determine what a script is allowed to execute.
 *
 * Several single letters are used as prefixes for many variables in this class.  They mean the following:
 * p - Used as part of the Painless typing system
 * j - Used as part of the Java typing system
 * w = Used as part of the Whitelist typing system
 *
 * A Whitelist consists of two pieces.  The first is a list {@link Whitelist#pdynamics} of {@link String}s
 * that represent the allowed name(s) of dynamic types in Painless.  The second is a list of {@link WStruct}s
 * that represent the equivalent of a Java class in Painless known as a struct.  These will be the types
 * available for use in Painless scripts compiled using a {@link Definition} generated by this Whitelist.
 */
public final class Whitelist {

    /**
     * WStruct represents the equivalent of a Java class in Painless complete with super classes,
     * constructors, methods, and fields.  In Painless a class is known as a struct primarily to avoid
     * naming conflicts internally.
     *
     * Structs in Painless allow for arity overloading for constructors and methods.  Arity overloading
     * means that multiple constructors are allowed for a single struct as long as they have a different
     * number of parameter types, and multiples methods with the same name are allowed for a single struct
     * as long as they have the same return type and a different number of parameter types.
     *
     * Structs are allowed to extend other structs, known as a super struct, in which they will have
     * available all of the methods and fields from a super struct.
     */
    static class WStruct {

        /** The Painless name of this struct which will also be the name of a type in a Painless script.  */
        final String pTypeName;

        /** The Java class this struct represents. */
        final Class<?> jClass;

        /** The {@link List} of Painless structs, as names, this struct extends. */
        final List<String> pSuperTypeNames;

        /** The {@link List} of white-listed constructors ({@link WConstructor}s) available to this struct. */
        final List<WConstructor> wConstructors;

        /** The {@link List} of white-listed methods ({@link WMethod}s) available to this struct. */
        final List<WMethod> wMethods;

        /** The {@link List} of white-listed fields ({@link WField}s) available to this struct. */
        final List<WField> wFields;

        /** Standard constructor. All values must be not {@code null}. */
        private WStruct(String pTypeName, Class<?> jClass, List<String> pSuperTypeNames,
                       List<WConstructor> wConstructors, List<WMethod> wMethods, List<WField> wFields) {
            this.pTypeName = Objects.requireNonNull(pTypeName);
            this.jClass = Objects.requireNonNull(jClass);
            this.pSuperTypeNames = Collections.unmodifiableList(Objects.requireNonNull(pSuperTypeNames));

            this.wConstructors = Collections.unmodifiableList(Objects.requireNonNull(wConstructors));
            this.wMethods = Collections.unmodifiableList(Objects.requireNonNull(wMethods));
            this.wFields = Collections.unmodifiableList(Objects.requireNonNull(wFields));
        }
    }

    /**
     * WConstructor represents the equivalent of a Java constructor available as a white-listed struct
     * constructor within Painless.  Constructors for Painless structs may be accessed exactly as
     * constructors for Java classes are using the 'new' keyword.  Painless structs may have multiple
     * constructors as long as they comply with arity overloading described for {@link WStruct}.
     */
    static class WConstructor {

        /** The Java reflection {@link Constructor} available as a Painless struct constructor. */
        final Constructor<?> jConstructor;

        /** The {@link List} of this constructor's parameter types as Painless struct names. */
        final List<String> pParameterTypeNames;

        /** Standard constructor. All values must be not {@code null}. */
        private WConstructor(Constructor<?> jConstructor, List<String> pParameterTypeNames) {
            this.jConstructor = Objects.requireNonNull(jConstructor);
            this.pParameterTypeNames = Collections.unmodifiableList(Objects.requireNonNull(pParameterTypeNames));
        }
    }

    /**
     * WMethod represents the equivalent of a Java method available as a white-listed struct method
     * within Painless.  Methods for Painless structs may be accessed exactly as methods for Java classes
     * are using the '.' operator on an existing struct variable/field.  Painless structs may have multiple
     * methods with the same name as long as they comply with arity overloading described for {@link WMethod}.
     *
     * Structs may also have additional methods that are not part of the Java class the struct represents -
     * these are known as augmented methods.  An augmented method can be added to a struct as a part of any
     * Java class as long as the method is static and the first parameter of the method is the Java class
     * represented by the struct.  Note that the augmented method's parent Java class does not need to be
     * white-listed.
     */
    static class WMethod {

        /** The Java reflection {@link Method} available as a Painless struct method. */
        final Method jMethod;

        /** The Java {@link Class} owner for an augmented method.  If the method is not augmented this should be {@code null}. */
        final Class<?> jAugmentedClass;

        /** The return type as a Painless struct name. */
        final String pReturnTypeName;

        /** The {@link List} of this constructor's parameter types as Painless struct names. */
        final List<String> pParameterTypeNames;

        /**
         * Standard constructor. All values must be not {@code null} with the exception of jAugmentedClass;
         * jAugmentedClass will be {@code null} unless the method is augmented as described in the class documentation.
         */
        private WMethod(Method jMethod, Class<?> jAugmentedClass, String pReturnTypeName, List<String> pParameterTypeNames) {
            this.jMethod = Objects.requireNonNull(jMethod);
            this.jAugmentedClass = jAugmentedClass;
            this.pReturnTypeName = Objects.requireNonNull(pReturnTypeName);
            this.pParameterTypeNames = Collections.unmodifiableList(Objects.requireNonNull(pParameterTypeNames));
        }
    }

    /**
     * WField represents the equivalent of a Java field available as a white-listed struct field
     * within Painless.  Fields for Painless structs may be accessed exactly as fields for Java classes
     * are using the '.' operator on an existing struct variable/field.
     */
    static class WField {

        /** The Java reflection {@link Field} available as a Painless struct field. */
        final Field jField;

        /** The field type as a Painless struct name. */
        final String pTypeName;

        /** Standard constructor. All values must be not {@code null}. */
        private WField(Field jField, String pTypeName) {
            this.jField = Objects.requireNonNull(jField);
            this.pTypeName = Objects.requireNonNull(pTypeName);
        }
    }

    /**
     * Loads and creates a {@link Whitelist} from one to many text files.  The file paths are passed in as a
     * {@link Map} with keys of {@link Class} and values of {@link List}s of {@link String}s where each {@link String}
     * is the path of a single text file.  The key {@link Class} for each {@link List} of file paths will be
     * used to load each file path in the {@link List} as a resource and then the key {@link Class}'s
     * {@link ClassLoader} will be used to lookup the Java reflection objects for each individual {@link Class},
     * {@link Constructor}, {@link Method}, and {@link Field} specified as part of the white-list in the text file.
     *
     * Two passes are made through each specified text file.  The first pass will load both the dynamic Painless
     * type names and static Painless type names that can then be used during a second pass as a lookup for Painless
     * constructor/method/field return and parameter type names.  The second pass will load each individual
     * constructor, method, and field that will be white-listed for use in Painless scripts.
     *
     * The following example is used to create a single white-list text file:
     *
     * {@code
     * # dynamic types
     *
     * dynamic def
     *
     * # primitive types
     *
     * class int -> int {
     * }
     *
     * # complex types
     *
     * class Example -> my.package.Example {
     *   # constructors
     *   ()
     *   (int)
     *   (Example)
     *
     *   # method
     *   Example add(int)
     *   int add(Example, Example)
     *   void example()
     *
     *   # augmented
     *   Example some.other.Class sub(int)
     *
     *   # fields
     *   int value0
     *   int value1
     * }
     * }
     *
     * 
     */
    public static Whitelist loadFromResourceFiles(Map<Class<?>, List<String>> resourcesToFiles) {
        Map<String, Class<?>> namesToClasses = new HashMap<>();
        Set<String> pdynamics = new HashSet<>();

        for (Entry<Class<?>, List<String>> resourceToFiles : resourcesToFiles.entrySet()) {
            Class<?> resource = resourceToFiles.getKey();
            List<String> files = resourceToFiles.getValue();

            for (String file : files) {
                String line;
                int number = -1;

                try (LineNumberReader reader = new LineNumberReader(
                    new InputStreamReader(resource.getResourceAsStream(file), StandardCharsets.UTF_8))) {

                    while ((line = reader.readLine()) != null) {
                        number = reader.getLineNumber();
                        line = line.trim();

                        if (line.length() == 0 || line.charAt(0) == '#') {
                            continue;
                        }

                        if (line.startsWith("dynamic ")) {
                            String[] elements = line.split("\\s+");

                            if (elements.length != 2) {
                                throw new IllegalArgumentException("invalid dynamic definition: unexpected format [" + line + "]");
                            }

                            if (namesToClasses.containsKey(elements[1])) {
                                throw new IllegalArgumentException(
                                    "invalid dynamic definition: name [" + elements[1] + "] already defined as a struct");
                            }

                            pdynamics.add(elements[1]);
                        } else if (line.startsWith("class ")) {
                            if (line.endsWith("{") == false) {
                                throw new IllegalArgumentException(
                                    "invalid struct definition: failed to parse class opening bracket [" + line + "]");
                            }

                            int index = line.indexOf(" extends ");
                            String[] elements =
                                line.substring(5, index == -1 ? line.length() - 1 : index).replaceAll("\\s+", "").split("->");

                            if (elements.length < 1 || elements.length > 2) {
                                throw new IllegalArgumentException("invalid struct definition: failed to parse class name [" + line + "]");
                            }

                            String pname = elements[0];
                            String jname = elements.length == 2 ? elements[1] : pname;
                            Class<?> jclass;

                            if ("void".equals(jname)) {
                                jclass = void.class;
                            } else if ("boolean".equals(jname)) {
                                jclass = boolean.class;
                            } else if ("byte".equals(jname)) {
                                jclass = byte.class;
                            } else if ("short".equals(jname)) {
                                jclass = short.class;
                            } else if ("char".equals(jname)) {
                                jclass = char.class;
                            } else if ("int".equals(jname)) {
                                jclass = int.class;
                            } else if ("long".equals(jname)) {
                                jclass = long.class;
                            } else if ("float".equals(jname)) {
                                jclass = float.class;
                            } else if ("double".equals(jname)) {
                                jclass = double.class;
                            } else {
                                jclass = Class.forName(jname, true, resource.getClassLoader());
                            }

                            if (pdynamics.contains(pname)) {
                                throw new IllegalArgumentException(
                                    "invalid struct definition: name [" + elements[1] + "] already defined as a dynamic");
                            }

                            Class<?> jduplicate = namesToClasses.get(pname);

                            if (jduplicate != null && jduplicate.equals(jclass) == false) {
                                throw new IllegalArgumentException("invalid struct definition: name [" + pname + "]" +
                                    " has been defined to be at least two different classes [" + jduplicate + "] and [" + jclass + "]");
                            }

                            namesToClasses.put(pname, jclass);
                        }
                    }
                } catch (Exception exception) {
                    throw new RuntimeException("error in [" + file + "] at line [" + number + "]", exception);
                }
            }
        }

        List<WStruct> wstructs = new ArrayList<>();

        for (Entry<Class<?>, List<String>> resourceToFiles : resourcesToFiles.entrySet()) {
            Class<?> resource = resourceToFiles.getKey();
            List<String> files = resourceToFiles.getValue();

            Function<String, Class<?>> getClassFromName = pname -> {
                int dimensions = 0;
                int index = pname.indexOf('[');
                String pnonarray = pname;

                if (index != -1) {
                    int length = pname.length();

                    while (index < length) {
                        if (pname.charAt(index) == '[' && ++index < length && pname.charAt(index++) == ']') {
                            ++dimensions;
                        } else {
                            throw new IllegalArgumentException("invalid struct/dynamic name [" + pname + "]");
                        }
                    }

                    pnonarray = pname.substring(0, pname.length() - dimensions*2);
                }

                Class<?> clazz = pdynamics.contains(pnonarray) ? Object.class : namesToClasses.get(pnonarray);

                if (clazz == null) {
                    throw new IllegalArgumentException("invalid struct/dynamic name [" + pname + "]");
                }

                if (dimensions > 0) {
                    pnonarray = clazz.getName();

                    if ("boolean".equals(pnonarray)) {
                        pnonarray = "Z";
                    } else if ("byte".equals(pnonarray)) {
                        pnonarray = "B";
                    } else if ("short".equals(pnonarray)) {
                        pnonarray = "S";
                    } else if ("char".equals(pnonarray)) {
                        pnonarray = "C";
                    } else if ("int".equals(pnonarray)) {
                        pnonarray = "I";
                    } else if ("long".equals(pnonarray)) {
                        pnonarray = "J";
                    } else if ("float".equals(pnonarray)) {
                        pnonarray = "F";
                    } else if ("double".equals(pnonarray)) {
                        pnonarray = "D";
                    } else if ("void".equals(pnonarray)) {
                        pnonarray = "V";
                    } else {
                        pnonarray = "L" + pnonarray + ";";
                    }

                    StringBuilder jarray = new StringBuilder();

                    for (int dimension = 0; dimension < dimensions; ++dimension) {
                        jarray.append('[');
                    }

                    jarray.append(pnonarray);

                    try {
                        clazz = Class.forName(jarray.toString(), true, resource.getClassLoader());
                    } catch (ClassNotFoundException cnfe) {
                        throw new IllegalArgumentException("invalid struct/dynamic name [" + pname + "]", cnfe);
                    }
                }

                return clazz;
            };

            for (String file : files) {
                String line;
                int number = -1;

                try (LineNumberReader reader = new LineNumberReader(
                    new InputStreamReader(resource.getResourceAsStream(file), StandardCharsets.UTF_8))) {

                    String pname = null;
                    Class<?> jclass = null;
                    List<String> wsupers = null;
                    List<WConstructor> wconstructors = null;
                    List<WMethod> wmethods = null;
                    List<WField> wfields = null;

                    while ((line = reader.readLine()) != null) {
                        number = reader.getLineNumber();
                        line = line.trim();

                        if (line.length() == 0 || line.charAt(0) == '#' || line.startsWith("dynamic ")) {
                            continue;
                        }

                        if (line.startsWith("class ")) {
                            int index = line.indexOf(" extends ");
                            String[] elements =
                                line.substring(5, index == -1 ? line.length() - 1 : index).replaceAll("\\s+", "").split("->");

                            pname = elements[0];
                            jclass = namesToClasses.get(pname);
                            wsupers = Collections.emptyList();
                            wconstructors = new ArrayList<>();
                            wmethods = new ArrayList<>();
                            wfields = new ArrayList<>();

                            if (index != -1) {
                                elements = line.substring(index + 9, line.length() - 1).replaceAll("\\s+", "").split(",");
                                wsupers = Arrays.asList(elements);
                            }
                        } else if (line.equals("}")) {
                            if (pname == null) {
                                throw new IllegalArgumentException("invalid struct definition: extraneous closing bracket");
                            }

                            wstructs.add(new WStruct(pname, jclass, wsupers, wconstructors, wmethods, wfields));

                            pname = null;
                            jclass = null;
                            wsupers = null;
                            wconstructors = null;
                            wmethods = null;
                            wfields = null;
                        } else {
                            if (pname == null) {
                                throw new IllegalArgumentException("invalid object definition: expected a class name [" + line + "]");
                            }

                            if (line.startsWith("(")) {
                                if (line.endsWith(")") == false) {
                                    throw new IllegalArgumentException(
                                        "invalid constructor definition: expected a closing parenthesis [" + line + "]");
                                }

                                String[] elements = line.substring(1, line.length() - 1).replaceAll("\\s+", "").split(",");

                                if ("".equals(elements[0])) {
                                    elements = new String[0];
                                }

                                Class<?>[] jparameters = new Class<?>[elements.length];

                                for (int parameter = 0; parameter < jparameters.length; ++parameter) {
                                    try {
                                        jparameters[parameter] = getClassFromName.apply(elements[parameter]);
                                    } catch (IllegalArgumentException iae) {
                                        throw new IllegalArgumentException(
                                            "invalid constructor definition: invalid parameter [" + elements[parameter] + "]", iae);
                                    }
                                }

                                Constructor<?> jconstructor;

                                try {
                                    jconstructor = jclass.getConstructor(jparameters);
                                } catch (NoSuchMethodException nsme) {
                                    throw new IllegalArgumentException(
                                        "invalid constructor definition: failed to look up constructor [" + line + "]", nsme);
                                }

                                wconstructors.add(new WConstructor(jconstructor, Arrays.asList(elements)));
                            } else if (line.contains("(")) {
                                if (line.endsWith(")") == false) {
                                    throw new IllegalArgumentException(
                                        "invalid method definition: expected a closing parenthesis [" + line + "]");
                                }

                                int index = line.indexOf('(');
                                String[] elements = line.substring(0, index).split("\\s+");
                                String methodname;
                                Class<?> augmented;

                                if (elements.length == 2) {
                                    methodname = elements[1];
                                    augmented = null;
                                } else if (elements.length == 3) {
                                    methodname = elements[2];

                                    try {
                                        augmented = Class.forName(elements[1], true, resource.getClassLoader());
                                    } catch (ClassNotFoundException cnfe) {
                                        throw new IllegalArgumentException(
                                            "invalid method definition: augmented class [" + elements[1] + "] does not exist", cnfe);
                                    }
                                } else {
                                    throw new IllegalArgumentException("invalid method definition: unexpected format [" + line + "]");
                                }

                                String preturn = elements[0];

                                try {
                                    getClassFromName.apply(preturn);
                                } catch (IllegalArgumentException iae) {
                                    throw new IllegalArgumentException("invalid method definition: invalid return [" + preturn + "]", iae);
                                }

                                elements = line.substring(index + 1, line.length() - 1).replaceAll("\\s+", "").split(",");
                                Class<?>[] jparameters;

                                if ("".equals(elements[0])) {
                                    elements = new String[0];
                                }

                                if (augmented == null) {
                                    jparameters = new Class<?>[elements.length];

                                    for (int parameter = 0; parameter < jparameters.length; ++parameter) {
                                        try {
                                            jparameters[parameter] = getClassFromName.apply(elements[parameter]);
                                        } catch (IllegalArgumentException iae) {
                                            throw new IllegalArgumentException(
                                                "invalid method definition: invalid parameter [" + elements[parameter] + "]", iae);
                                        }
                                    }
                                } else {
                                    jparameters = new Class<?>[1 + elements.length];
                                    jparameters[0] = jclass;

                                    for (int parameter = 1; parameter < jparameters.length; ++parameter) {
                                        try {
                                            jparameters[parameter] = getClassFromName.apply(elements[parameter - 1]);
                                        } catch (IllegalArgumentException iae) {
                                            throw new IllegalArgumentException(
                                                "invalid method definition: invalid parameter [" + elements[parameter - 1] + "]", iae);
                                        }
                                    }
                                }

                                Method jmethod;

                                try {
                                    jmethod = (augmented == null ? jclass : augmented).getMethod(methodname, jparameters);
                                } catch (NoSuchMethodException nsme) {
                                    throw new IllegalArgumentException(
                                        "invalid method definition: failed to look up method [" + line + "]", nsme);
                                }

                                wmethods.add(new WMethod(jmethod, augmented, preturn, Arrays.asList(elements)));
                            } else {
                                String[] elements = line.split("\\s+");

                                if (elements.length != 2) {
                                    throw new IllegalArgumentException("invalid field definition: unexpected format [" + line + "]");
                                }

                                try {
                                    getClassFromName.apply(elements[0]);
                                } catch (IllegalArgumentException iae) {
                                    throw new IllegalArgumentException("invalid field definition: invalid type [" + elements[0] + "]", iae);
                                }

                                Field jfield;

                                try {
                                    jfield = jclass.getField(elements[1]);
                                } catch (NoSuchFieldException nsfe) {
                                    throw new IllegalArgumentException(
                                        "invalid field definition: field [" + elements[0] + "] does not exist", nsfe);
                                }

                                wfields.add(new WField(jfield, elements[0]));
                            }
                        }
                    }

                    if (pname != null) {
                        throw new IllegalArgumentException("invalid struct definition: expected closing bracket");
                    }
                } catch (Exception exception) {
                    throw new RuntimeException("error in [" + file + "] at line [" + number + "]", exception);
                }
            }
        }

        return new Whitelist(pdynamics, wstructs);
    }

    public final Set<String> pdynamics;
    public final List<WStruct> wstructs;

    private Whitelist(Set<String> pdynamics, List<WStruct> wstructs) {
        this.pdynamics = Collections.unmodifiableSet(Objects.requireNonNull(pdynamics));
        this.wstructs = Collections.unmodifiableList(Objects.requireNonNull(wstructs));

        validate();
    }

    private void validate() {

    }
}
