/*
 * Licensed to Elasticsearch under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.elasticsearch.painless;

import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;

/**
 * Whitelist contains data structures and methods designed to either load or generate a white-list of
 * Java classes, methods, and fields that can be used within a Painless script.  Whitelist is used directly
 * to create a new {@link Definition} and is passed into {@link Definition#Definition(Whitelist)}.
 * {@link Definition}'s are then used as part of each Painless script at both compile-time and
 * run-time to determine what a script is allowed to execute.
 *
 * Several single letters are used as prefixes for many variables in this class.  They mean the following:
 * p - Used as part of the Painless typing system
 * j - Used as part of the Java typing system
 * w = Used as part of the Whitelist typing system
 *
 * A Whitelist consists of two pieces.  The first is a list {@link Whitelist#pDynamicTypeNames} of {@link String}s
 * that represent the allowed name(s) of dynamic types in Painless.  The second is a list of {@link WStruct}s
 * that represent the equivalent of a Java class in Painless known as a struct.  These will be the types
 * available for use in Painless scripts compiled using a {@link Definition} generated by this Whitelist.
 */
public final class Whitelist {

    /**
     * WStruct represents the equivalent of a Java class in Painless complete with super classes,
     * constructors, methods, and fields.  In Painless a class is known as a struct primarily to avoid
     * naming conflicts internally.
     *
     * Structs in Painless allow for arity overloading for constructors and methods.  Arity overloading
     * means that multiple constructors are allowed for a single struct as long as they have a different
     * number of parameter types, and multiples methods with the same name are allowed for a single struct
     * as long as they have the same return type and a different number of parameter types.
     *
     * Structs are allowed to extend other structs, known as a super struct, in which they will have
     * available all of the methods and fields from a super struct.
     */
    static class WStruct {

        /** The Painless name of this struct which will also be the name of a type in a Painless script.  */
        final String pTypeName;

        /** The Java class this struct represents. */
        final Class<?> jClass;

        /** The {@link List} of Painless structs, as names, this struct extends. */
        final List<String> pSuperTypeNames;

        /** The {@link List} of white-listed constructors ({@link WConstructor}s) available to this struct. */
        final List<WConstructor> wConstructors;

        /** The {@link List} of white-listed methods ({@link WMethod}s) available to this struct. */
        final List<WMethod> wMethods;

        /** The {@link List} of white-listed fields ({@link WField}s) available to this struct. */
        final List<WField> wFields;

        /** Standard constructor. All values must be not {@code null}. */
        private WStruct(String pTypeName, Class<?> jClass, List<String> pSuperTypeNames,
                       List<WConstructor> wConstructors, List<WMethod> wMethods, List<WField> wFields) {
            this.pTypeName = Objects.requireNonNull(pTypeName);
            this.jClass = Objects.requireNonNull(jClass);
            this.pSuperTypeNames = Collections.unmodifiableList(Objects.requireNonNull(pSuperTypeNames));

            this.wConstructors = Collections.unmodifiableList(Objects.requireNonNull(wConstructors));
            this.wMethods = Collections.unmodifiableList(Objects.requireNonNull(wMethods));
            this.wFields = Collections.unmodifiableList(Objects.requireNonNull(wFields));
        }
    }

    /**
     * WConstructor represents the equivalent of a Java constructor available as a white-listed struct
     * constructor within Painless.  Constructors for Painless structs may be accessed exactly as
     * constructors for Java classes are using the 'new' keyword.  Painless structs may have multiple
     * constructors as long as they comply with arity overloading described for {@link WStruct}.
     */
    static class WConstructor {

        /** The Java reflection {@link Constructor} available as a Painless struct constructor. */
        final Constructor<?> jConstructor;

        /** The {@link List} of this constructor's parameter types as Painless struct names. */
        final List<String> pParameterTypeNames;

        /** Standard constructor. All values must be not {@code null}. */
        private WConstructor(Constructor<?> jConstructor, List<String> pParameterTypeNames) {
            this.jConstructor = Objects.requireNonNull(jConstructor);
            this.pParameterTypeNames = Collections.unmodifiableList(Objects.requireNonNull(pParameterTypeNames));
        }
    }

    /**
     * WMethod represents the equivalent of a Java method available as a white-listed struct method
     * within Painless.  Methods for Painless structs may be accessed exactly as methods for Java classes
     * are using the '.' operator on an existing struct variable/field.  Painless structs may have multiple
     * methods with the same name as long as they comply with arity overloading described for {@link WMethod}.
     *
     * Structs may also have additional methods that are not part of the Java class the struct represents -
     * these are known as augmented methods.  An augmented method can be added to a struct as a part of any
     * Java class as long as the method is static and the first parameter of the method is the Java class
     * represented by the struct.  Note that the augmented method's parent Java class does not need to be
     * white-listed.
     */
    static class WMethod {

        /** The Java reflection {@link Method} available as a Painless struct method. */
        final Method jMethod;

        /** The Java {@link Class} owner for an augmented method.  If the method is not augmented this should be {@code null}. */
        final Class<?> jAugmentedClass;

        /** The return type as a Painless struct name. */
        final String pReturnTypeName;

        /** The {@link List} of this constructor's parameter types as Painless struct names. */
        final List<String> pParameterTypeNames;

        /**
         * Standard constructor. All values must be not {@code null} with the exception of jAugmentedClass;
         * jAugmentedClass will be {@code null} unless the method is augmented as described in the class documentation.
         */
        private WMethod(Method jMethod, Class<?> jAugmentedClass, String pReturnTypeName, List<String> pParameterTypeNames) {
            this.jMethod = Objects.requireNonNull(jMethod);
            this.jAugmentedClass = jAugmentedClass;
            this.pReturnTypeName = Objects.requireNonNull(pReturnTypeName);
            this.pParameterTypeNames = Collections.unmodifiableList(Objects.requireNonNull(pParameterTypeNames));
        }
    }

    /**
     * WField represents the equivalent of a Java field available as a white-listed struct field
     * within Painless.  Fields for Painless structs may be accessed exactly as fields for Java classes
     * are using the '.' operator on an existing struct variable/field.
     */
    static class WField {

        /** The Java reflection {@link Field} available as a Painless struct field. */
        final Field jField;

        /** The field type as a Painless struct name. */
        final String pTypeName;

        /** Standard constructor. All values must be not {@code null}. */
        private WField(Field jField, String pTypeName) {
            this.jField = Objects.requireNonNull(jField);
            this.pTypeName = Objects.requireNonNull(pTypeName);
        }
    }

    /**
     * Loads and creates a {@link Whitelist} from one to many text files.  The file paths are passed in as a
     * {@link Map} with keys of {@link Class} and values of {@link List}s of {@link String}s where each {@link String}
     * is the path of a single text file.  The key {@link Class} for each {@link List} of file paths will be
     * used to load each file path in the {@link List} as a resource and then the key {@link Class}'s
     * {@link ClassLoader} will be used to lookup the Java reflection objects for each individual {@link Class},
     * {@link Constructor}, {@link Method}, and {@link Field} specified as part of the white-list in the text file.
     *
     * Two passes are made through each specified text file.  The first pass will load both the dynamic Painless
     * type names and static Painless type names that can then be used during a second pass as a lookup for Painless
     * constructor/method/field return and parameter type names.  The second pass will load each individual
     * constructor, method, and field that will be white-listed for use in Painless scripts.
     *
     * The following can be parsed:
     * - Blank lines will be ignored by the parser.
     * - Comments may be created starting with a pound '#; symbol and end with a newline.  These will
     *   be ignored by the parser.
     * - Dynamic types may be specified starting with 'dynamic' and followed by a single Painless type
     *   name and a newline.
     * - Primitive types may be specified starting with 'class' and followed by the Painless type
     *   name (often the same as the Java type name), an arrow symbol, the Java type name,
     *   an opening bracket, a newline, a closing bracket, and a final newline.
     * - Complex types may be specified starting with 'class' and followed by the Painless type name,
     *   an arrow symbol, the Java class name, a opening bracket, a newline, constructor/method/field
     *   specifications, a closing bracket, and a final newline. Within a complex type the following
     *   may be parsed:
     *   -- A constructor may be specified starting with an opening parenthesis, followed by a
     *      comma-delimited list of Painless type names corresponding to the type/class names for
     *      the equivalent Java parameter types (these must be white-listed as well), a closing
     *      parenthesis, and a newline.
     *   -- A method may be specified starting with a Painless type name for the return type,
     *      followed by the Java name of the method (which will also be the Painless name for the
     *      method), an opening parenthesis, a comma-delimited list of Painless type names
     *      corresponding to the type/class names for the equivalent Java parameter types
     *      (these must be white-listed as well), a closing parenthesis, and a newline.
     *   -- An augmented method may be specified starting with a Painless type name for the return
     *      type, followed by the fully qualified Java name of the class the augmented method is
     *      part of (this class does not need to be white-listed), the Java name of the method
     *      (which will also be the Painless name for the method), an opening parenthesis, a
     *      comma-delimited list of Painless type names corresponding to the type/class names
     *      for the equivalent Java parameter types (these must be white-listed as well), a closing
     *      parenthesis, and a newline.
     *   -- A field may be specified starting with a Painless type name for the equivalent Java type
     *      of the field, followed by the Java name of the field (which all be the Painless name
     *      for the field), and a newline.
     *
     * Note there must be a one-to-one correspondence of Painless type names to Java type/class names.
     * If the same Painless type is defined across multiple files and the Java class is the same, all
     * specified constructors, methods, and fields will be merged into a single Painless type.  Dynamic
     * types will always be equivalent to an {@link Object} as a base, but resolution of method calls
     * and field access will be determined at run-time.
     *
     * The following example is used to create a single white-list text file:
     *
     * {@code
     * # dynamic types
     *
     * dynamic def
     *
     * # primitive types
     *
     * class int -> int {
     * }
     *
     * # complex types
     *
     * class Example -> my.package.Example {
     *   # constructors
     *   ()
     *   (int)
     *   (Example)
     *
     *   # method
     *   Example add(int)
     *   int add(Example, Example)
     *   void example()
     *
     *   # augmented
     *   Example some.other.Class sub(int)
     *
     *   # fields
     *   int value0
     *   int value1
     * }
     * }
     */
    public static Whitelist loadFromResourceFiles(Map<Class<?>, List<String>> resourcesToFiles) {
        Set<String> pDynamicTypeNames = new HashSet<>();
        Map<String, Class<?>> pTypeNamesToJClasses = new HashMap<>();

        // Execute a first-pass through the white-list text files.  This will gather
        // all the Painless dynamic type names and create a map of Painless type names
        // to their corresponding Java types/classes for later use during lookup of
        // return and parameter types for constructors, fields, and methods.
        for (Entry<Class<?>, List<String>> resourceToFiles : resourcesToFiles.entrySet()) {
            Class<?> resource = resourceToFiles.getKey();
            List<String> filepaths = resourceToFiles.getValue();

            for (String filepath : filepaths) {
                String line;
                int number = -1;

                try (LineNumberReader reader = new LineNumberReader(
                    new InputStreamReader(resource.getResourceAsStream(filepath), StandardCharsets.UTF_8))) {

                    while ((line = reader.readLine()) != null) {
                        number = reader.getLineNumber();
                        line = line.trim();

                        // Skip any lines that are either blank or comments.
                        if (line.length() == 0 || line.charAt(0) == '#') {
                            continue;
                        }

                        // Handle the case where Painless dynamic type names are listed.
                        // Expects the following format: 'dynamic' ID '\n'
                        if (line.startsWith("dynamic ")) {
                            // Parse based on the expected format.
                            String[] tokens = line.split("\\s+");

                            // Ensure the correct number of tokens.
                            if (tokens.length != 2) {
                                throw new IllegalArgumentException("invalid dynamic definition: unexpected format [" + line + "]");
                            }

                            String pDynamicTypeName = tokens[1];

                            // Ensure a non-dynamic type name hasn't already been defined with the same type name.
                            if (pTypeNamesToJClasses.containsKey(pDynamicTypeName)) {
                                throw new IllegalArgumentException(
                                    "invalid dynamic definition: name [" + pDynamicTypeName + "] already defined as a struct");
                            }

                            pDynamicTypeNames.add(pDynamicTypeName);

                        // Handle the case where Painless primitive/complex type names are listed.
                        // Expects the following format: 'class' ID -> ID ( 'extends' ID ( ',' ID )* )? '{'
                        } else if (line.startsWith("class ")) {
                            // Ensure the final token of the line is '{'.
                            if (line.endsWith("{") == false) {
                                throw new IllegalArgumentException(
                                    "invalid struct definition: failed to parse class opening bracket [" + line + "]");
                            }

                            // Parse based on the expected format prior to the 'extends' token.
                            int extendsIndex = line.indexOf(" extends ");
                            String[] tokens =
                                line.substring(5, extendsIndex == -1 ? line.length() - 1 : extendsIndex).replaceAll("\\s+", "").split("->");

                            // Ensure the correct number of tokens.
                            if (tokens.length < 1 || tokens.length > 2) {
                                throw new IllegalArgumentException("invalid struct definition: failed to parse class name [" + line + "]");
                            }

                            String pTypeName = tokens[0];
                            String jTypeName = tokens.length == 2 ? tokens[1] : pTypeName;
                            Class<?> jClass;


                            if ("void".equals(jTypeName)) {
                                jClass = void.class;
                            } else if ("boolean".equals(jTypeName)) {
                                jClass = boolean.class;
                            } else if ("byte".equals(jTypeName)) {
                                jClass = byte.class;
                            } else if ("short".equals(jTypeName)) {
                                jClass = short.class;
                            } else if ("char".equals(jTypeName)) {
                                jClass = char.class;
                            } else if ("int".equals(jTypeName)) {
                                jClass = int.class;
                            } else if ("long".equals(jTypeName)) {
                                jClass = long.class;
                            } else if ("float".equals(jTypeName)) {
                                jClass = float.class;
                            } else if ("double".equals(jTypeName)) {
                                jClass = double.class;
                            } else {
                                jClass = Class.forName(jTypeName, true, resource.getClassLoader());
                            }

                            if (pDynamicTypeNames.contains(pTypeName)) {
                                throw new IllegalArgumentException(
                                    "invalid struct definition: name [" + elements[1] + "] already defined as a dynamic");
                            }

                            Class<?> jduplicate = pTypeNamesToJClasses.get(pTypeName);

                            if (jduplicate != null && jduplicate.equals(jClass) == false) {
                                throw new IllegalArgumentException("invalid struct definition: name [" + pTypeName + "]" +
                                    " has been defined to be at least two different classes [" + jduplicate + "] and [" + jClass + "]");
                            }

                            pTypeNamesToJClasses.put(pTypeName, jClass);
                        }
                    }
                } catch (Exception exception) {
                    throw new RuntimeException("error in [" + file + "] at line [" + number + "]", exception);
                }
            }
        }

        Map<String, WStruct> wstructs = new HashMap<>();

        for (Entry<Class<?>, List<String>> resourceToFiles : resourcesToFiles.entrySet()) {
            Class<?> resource = resourceToFiles.getKey();
            List<String> files = resourceToFiles.getValue();

            Function<String, Class<?>> getClassFromName = pname -> {
                int dimensions = 0;
                int index = pname.indexOf('[');
                String pnonarray = pname;

                if (index != -1) {
                    int length = pname.length();

                    while (index < length) {
                        if (pname.charAt(index) == '[' && ++index < length && pname.charAt(index++) == ']') {
                            ++dimensions;
                        } else {
                            throw new IllegalArgumentException("invalid struct/dynamic name [" + pname + "]");
                        }
                    }

                    pnonarray = pname.substring(0, pname.length() - dimensions*2);
                }

                Class<?> clazz = pDynamicTypeNames.contains(pnonarray) ? Object.class : pTypeNamesToJClasses.get(pnonarray);

                if (clazz == null) {
                    throw new IllegalArgumentException("invalid struct/dynamic name [" + pname + "]");
                }

                if (dimensions > 0) {
                    pnonarray = clazz.getName();

                    if ("boolean".equals(pnonarray)) {
                        pnonarray = "Z";
                    } else if ("byte".equals(pnonarray)) {
                        pnonarray = "B";
                    } else if ("short".equals(pnonarray)) {
                        pnonarray = "S";
                    } else if ("char".equals(pnonarray)) {
                        pnonarray = "C";
                    } else if ("int".equals(pnonarray)) {
                        pnonarray = "I";
                    } else if ("long".equals(pnonarray)) {
                        pnonarray = "J";
                    } else if ("float".equals(pnonarray)) {
                        pnonarray = "F";
                    } else if ("double".equals(pnonarray)) {
                        pnonarray = "D";
                    } else if ("void".equals(pnonarray)) {
                        pnonarray = "V";
                    } else {
                        pnonarray = "L" + pnonarray + ";";
                    }

                    StringBuilder jarray = new StringBuilder();

                    for (int dimension = 0; dimension < dimensions; ++dimension) {
                        jarray.append('[');
                    }

                    jarray.append(pnonarray);

                    try {
                        clazz = Class.forName(jarray.toString(), true, resource.getClassLoader());
                    } catch (ClassNotFoundException cnfe) {
                        throw new IllegalArgumentException("invalid struct/dynamic name [" + pname + "]", cnfe);
                    }
                }

                return clazz;
            };

            for (String file : files) {
                String line;
                int number = -1;

                try (LineNumberReader reader = new LineNumberReader(
                    new InputStreamReader(resource.getResourceAsStream(file), StandardCharsets.UTF_8))) {

                    String pname = null;
                    Class<?> jclass = null;
                    List<String> wsupers = null;
                    List<WConstructor> wconstructors = null;
                    List<WMethod> wmethods = null;
                    List<WField> wfields = null;

                    while ((line = reader.readLine()) != null) {
                        number = reader.getLineNumber();
                        line = line.trim();

                        if (line.length() == 0 || line.charAt(0) == '#' || line.startsWith("dynamic ")) {
                            continue;
                        }

                        if (line.startsWith("class ")) {
                            int index = line.indexOf(" extends ");
                            String[] elements =
                                line.substring(5, index == -1 ? line.length() - 1 : index).replaceAll("\\s+", "").split("->");

                            pname = elements[0];
                            jclass = pTypeNamesToJClasses.get(pname);
                            wsupers = Collections.emptyList();
                            wconstructors = new ArrayList<>();
                            wmethods = new ArrayList<>();
                            wfields = new ArrayList<>();

                            if (index != -1) {
                                elements = line.substring(index + 9, line.length() - 1).replaceAll("\\s+", "").split(",");
                                wsupers = Arrays.asList(elements);
                            }
                        } else if (line.equals("}")) {
                            if (pname == null) {
                                throw new IllegalArgumentException("invalid struct definition: extraneous closing bracket");
                            }

                            WStruct wStruct = wstructs.get(pname);

                            if (wStruct != null) {
                                if (wsupers.equals(wStruct.pSuperTypeNames) == false) {
                                    throw new IllegalArgumentException("invalid struct definition: when attempting to merge " +
                                        "type [" + pname + "] from multiple files, super types do not match");
                                }

                                wconstructors.addAll(wStruct.wConstructors);
                                wmethods.addAll(wStruct.wMethods);
                                wfields.addAll(wStruct.wFields);
                            }

                            wstructs.put(pname, new WStruct(pname, jclass, wsupers, wconstructors, wmethods, wfields));

                            pname = null;
                            jclass = null;
                            wsupers = null;
                            wconstructors = null;
                            wmethods = null;
                            wfields = null;
                        } else {
                            if (pname == null) {
                                throw new IllegalArgumentException("invalid object definition: expected a class name [" + line + "]");
                            }

                            if (line.startsWith("(")) {
                                if (line.endsWith(")") == false) {
                                    throw new IllegalArgumentException(
                                        "invalid constructor definition: expected a closing parenthesis [" + line + "]");
                                }

                                String[] elements = line.substring(1, line.length() - 1).replaceAll("\\s+", "").split(",");

                                if ("".equals(elements[0])) {
                                    elements = new String[0];
                                }

                                Class<?>[] jparameters = new Class<?>[elements.length];

                                for (int parameter = 0; parameter < jparameters.length; ++parameter) {
                                    try {
                                        jparameters[parameter] = getClassFromName.apply(elements[parameter]);
                                    } catch (IllegalArgumentException iae) {
                                        throw new IllegalArgumentException(
                                            "invalid constructor definition: invalid parameter [" + elements[parameter] + "]", iae);
                                    }
                                }

                                Constructor<?> jconstructor;

                                try {
                                    jconstructor = jclass.getConstructor(jparameters);
                                } catch (NoSuchMethodException nsme) {
                                    throw new IllegalArgumentException(
                                        "invalid constructor definition: failed to look up constructor [" + line + "]", nsme);
                                }

                                wconstructors.add(new WConstructor(jconstructor, Arrays.asList(elements)));
                            } else if (line.contains("(")) {
                                if (line.endsWith(")") == false) {
                                    throw new IllegalArgumentException(
                                        "invalid method definition: expected a closing parenthesis [" + line + "]");
                                }

                                int index = line.indexOf('(');
                                String[] elements = line.substring(0, index).split("\\s+");
                                String methodname;
                                Class<?> augmented;

                                if (elements.length == 2) {
                                    methodname = elements[1];
                                    augmented = null;
                                } else if (elements.length == 3) {
                                    methodname = elements[2];

                                    try {
                                        augmented = Class.forName(elements[1], true, resource.getClassLoader());
                                    } catch (ClassNotFoundException cnfe) {
                                        throw new IllegalArgumentException(
                                            "invalid method definition: augmented class [" + elements[1] + "] does not exist", cnfe);
                                    }
                                } else {
                                    throw new IllegalArgumentException("invalid method definition: unexpected format [" + line + "]");
                                }

                                String preturn = elements[0];

                                try {
                                    getClassFromName.apply(preturn);
                                } catch (IllegalArgumentException iae) {
                                    throw new IllegalArgumentException("invalid method definition: invalid return [" + preturn + "]", iae);
                                }

                                elements = line.substring(index + 1, line.length() - 1).replaceAll("\\s+", "").split(",");
                                Class<?>[] jparameters;

                                if ("".equals(elements[0])) {
                                    elements = new String[0];
                                }

                                if (augmented == null) {
                                    jparameters = new Class<?>[elements.length];

                                    for (int parameter = 0; parameter < jparameters.length; ++parameter) {
                                        try {
                                            jparameters[parameter] = getClassFromName.apply(elements[parameter]);
                                        } catch (IllegalArgumentException iae) {
                                            throw new IllegalArgumentException(
                                                "invalid method definition: invalid parameter [" + elements[parameter] + "]", iae);
                                        }
                                    }
                                } else {
                                    jparameters = new Class<?>[1 + elements.length];
                                    jparameters[0] = jclass;

                                    for (int parameter = 1; parameter < jparameters.length; ++parameter) {
                                        try {
                                            jparameters[parameter] = getClassFromName.apply(elements[parameter - 1]);
                                        } catch (IllegalArgumentException iae) {
                                            throw new IllegalArgumentException(
                                                "invalid method definition: invalid parameter [" + elements[parameter - 1] + "]", iae);
                                        }
                                    }
                                }

                                Method jmethod;

                                try {
                                    jmethod = (augmented == null ? jclass : augmented).getMethod(methodname, jparameters);
                                } catch (NoSuchMethodException nsme) {
                                    throw new IllegalArgumentException(
                                        "invalid method definition: failed to look up method [" + line + "]", nsme);
                                }

                                wmethods.add(new WMethod(jmethod, augmented, preturn, Arrays.asList(elements)));
                            } else {
                                String[] elements = line.split("\\s+");

                                if (elements.length != 2) {
                                    throw new IllegalArgumentException("invalid field definition: unexpected format [" + line + "]");
                                }

                                try {
                                    getClassFromName.apply(elements[0]);
                                } catch (IllegalArgumentException iae) {
                                    throw new IllegalArgumentException("invalid field definition: invalid type [" + elements[0] + "]", iae);
                                }

                                Field jfield;

                                try {
                                    jfield = jclass.getField(elements[1]);
                                } catch (NoSuchFieldException nsfe) {
                                    throw new IllegalArgumentException(
                                        "invalid field definition: field [" + elements[0] + "] does not exist", nsfe);
                                }

                                wfields.add(new WField(jfield, elements[0]));
                            }
                        }
                    }

                    if (pname != null) {
                        throw new IllegalArgumentException("invalid struct definition: expected closing bracket");
                    }
                } catch (Exception exception) {
                    throw new RuntimeException("error in [" + file + "] at line [" + number + "]", exception);
                }
            }
        }

        return new Whitelist(pDynamicTypeNames, wstructs.values());
    }

    final Set<String> pDynamicTypeNames;
    final Collection<WStruct> wStructs;

    private Whitelist(Set<String> pDynamicTypeNames, Collection<WStruct> wStructs) {
        this.pDynamicTypeNames = Collections.unmodifiableSet(Objects.requireNonNull(pDynamicTypeNames));
        this.wStructs = Collections.unmodifiableCollection(Objects.requireNonNull(wStructs));
    }
}
