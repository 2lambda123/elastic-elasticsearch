/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

import org.elasticsearch.gradle.internal.conventions.util.Util;
import org.yaml.snakeyaml.Yaml

// TODO move this file... what is a good location for it?
def mutedTestsFile = new File(Util.locateElasticsearchWorkspace(project.gradle), "muted-tests.yml")
def mutedTests = mutedTestsFile.exists() ? new Yaml().load(mutedTestsFile.text) : null

allprojects {
  applyTestSkipping(project, mutedTests)
}

def applyTestSkipping(project, mutedTests) {
  project.tasks.withType(Test) {
    testLogging {
      events "SKIPPED", "FAILED", "PASSED"
    }

    filter {
      def toSkip = []
      if (mutedTests) {
        mutedTests.tests.each { test ->
          if (test.method) {
            test.methods = [test.method]
          }

          if (test.methods instanceof String) {
            test.methods = [test.methods]
          }

          if (test.class && test.methods) {
            test.methods.each { method ->
              // Tests that use the randomized runner and parameters end up looking like this:
              // test {yaml=analysis-common/30_tokenizers/letter}
              // We need to detect this and handle them a little bit different than non-parameterized tests, because of some quirks in the randomized runner
              def index = method.indexOf(" {")
              def methodWithoutParams = index >= 0 ? method.substring(0, index) : method
              def paramString = index >= 0 ? method.substring(index) : null

              toSkip.add("${test.class}.${method}")

              if (paramString) {
                // Because of randomized runner quirks, we need skip the test method by itself whenever we want to skip a test that has parameters
                // This is because the runner has *two* separate checks that can cause the test to end up getting executed, so we need filters that cover both checks
                toSkip.add("${test.class}.${methodWithoutParams}")
              } else {
                // We need to add the following, in case we're skipping an entire class of parameterized tests
                toSkip.add("${test.class}.${method} *")
              }
            }
          }

          else if (test.class) {
            toSkip.add("${test.class}.*")
          }
        }
      }

      toSkip.each {
        excludeTestsMatching it
      }

      // TODO this should be true outside of CI?
      setFailOnNoMatchingTests(false)
    }
  }
}

