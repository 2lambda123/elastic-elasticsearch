/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

/*
 This qa module runs yaml and java against a local and a remote clusters connected via CCS.
 The local cluster is always on the current version, the remote cluster is tested for all wire-compatible versions
 that are also CCS compatible (i.e. all versions on the previous minor branch)
*/


import org.elasticsearch.gradle.Version
import org.elasticsearch.gradle.VersionProperties
import org.elasticsearch.gradle.internal.info.BuildParams
import org.elasticsearch.gradle.testclusters.StandaloneRestIntegTestTask

apply plugin: 'elasticsearch.internal-testclusters'
apply plugin: 'elasticsearch.standalone-rest-test'
apply plugin: 'elasticsearch.bwc-test'
apply plugin: 'elasticsearch.rest-resources'

dependencies {
  testImplementation project(xpackModule('esql:qa:testFixtures'))
  testImplementation project(xpackModule('esql:qa:server'))
}

restResources {
  restApi {
    include '_common', 'bulk', 'get', 'indices', 'esql', 'xpack', 'enrich', 'cluster'
  }
  restTests {
    includeXpack 'esql'
  }
}

def ccsSupportedVersion = bwcVersion -> {
  // CCQ is available on 8.13 or later
  if (bwcVersion.before(Version.fromString("8.13.0"))) {
    return false;
  }
  def currentVersion = Version.fromString(project.version)
  // in case the current version is the first in a new major series, all wire compatible versions (i.e. last minor of previous major)
  // are CCS compatible
  return currentVersion.minor == 0 || (currentVersion.major == bwcVersion.major && currentVersion.minor - bwcVersion.minor <= 1)
}

BuildParams.bwcVersions.withWireCompatible(ccsSupportedVersion) { bwcVersion, baseName ->

  def remoteCluster = testClusters.register("${baseName}-remote") {
    numberOfNodes = 2
    versions = [bwcVersion.toString()]
    setting 'node.roles', '[data,ingest,master]'
  }

  def localCluster = testClusters.register("${baseName}-local") {
    numberOfNodes = 2
    versions = [project.version]
    setting 'node.roles', '[data,ingest,master,remote_cluster_client]'
    setting 'cluster.remote.connections_per_cluster', '1'
    setting 'cluster.remote.my_remote_cluster.seeds',
      { "\"${remoteCluster.get().getAllTransportPortURI().get(0)}\"" }
  }

  tasks.register("${baseName}#remote-cluster", StandaloneRestIntegTestTask) {
    useCluster remoteCluster
    doFirst {
      nonInputProperties.systemProperty('tests.rest.suite', 'remote_cluster')
      nonInputProperties.systemProperty('tests.rest.cluster', remoteCluster.map(c -> c.allHttpSocketURI.join(",")))
    }
    dependsOn "processTestResources"
  }

  tasks.register("${baseName}#multi-cluster", StandaloneRestIntegTestTask) {
    useCluster localCluster
    useCluster remoteCluster
    doFirst {
      nonInputProperties.systemProperty('tests.rest.suite', 'multi_cluster')
      nonInputProperties.systemProperty('tests.rest.cluster', localCluster.map(c -> c.allHttpSocketURI.join(",")))
      nonInputProperties.systemProperty('tests.rest.remote_cluster', remoteCluster.map(c -> c.allHttpSocketURI.join(",")))
      nonInputProperties.systemProperty('tests.rest.remote_cluster_version', bwcVersion.toString())
    }
    dependsOn "${baseName}#remote-cluster"
  }

  tasks.register(bwcTaskName(bwcVersion)) {
    dependsOn "${baseName}#multi-cluster"
    mustRunAfter("precommit")
  }
}

testClusters.configureEach {
  testDistribution = 'DEFAULT'
  setting 'xpack.license.self_generated.type', 'trial'
  setting 'xpack.security.enabled', 'false'
}
