---
template:
  settings:
    # This is a made up setting which does not exist today. The idea is that
    # any field that shows up after the first 1000 fields is kept in source
    # but does not show up as runtime for index field
    #index.mapping.total_fields.soft_limit: 1000

    # Ignores any malformed data. Data will still be persisted in _source
    index.mapping.ignore_malformed": true

  mappings:

    # Any field that is discovered is mapped as a runtime field
    dynamic: runtime

    # DISCUSS: What are the pros / cons of having this enabled?
    date_detection: false

    ### All the properties which are set in each template
    properties:

      # This ensures all subobjects are flattened and prevents and object / keyword conflicts
      # As subobject is set to false, no objects like host, error or similar are mapped.
      subobject: false

      # @timestamp is the only field that MUST exist.
      "@timestamp":
        type: date
        ignore_malformed: false

      # The data stream properties are required in any index following the data stream naming scheme
      # Discuss: If there is an ecs: enabled flag it can also be used in indices so this would have to be skipped
      # These fields might not even be needed in this template
      data_stream.type:
        type: constant_keyword
        #value: logs
      data_stream.dataset:
        type: constant_keyword
      data_stream.namespace:
        type: constant_keyword


    # To ensure no empty mappings are in an index, everything except the properties above are mapped as dynamic templates
    # The dynamic mappings here are a best effort to map ECS core fields: https://github.com/elastic/ecs/blob/8.4/generated/csv/fields.csv
    # As most fields are keyword, these will be automatically be matched correctly. Only core fields were taken into account.
    # DISCUSS: Should @timestamp and data_stream.* also be moved under dynamic templates?
    dynamic_templates:

      ### Index mappings

      # Message field is always index
      - message:
          path_match: message
          mapping:
            type: match_only_text

      ### Runtime mappings

      # Matching all string fields by default to keyword
      # TODO: Does first / last match win in the list?
      - strings_as_keyword:
          match_mapping_type: string
          runtime:
            type: keyword
            # Do we need this for runtime?
            ignore_above: 1024

      # Matching all long fields
      # This matches the following fields: bytes, packets, port, duration, severity, pid
      # No path matching is needed as it is assumed these fields are already in the json doc a long
      # Elasticsearch would do this mapping automatically but it is specified here for documentation purpose
      # DISCUSS: If a field "7" as string comes in, will it still be mapped correctly?
      - long_as_long:
          match_mapping_type: long
          runtime:
            type: long

      # Matching all long and double fields
      # This matches the following fields: event.risk_score
      # No path matching is needed as it is assumed these fields are already in the json doc a float or double
      # Elasticsearch would do this mapping automatically but it is specified here for documentation purpose
      # DISCUSS: If a field "7.7" as string comes in, will it still be mapped correctly?
      - double_as_double:
          match_mapping_type: double
          runtime:
            type: double

      # Matching all boolean fields
      # This matches the following fields: exists
      # No path matching is needed as it is assumed these fields are already in the json doc as boolean
      # Elasticsearch would do this mapping automatically but it is specified here for documentation purpose
      # DISCUSS: If a field "true" as string comes in, will it still be mapped correctly?
      - strings_as_boolean:
          match_mapping_type: boolean
          runtime:
            type: boolean

      # Matching all string fields by default to keyword
      # TODO: Does first / last match win in the list?
      - strings_as_keyword:
          match_mapping_type: string
          runtime:
            type: keyword
            # Do we need this for runtime?
            ignore_above: 1024

      # Any message field except the top level one is matched as text but not indexed
      # TODO: Does this work? Which one has priority?
      - match_message:
          path_match: message
          runtime:
            type: match_only_text

      # Match all ip fields to ip
      - match_ip:
          match_mapping_type: string
          # DISCUSS: If match could be an array, these mappings could be written much more compact
          match: ip
          runtime:
            type: ip

      # Match all forwarded_ip fields to ip. This is for network.forwarded_ip
      - match_ip:
          match_mapping_type: string
          match: forwarded_ip
          runtime:
            type: ip

      # Match all labels fields. Flattened type instead of keyword is used to prevent too many fields to be created.
      # DISCUSS: Is this the right choice?
      - match_labels:
          match_mapping_type: string
          # TODO: Does this also match the top level labels?
          match: labels
          runtime:
            type: flattened

      # Match location fields to geopoint
      - match_location:
          # TODO: What is the correct matching type here?
          match_mapping_type: object
          match: location
          runtime:
            type: geo_point

      # Match location fields to geopoint
      - match_location:
          # TODO: What is the correct matching type here?
          match_mapping_type: string
          match: name
          runtime:
            # TODO: This is a field type that does not exist today. What ECS does is that for all name fields, it
            # has a subfield .text to also do text indexing
            type: text_keyword

      # Match strings fields to wildcard
      # This matches the following fields: strings
      # An example field is registry.data.strings
      - match_strings:
          # TODO: What is the correct matching type here?
          match_mapping_type: string
          match: strings
          runtime:
            type: wildcard

      # Match created fields to date
      # This matches the following fields: event.created
      - match_created:
          match_mapping_type: string
          match: created
          runtime:
            type: date

      # Match strings fields to wildcard
      # This matches the following fields: event.ingested
      - match_ingested:
          match_mapping_type: string
          match: ingested
          runtime:
            type: date

# Keyword fields to discuss if should be indexed or not. Proposed rule for discussion. Quorum needs to be reached
      # for a field to be indexed. Reason is going from runtime to index is easy, otherway around could be a breaking
      # It should also be discussed if logs-*, metrics-* and traces-* have exact same default.
      # change.
      # This is list is initially copied from https://github.com/elastic/elasticsearch/pull/88181/files#diff-0fba05a9236d9aa3866db886f0b6c24759be01a775023e1663b8f44f91951e62
      # - log.level
      # - log.logger
      # - trace.id
      # - span.id
      # - transaction.id
      # - service.name
      # - service.version
      # - service.environment
      # - process.id
      # - process.thread.name
      # - error.type
      # - error.message
      # - event.dataset
      # - cloud.provider
      # - cloud.availability_zone
      # - cloud.region
      # - cloud.provider
      # - host.hostname
      # - host.name
      # - container.id
      # - container.name
      # - orchestrator.namespace
      # - orchestrator.id
      # - orchestrator.resource.id
      # - orchestrator.resource.name



# Meta information blocks
_meta:
  description: Base mappings for indices and data streams using ECS
  managed: true

# TODO: What should the version here be? Put in brackets for now to make it valid yaml
version: "${xpack.stack.template.version}"
