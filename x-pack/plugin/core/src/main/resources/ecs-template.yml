---
# This template should serve as a foundation for indices and data streams using ECS.

template:

  settings:
    # This is a made up setting which does not exist today. The idea is that
    # any field that shows up after the first 1000 fields is kept in source
    # but does not show up as runtime for index field
    #index.mapping.total_fields.soft_limit: 1000

    # Ignores any malformed data. Data will still be persisted in _source
    index.mapping.ignore_malformed": true

  mappings:

    # Any field that is discovered is mapped as a runtime field
    dynamic: runtime

    # DISCUSS: What are the pros / cons of having this enabled?
    date_detection: false

    ### All the properties which are set in each template
    properties:

      # This ensures all subobjects are flattened and prevents and object / keyword conflicts
      # As subobject is set to false, no objects like host, error or similar are mapped.
      subobject: false

      # @timestamp is the only field that MUST exist.
      "@timestamp":
        type: date
        ignore_malformed: false

      # The data stream properties are required in any index following the data stream naming scheme
      # But not all data streams or indices which use ECS are part of the data stream naming scheme.
      # As an example logstash-* and *beats-*. Because of this, the data_stream.* fields are not part
      # of this template. It is expected that these are set by another template for the data stream
      # naming scheme.
      #data_stream.type:
      #  type: constant_keyword
      #  #value: logs
      #data_stream.dataset:
      #  type: constant_keyword
      #data_stream.namespace:
      #  type: constant_keyword


    # To ensure no empty mappings are in an index, everything except the properties above are mapped as dynamic templates
    # The dynamic mappings here are a best effort to map ECS core fields: https://github.com/elastic/ecs/blob/8.4/generated/csv/fields.csv
    # As most fields are keyword, these will be automatically be matched correctly. Only core fields were taken into account.
    # DISCUSS: Should @timestamp and data_stream.* also be moved under dynamic templates?
    dynamic_templates:

      ### Index mappings

      # Message field is always index
      - message:
          path_match: message
          mapping:
            type: match_only_text

      ### Runtime mappings

      # Matching all string fields by default to keyword
      # TODO: Does first / last match win in the list?
      - strings_as_keyword:
          match_mapping_type: string
          runtime:
            type: keyword
            # As it is a runtime field, ignore_above is not needed
            #ignore_above: 1024

      # Matching all ECS core long fields
      # This matches the following fields: bytes, packets, port, duration, severity, pid
      # Path matching on these fields is needed as otherwise if the first value of the field would be for example
      # "7" as a string in JSON, it would have the wrong default mapping. As it is a runtime field, the mapping could
      # still be adjusted but not something we should have the user do by default.
      # TODO: if path_match would be an array, this could be defined much nicer and more compact
      - bytes:
          path_match: bytes
          runtime:
            type: long
      - packets:
          path_match: packets
          runtime:
            type: long
      - port:
          path_match: port
          runtime:
            type: long
      - duration:
          path_match: duration
          runtime:
            type: long
      - severity:
          path_match: severity
          runtime:
            type: long
      - pid:
          path_match: pid
          runtime:
            type: long

      # Matching all float and double fields
      # This matches the following fields: event.risk_score
      # Why path_match is used, see discussion for long. For runtime fields, it does not matter if it is a float or a double
      - risk_score:
          match_path: risk_score
          runtime:
            type: double

      # Matching all boolean fields
      # This matches the following fields: exists
      # Why path_match is used, see discussion for long.
      - exists:
          match_path: exists
          runtime:
            type: boolean

      # Matching all string fields by default to keyword
      # TODO: Does first / last match win in the list?
      - strings_as_keyword:
          match_mapping_type: string
          runtime:
            type: keyword
            # Do we need this for runtime?
            ignore_above: 1024

      # Any message field except the top level one is matched as text but not indexed
      # TODO: Does this work? Which one has priority?
      - match_message:
          path_match: message
          runtime:
            type: match_only_text

      # Match all ip fields to ip
      # This matches the following fields: ip, network.forwarded_ip
      - ip:
          match: ip
          runtime:
            type: ip

      - forwarded_ip:
          match: forwarded_ip
          runtime:
            type: ip

      # Match all labels fields. Flattened type instead of keyword is used to prevent too many fields to be created.
      # DISCUSS: Is this the right choice?
      - match_labels:
          match_mapping_type: string
          # TODO: Does this also match the top level labels?
          match: labels
          runtime:
            type: flattened

      # Match location fields to geopoint
      - location:
          # TODO: What is the correct matching type here?
          match_mapping_type: object
          match: location
          runtime:
            type: geo_point

      # Match name fields to text_keyword
      - match_name:
          # TODO: What is the correct matching type here?
          match_mapping_type: string
          match: name
          runtime:
            # TODO: This is a field type that does not exist today. What ECS does is that for all name fields, it
            # has a subfield .text to also do text indexing
            type: text_keyword

      # Match strings fields to wildcard
      # This matches the following fields: strings
      # An example field is registry.data.strings
      - match_strings:
          # TODO: What is the correct matching type here?
          match_mapping_type: string
          match: strings
          runtime:
            type: wildcard

      # Match date fields to date
      # This matches the following fields: event.created, event.ingested
      - match_created:
          match: created
          runtime:
            type: date

      - match_ingested:
          match: ingested
          runtime:
            type: date

      # Keyword fields to discuss if should be indexed or not. Proposed rule for discussion. Quorum needs to be reached
      # for a field to be indexed. Reason is going from runtime to index is easy, otherway around could be a breaking
      # It should also be discussed if logs-*, metrics-* and traces-* have exact same default.
      # change.
      # This is list is initially copied from https://github.com/elastic/elasticsearch/pull/88181/files#diff-0fba05a9236d9aa3866db886f0b6c24759be01a775023e1663b8f44f91951e62
      # - log.level
      # - log.logger
      # - trace.id
      # - span.id
      # - transaction.id
      # - service.name
      # - service.version
      # - service.environment
      # - process.id
      # - process.thread.name
      # - error.type
      # - error.message
      # - event.dataset
      # - cloud.provider
      # - cloud.availability_zone
      # - cloud.region
      # - cloud.provider
      # - host.hostname
      # - host.name
      # - container.id
      # - container.name
      # - orchestrator.namespace
      # - orchestrator.id
      # - orchestrator.resource.id
      # - orchestrator.resource.name



# Meta information blocks
_meta:
  description: Base mappings for indices and data streams using ECS
  managed: true

# TODO: What should the version here be? Put in brackets for now to make it valid yaml
version: "${xpack.stack.template.version}"
