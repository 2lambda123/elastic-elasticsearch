/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

package org.elasticsearch.xpack.security.cli;

import joptsimple.OptionSet;
import org.elasticsearch.cli.EnvironmentAwareCommand;
import org.elasticsearch.cli.ExitCodes;
import org.elasticsearch.cli.Terminal;
import org.elasticsearch.cli.UserException;
import org.elasticsearch.env.Environment;
import org.elasticsearch.xpack.core.XPackSettings;
import org.elasticsearch.xpack.security.cli.CertificateTool.CertificateAndKey;
import org.elasticsearch.xpack.security.cli.CertificateTool.GenerateCertificateCommand;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

import static org.elasticsearch.xpack.security.cli.CertificateTool.CertificateCommand.writePkcs12;
import static org.elasticsearch.xpack.security.cli.CertificateTool.fullyWriteFile;
import static org.elasticsearch.xpack.security.cli.CertificateTool.resolvePath;

// this starts a single node cluster with security features enabled
public class AutoConfigInitialNode extends EnvironmentAwareCommand {

    private static final String TRANSPORT_AUTOGENERATED_CERTIFICATE_NAME = "transport-auto-generated-all-nodes";
    private static final int TRANSPORT_CERTIFICATE_DAYS = 3 * 365;
    private static final int TRANSPORT_KEY_SIZE = 2048;

    public AutoConfigInitialNode() {
        super("Generates all the necessary configuration for the initial node of a new secure cluster");
    }

    @Override
    protected void execute(Terminal terminal, OptionSet options, Environment env) throws Exception {
        if (Files.isDirectory(env.dataFile())) {
            terminal.println(Terminal.Verbosity.VERBOSE,
                            "Skipping security auto configuration because it appears that the node is not starting up for the first time.");
            // TODO maybe throw a special error that informs the auto configuration skipped
            return;
        }
        if (env.settings().hasValue(XPackSettings.SECURITY_ENABLED.getKey()) ||
                false == env.settings().getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX).isEmpty()) {
            // do not try to validate, correct or fill in incomplete security configuration,
            // but instead rely on the node startup to do the validation
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because it appears that security is already configured.");
            // TODO maybe throw a special error that informs the auto configuration skipped
            return;
        }
        // TODO if cannot be leader (is not master)
        // TODO set initial master nodes to this node only
        // TODO generate transport PKCS12 with password that is stored in the keystore

        {
            // TODO check the CWD
            // the transport key-pair is the same across the cluster and is trusted without hostname verification,
            // so do not to populate the ip,dns,CN certificate fields
            CertificateTool.CertificateInformation certificateInformation =
                    new CertificateTool.CertificateInformation(TRANSPORT_AUTOGENERATED_CERTIFICATE_NAME,
                            TRANSPORT_AUTOGENERATED_CERTIFICATE_NAME, null, null, null);
            List<String> validationErrors = certificateInformation.validate();
            if (false == validationErrors.isEmpty()) {
                validationErrors.forEach(terminal::errorPrintln);
                throw new UserException(ExitCodes.DATA_ERROR, "Could not generate transport certificates");
            }
            GenerateCertificateCommand certificateCommand = new GenerateCertificateCommand();
            CertificateAndKey pair = certificateCommand.generateCertificateAndKey(certificateInformation, null,
                    TRANSPORT_KEY_SIZE,
                    TRANSPORT_CERTIFICATE_DAYS);
            Path output = resolvePath(TRANSPORT_AUTOGENERATED_CERTIFICATE_NAME + ".p12");
            // TODO generate password randomly
            char[] outputPassword = new char[]{'t', 'e', 's', 't'};
            fullyWriteFile(output, stream -> writePkcs12(output.getFileName().toString(), stream,
                    certificateInformation.name.originalName, pair, null, outputPassword, terminal));
        }
//        new GenerateCertificateCommand().generateAndWriteSignedCertificates();
//        // investigate the fork an wait for cluster to form
//
//        // TODO if single-node
//        // TODO check environment variable (only if there's no enrollment token go through this, but maybe this is thing fo rthe sh script)
//        final boolean isSecurityEnabled = XPackSettings.SECURITY_ENABLED.get(env.settings());
//        final boolean isSecurityExplicitlySet = env.settings().hasValue(XPackSettings.SECURITY_ENABLED.getKey());
//        // don't try to do settings validation, only bare minimum necessary
//        if (isSecurityExplicitlySet) {
//            if (isSecurityEnabled) {
//
//            } else {
//                terminal.println("Security is disabled by configuration.");
//                return;
//            }
//        } else {
//            //
//            final ClusterState clusterState =
//                    loadTermAndClusterState(createPersistedClusterStateService(env.settings(), dataPath), environment).v2();
//        }
    }

}
