/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

package org.elasticsearch.xpack.security.cli;

import joptsimple.OptionSet;
import org.elasticsearch.cli.EnvironmentAwareCommand;
import org.elasticsearch.cli.ExitCodes;
import org.elasticsearch.cli.Terminal;
import org.elasticsearch.cli.UserException;
import org.elasticsearch.cluster.coordination.ClusterBootstrapService;
import org.elasticsearch.cluster.node.DiscoveryNodeRole;
import org.elasticsearch.common.UUIDs;
import org.elasticsearch.common.settings.KeyStoreWrapper;
import org.elasticsearch.common.settings.SecureString;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.env.Environment;
import org.elasticsearch.http.HttpTransportSettings;
import org.elasticsearch.node.NodeRoleSettings;
import org.elasticsearch.xpack.core.XPackSettings;
import org.elasticsearch.xpack.core.security.authc.RealmSettings;
import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.KeyPair;
import java.security.KeyStore;
import java.security.cert.Certificate;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.Locale;

import static org.elasticsearch.xpack.security.cli.CertificateTool.fullyWriteFile;

/**
 * Configures a new cluster node, by appending to the elasticsearch.yml, so that it forms a single node cluster with
 * Security enabled. Used to configure only the initial node of a cluster, and only the first time that the node
 * is started. Subsequent nodes can be added to the cluster via the enrollment flow, but this is not used to
 * configure such nodes or to display the necessary configuration (ie the enrollment tokens) for such.
 *
 * This will not run if Security is explicitly configured or if the existing configuration otherwise clashes with the
 * intent of this (i.e. the node is configured so it cannot form a single node cluster).
 */
public class AutoConfigInitialNode extends EnvironmentAwareCommand {

    private static final String TRANSPORT_AUTOGENERATED_KEYSTORE_NAME = "transport_keystore_all_nodes";
    private static final String TRANSPORT_AUTOGENERATED_TRUSTSTORE_NAME = "transport_truststore_all_nodes";
    private static final int TRANSPORT_CERTIFICATE_DAYS = 3 * 365;
    private static final int TRANSPORT_KEY_SIZE = 2048;

    public AutoConfigInitialNode() {
        super("Generates all the necessary configuration for the initial node of a new secure cluster");
    }

    public static void main(String[] args) throws Exception {
        exit(new AutoConfigInitialNode().main(args, Terminal.DEFAULT));
    }

    @Override
    protected void execute(Terminal terminal, OptionSet options, Environment env) throws Exception {
        if (Files.isDirectory(env.dataFile())) {
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because it appears that the node is not starting up for the first time.");
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "The node might already be part of a cluster and this auto setup utility is designed to configure Security for new " +
                            "clusters only.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: node restarted");
        }
        if (env.settings().hasValue(XPackSettings.SECURITY_ENABLED.getKey())) {
            // do not try to validate, correct or fill in any incomplete security configuration,
            // but instead rely on the regular node startup to do this validation
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because it appears that security is already configured.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: Security already configured");
        }
        if (env.settings().hasValue(ClusterBootstrapService.INITIAL_MASTER_NODES_SETTING.getKey())) {
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because this node is explicitly configured to form a new cluster.");
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "The node cannot be auto configured to participate in forming a new multi-node secure cluster.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: configured cluster formation");
        }
        List<DiscoveryNodeRole> nodeRoles = NodeRoleSettings.NODE_ROLES_SETTING.get(env.settings());
        boolean canBecomeMaster = nodeRoles.contains(DiscoveryNodeRole.MASTER_ROLE) &&
                false == nodeRoles.contains(DiscoveryNodeRole.VOTING_ONLY_NODE_ROLE);
        if (false == canBecomeMaster) {
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because the node is configured such that it cannot become master.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: cannot become master");
        }
        boolean canHoldSecurityIndex = nodeRoles.stream().anyMatch(DiscoveryNodeRole::canContainData);
        if (false == canHoldSecurityIndex) {
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because the node is configured such that it cannot contain data.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: cannot contain data");
        }
        if (false == env.settings().getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX).isEmpty() ||
                false == env.settings().getByPrefix(XPackSettings.HTTP_SSL_PREFIX).isEmpty()) {
            // again, zero validation for the TLS settings, let the node startup do its thing
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because it appears that TLS is already configured.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: TLS already configured");
        }
        // check that no file realms have been configured.
        // this can technically be improved upon:
        // auto configuration only requires that the file realm be enabled, and, for optimal experience,
        // also be the first in the chain
        if (false == env.settings().getByPrefix(RealmSettings.realmSettingPrefix(FileRealmSettings.TYPE)).isEmpty()) {
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because it appears that a file-based realm is already configured.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: file realm configured");
        }
        // tolerate enabling enrollment explicitly, as it could be useful to enable it by a command line option
        // only the first time that the node is started
        if (env.settings().hasValue(XPackSettings.ENROLLMENT_ENABLED.getKey()) && false ==
                XPackSettings.ENROLLMENT_ENABLED.get(env.settings())) {
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because enrollment is explicitly disabled.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: enrollment disabled");
        }

        final ZonedDateTime autoConfigDate = ZonedDateTime.now();
        final String instantAutoConfigName = "auto_generated_" + autoConfigDate.toInstant().getEpochSecond();
        final Path instantAutoConfigDir = env.configFile().resolve(instantAutoConfigName);
        if (false == instantAutoConfigDir.toFile().mkdir()) {
            throw new UserException(ExitCodes.CANT_CREATE, "Could not create auto configuration directory");
        }

        // the transport key-pair is the same across the cluster and is trusted without hostname verification (it is self-signed),
        // do not populate the certificate's IP, DN, and CN certificate fields
        CertificateTool.Name transportCertificateName = CertificateTool.Name.fromUserProvidedName(TRANSPORT_AUTOGENERATED_KEYSTORE_NAME,
                TRANSPORT_AUTOGENERATED_KEYSTORE_NAME);
        if (transportCertificateName.error != null) {
            terminal.errorPrintln(transportCertificateName.error);
            throw new UserException(ExitCodes.DATA_ERROR, "Could not generate transport certificates");
        }
        KeyPair keyPair = CertGenUtils.generateKeyPair(TRANSPORT_KEY_SIZE);
        Certificate certificate = CertGenUtils.generateSignedCertificate(transportCertificateName.x500Principal,
                null, keyPair, null, null, false, TRANSPORT_CERTIFICATE_DAYS, null);

        final KeyStoreWrapper nodeKeystore;
        try (SecureString keystorePassword = new SecureString(terminal.readSecret("", KeyStoreWrapper.MAX_PASSPHRASE_LENGTH))) {
            nodeKeystore = KeyStoreWrapper.bootstrap(env.configFile(), () -> keystorePassword);
            Path transportKeystoreOutput = instantAutoConfigDir.resolve(TRANSPORT_AUTOGENERATED_KEYSTORE_NAME + ".p12");
            try (SecureString transportKeystorePassword = UUIDs.randomBase64UUIDSecureString()) {
                KeyStore transportKeystore = KeyStore.getInstance("PKCS12");
                transportKeystore.load(null);
                transportKeystore.setKeyEntry(transportCertificateName.originalName, keyPair.getPrivate(),
                        transportKeystorePassword.getChars(), new Certificate[]{certificate});
                fullyWriteFile(transportKeystoreOutput, stream -> transportKeystore.store(stream, transportKeystorePassword.getChars()));
                nodeKeystore.setString("xpack.security.transport.ssl.keystore.secure_password", transportKeystorePassword.getChars());
            } finally {
                nodeKeystore.save(env.configFile(), keystorePassword.getChars());
            }
        }

        Path transportTruststoreOutput = instantAutoConfigDir.resolve(TRANSPORT_AUTOGENERATED_TRUSTSTORE_NAME + ".p12");
        final KeyStore transportTruststore = KeyStore.getInstance("PKCS12");
        transportTruststore.load(null);
        transportTruststore.setCertificateEntry(transportCertificateName.originalName, certificate);
        fullyWriteFile(transportTruststoreOutput, stream -> transportTruststore.store(stream, new char[0]));

        Path path = env.configFile().resolve("elasticsearch.yml");
        FileWriter fw = new FileWriter(path.toFile(), true);
        BufferedWriter bw = new BufferedWriter(fw);
        bw.newLine();
        bw.newLine();
        bw.write("###################################################################################");
        bw.newLine();
        bw.write("# The following settings, and associated TLS certificates and keys configuration, #");
        bw.newLine();
        bw.write("# have been automatically generated in order to configure Security.               #");
        bw.newLine();
        bw.write("# These have been generated the first time that the new node was started without  #");
        bw.newLine();
        bw.write("# joining or enrolling to an existing cluster and only if Security had not been   #");
        bw.newLine();
        bw.write("# explicitly configured beforehand.                                               #");
        bw.newLine();
        bw.write(String.format(Locale.ROOT, "# %-79s #", ""));
        bw.newLine();
        bw.write(String.format(Locale.ROOT, "# %-79s #", autoConfigDate));
        bw.newLine();
        bw.write("###################################################################################");
        bw.newLine();
        bw.newLine();
        bw.write(XPackSettings.SECURITY_ENABLED.getKey() + ": true");
        bw.newLine();
        bw.newLine();
        if (false == env.settings().hasValue(XPackSettings.ENROLLMENT_ENABLED.getKey())) {
            bw.write(XPackSettings.ENROLLMENT_ENABLED.getKey() + ": true");
            bw.newLine();
            bw.newLine();
        }
        int autoRealmOrder = minimumRealmOrder(env.settings());
        bw.write(RealmSettings.ORDER_SETTING.apply(FileRealmSettings.TYPE)
                .getConcreteSettingForNamespace(instantAutoConfigName).getKey() + ": " + autoRealmOrder);
        bw.newLine();
        bw.newLine();
        bw.write("xpack.security.transport.ssl.enabled: true");
        bw.newLine();
        bw.write("xpack.security.transport.ssl.verification_mode: certificate");
        bw.newLine();
        bw.write("xpack.security.transport.ssl.client_authentication: required");
        bw.newLine();
        bw.write("xpack.security.transport.ssl.keystore.path: " + Path.of(instantAutoConfigName,
                TRANSPORT_AUTOGENERATED_KEYSTORE_NAME + ".p12"));
        bw.newLine();
        bw.write("xpack.security.transport.ssl.truststore.path: " + Path.of(instantAutoConfigName,
                TRANSPORT_AUTOGENERATED_TRUSTSTORE_NAME + ".p12"));
        bw.newLine();
        if (false == env.settings().hasValue(HttpTransportSettings.SETTING_HTTP_HOST.getKey())) {
            bw.newLine();
            bw.write("# With security now configured, it's reasonable to serve requests on the local network too");
            bw.newLine();
            bw.write(HttpTransportSettings.SETTING_HTTP_HOST.getKey() + ": [_local_, _site_]");
        }
        bw.close();
    }

    private Integer minimumRealmOrder(Settings settings) {
        Integer order = 0;
        Settings realmsSettings = settings.getByPrefix(RealmSettings.PREFIX);
        if (realmsSettings == null || realmsSettings.isEmpty()) {
            return order;
        }
        for (String realmType : realmsSettings.names()) {
            // return the first enabled file realm
            Settings realmSettings = realmsSettings.getByPrefix(realmType);
            if (realmSettings == null || realmSettings.isEmpty()) {
                continue;
            }
            for (String realmName : realmSettings.names()) {
                order = Math.min(order,
                        RealmSettings.ORDER_SETTING.apply(realmType).getConcreteSettingForNamespace(realmName).get(settings));
            }
        }
        return order;
    }

}
