/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

package org.elasticsearch.xpack.security.cli;

import joptsimple.OptionSet;
import org.elasticsearch.cli.EnvironmentAwareCommand;
import org.elasticsearch.cli.ExitCodes;
import org.elasticsearch.cli.Terminal;
import org.elasticsearch.cli.UserException;
import org.elasticsearch.cluster.coordination.ClusterBootstrapService;
import org.elasticsearch.common.UUIDs;
import org.elasticsearch.common.settings.KeyStoreWrapper;
import org.elasticsearch.common.settings.SecureString;
import org.elasticsearch.env.Environment;
import org.elasticsearch.xpack.core.XPackSettings;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.KeyPair;
import java.security.KeyStore;
import java.security.cert.Certificate;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.Locale;

import static org.elasticsearch.xpack.security.cli.CertificateTool.fullyWriteFile;

// this starts a single node cluster with security features enabled
public class AutoConfigInitialNode extends EnvironmentAwareCommand {

    private static final String TRANSPORT_AUTOGENERATED_KEYSTORE_NAME = "transport_keystore_all_nodes";
    private static final String TRANSPORT_AUTOGENERATED_TRUSTSTORE_NAME = "transport_truststore_all_nodes";
    private static final int TRANSPORT_CERTIFICATE_DAYS = 3 * 365;
    private static final int TRANSPORT_KEY_SIZE = 2048;

    public AutoConfigInitialNode() {
        super("Generates all the necessary configuration for the initial node of a new secure cluster");
    }

    public static void main(String[] args) throws Exception {
        exit(new AutoConfigInitialNode().main(args, Terminal.DEFAULT));
    }

    @Override
    protected void execute(Terminal terminal, OptionSet options, Environment env) throws Exception {
        // TODO check between terminal print and log
        if (Files.isDirectory(env.dataFile())) {
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because it appears that the node is not starting up for the first time.");
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "The node might already be part of a cluster and this auto setup utility is designed to configure Security for new " +
                            "clusters only.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: node restarted");
        }
        if (env.settings().hasValue(ClusterBootstrapService.INITIAL_MASTER_NODES_SETTING.getKey())) {
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because this node is explicitly configured to form a new cluster.");
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "The node cannot be auto configured to participate in forming a new multi-node secure cluster.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: configured cluster formation");
        }
        // TODO detect if console/terminal
        if (env.settings().hasValue(XPackSettings.SECURITY_ENABLED.getKey()) ||
                false == env.settings().getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX).isEmpty() ||
                false == env.settings().getByPrefix(XPackSettings.HTTP_SSL_PREFIX).isEmpty()) {
            // do not try to validate, correct or fill in any incomplete security configuration,
            // but instead rely on the regular node startup to do this validation
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because it appears that security is already configured.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: Security already configured");
        }
        terminal.println(Terminal.Verbosity.VERBOSE, "Attempting to create a new secure cluster.");

        final ZonedDateTime autoConfigDate = ZonedDateTime.now();
        final String instantAutoConfigName = "auto_generated_" + autoConfigDate.toInstant().getEpochSecond();
        final Path instantAutoConfigDir = env.configFile().resolve(instantAutoConfigName);
        if (false == instantAutoConfigDir.toFile().mkdir()) {
            throw new UserException(ExitCodes.CANT_CREATE, "Could not create auto configuration directory");
        }

        // TODO check if cannot become leader (if not master)
        // TODO generate transport PKCS12 with password that is stored in the keystore

        // TODO log

        // the transport key-pair is the same across the cluster and is trusted without hostname verification (it is self-signed),
        // do not populate the certificate's IP, DN, and CN certificate fields
        CertificateTool.CertificateInformation certificateInformation =
                new CertificateTool.CertificateInformation(TRANSPORT_AUTOGENERATED_KEYSTORE_NAME,
                        TRANSPORT_AUTOGENERATED_KEYSTORE_NAME, null, null, null);
        List<String> validationErrors = certificateInformation.validate();
        if (false == validationErrors.isEmpty()) {
            validationErrors.forEach(terminal::errorPrintln);
            throw new UserException(ExitCodes.DATA_ERROR, "Could not generate transport certificates");
        }
        KeyPair keyPair = CertGenUtils.generateKeyPair(TRANSPORT_KEY_SIZE);
        Certificate certificate = CertGenUtils.generateSignedCertificate(certificateInformation.name.x500Principal,
                null, keyPair, null, null, false, TRANSPORT_CERTIFICATE_DAYS, null);

        final KeyStoreWrapper nodeKeystore;
        try (SecureString keystorePassword = new SecureString(terminal.readSecret("", KeyStoreWrapper.MAX_PASSPHRASE_LENGTH))) {
            nodeKeystore = KeyStoreWrapper.bootstrap(env.configFile(), () -> keystorePassword);
            Path transportKeystoreOutput = instantAutoConfigDir.resolve(TRANSPORT_AUTOGENERATED_KEYSTORE_NAME + ".p12");
            try (SecureString transportKeystorePassword = UUIDs.randomBase64UUIDSecureString()) {
                KeyStore transportKeystore = KeyStore.getInstance("PKCS12");
                transportKeystore.load(null);
                transportKeystore.setKeyEntry(certificateInformation.name.originalName, keyPair.getPrivate(),
                        transportKeystorePassword.getChars(), new Certificate[]{certificate});
                fullyWriteFile(transportKeystoreOutput, stream -> transportKeystore.store(stream, transportKeystorePassword.getChars()));
                nodeKeystore.setString("xpack.security.transport.ssl.keystore.secure_password", transportKeystorePassword.getChars());
            } finally {
                nodeKeystore.save(env.configFile(), keystorePassword.getChars());
            }
        }

        Path transportTruststoreOutput = instantAutoConfigDir.resolve(TRANSPORT_AUTOGENERATED_TRUSTSTORE_NAME + ".p12");
        final KeyStore transportTruststore = KeyStore.getInstance("PKCS12");
        transportTruststore.load(null);
        transportTruststore.setCertificateEntry(certificateInformation.name.originalName, certificate);
        fullyWriteFile(transportTruststoreOutput, stream -> transportTruststore.store(stream, new char[0]));

        Path path = env.configFile().resolve("elasticsearch.yml");
        FileWriter fw = new FileWriter(path.toFile(), true);
        BufferedWriter bw = new BufferedWriter(fw);
        bw.newLine();
        bw.newLine();
        bw.write("##############################################################################################");
        bw.newLine();
        bw.write("# The following settings, and associated TLS certificates and keys configuration, have been  #");
        bw.newLine();
        bw.write("# automatically generated in order to configure Security.                                    #");
        bw.newLine();
        bw.write("# These have been generated the first time that the new node was started, from the command   #");
        bw.newLine();
        bw.write("# line, and without joining or enrolling to an existing cluster and only if Security had not #");
        bw.newLine();
        bw.write("# been expressly configured before starting up the node.                                     #");
        bw.newLine();
        bw.write(String.format(Locale.ROOT, "# %-90s #", ""));
        bw.newLine();
        bw.write(String.format(Locale.ROOT, "# %-90s #", autoConfigDate));
        bw.newLine();
        bw.write("##############################################################################################");
        bw.newLine();
        bw.newLine();
        bw.write("xpack.security.enabled: true");
        bw.newLine();
        bw.newLine();
        // TODO check if order or enabled is toggled
        bw.write("xpack.security.authc.realms.file." + instantAutoConfigName + ".order: 0");
        bw.newLine();
        bw.newLine();
        bw.write("xpack.security.transport.ssl.enabled: true");
        bw.newLine();
        bw.write("xpack.security.transport.ssl.verification_mode: certificate");
        bw.newLine();
        bw.write("xpack.security.transport.ssl.client_authentication: required");
        bw.newLine();
        bw.write("xpack.security.transport.ssl.keystore.path: " + Path.of(instantAutoConfigName,
                TRANSPORT_AUTOGENERATED_KEYSTORE_NAME + ".p12"));
        bw.newLine();
        bw.write("xpack.security.transport.ssl.truststore.path: " + Path.of(instantAutoConfigName,
                TRANSPORT_AUTOGENERATED_TRUSTSTORE_NAME + ".p12"));
        bw.newLine();
        bw.close();

//        new GenerateCertificateCommand().generateAndWriteSignedCertificates();
//        // investigate the fork an wait for cluster to form
//
//        // TODO if single-node
//        // TODO check environment variable (only if there's no enrollment token go through this, but maybe this is thing fo rthe sh script)
//        final boolean isSecurityEnabled = XPackSettings.SECURITY_ENABLED.get(env.settings());
//        final boolean isSecurityExplicitlySet = env.settings().hasValue(XPackSettings.SECURITY_ENABLED.getKey());
//        // don't try to do settings validation, only bare minimum necessary
//        if (isSecurityExplicitlySet) {
//            if (isSecurityEnabled) {
//
//            } else {
//                terminal.println("Security is disabled by configuration.");
//                return;
//            }
//        } else {
//            //
//            final ClusterState clusterState =
//                    loadTermAndClusterState(createPersistedClusterStateService(env.settings(), dataPath), environment).v2();
//        }
    }

}
