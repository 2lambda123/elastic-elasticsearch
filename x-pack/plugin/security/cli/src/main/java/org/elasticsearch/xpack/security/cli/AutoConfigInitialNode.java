/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

package org.elasticsearch.xpack.security.cli;

import joptsimple.OptionSet;
import org.elasticsearch.cli.EnvironmentAwareCommand;
import org.elasticsearch.cli.ExitCodes;
import org.elasticsearch.cli.Terminal;
import org.elasticsearch.cli.UserException;
import org.elasticsearch.cluster.coordination.ClusterBootstrapService;
import org.elasticsearch.common.UUIDs;
import org.elasticsearch.common.settings.KeyStoreWrapper;
import org.elasticsearch.common.settings.SecureString;
import org.elasticsearch.env.Environment;
import org.elasticsearch.xpack.core.XPackSettings;
import org.elasticsearch.xpack.core.security.authc.RealmSettings;
import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.KeyPair;
import java.security.KeyStore;
import java.security.cert.Certificate;
import java.time.ZonedDateTime;
import java.util.Locale;

import static org.elasticsearch.xpack.security.cli.CertificateTool.fullyWriteFile;

/**
 * Configures a new cluster node, by appending to the elasticsearch.yml, so that it forms a single node cluster with
 * Security enabled. Used to configure only the initial node of a cluster, and only the first time that the node
 * is started. Subsequent nodes can be added to the cluster via the enrollment flow, but this is not used to
 * configure such nodes or to display the necessary configuration (ie the enrollment tokens) for such.
 *
 * This will not run if Security is explicitly configured or if the existing configuration otherwise clashes with the
 * intent of this (i.e. the node is configured so it cannot form a single node cluster).
 */
public class AutoConfigInitialNode extends EnvironmentAwareCommand {

    private static final String TRANSPORT_AUTOGENERATED_KEYSTORE_NAME = "transport_keystore_all_nodes";
    private static final String TRANSPORT_AUTOGENERATED_TRUSTSTORE_NAME = "transport_truststore_all_nodes";
    private static final int TRANSPORT_CERTIFICATE_DAYS = 3 * 365;
    private static final int TRANSPORT_KEY_SIZE = 2048;

    public AutoConfigInitialNode() {
        super("Generates all the necessary configuration for the initial node of a new secure cluster");
    }

    public static void main(String[] args) throws Exception {
        exit(new AutoConfigInitialNode().main(args, Terminal.DEFAULT));
    }

    @Override
    protected void execute(Terminal terminal, OptionSet options, Environment env) throws Exception {
        if (Files.isDirectory(env.dataFile())) {
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because it appears that the node is not starting up for the first time.");
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "The node might already be part of a cluster and this auto setup utility is designed to configure Security for new " +
                            "clusters only.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: node restarted");
        }
        if (env.settings().hasValue(XPackSettings.SECURITY_ENABLED.getKey())) {
            // do not try to validate, correct or fill in any incomplete security configuration,
            // but instead rely on the regular node startup to do this validation
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because it appears that security is already configured.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: Security already configured");
        }
        if (env.settings().hasValue(ClusterBootstrapService.INITIAL_MASTER_NODES_SETTING.getKey())) {
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because this node is explicitly configured to form a new cluster.");
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "The node cannot be auto configured to participate in forming a new multi-node secure cluster.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: configured cluster formation");
        }
        if (false == env.settings().getByPrefix(XPackSettings.TRANSPORT_SSL_PREFIX).isEmpty() ||
                false == env.settings().getByPrefix(XPackSettings.HTTP_SSL_PREFIX).isEmpty()) {
            // again, zero validation for the TLS settings, let the node startup do its thing
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because it appears that TLS is already configured.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: TLS already configured");
        }
        if (false == env.settings().getByPrefix(RealmSettings.realmSettingPrefix(FileRealmSettings.TYPE)).isEmpty()) {
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because it appears that TLS is already configured.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: file realm configured");
        }
        // tolerate enabling enrollment explicitly, as it could be useful to enable it by a command line option
        // only the first time that the node is started
        if (env.settings().hasValue(XPackSettings.ENROLLMENT_ENABLED.getKey()) && false ==
                XPackSettings.ENROLLMENT_ENABLED.get(env.settings())) {
            terminal.println(Terminal.Verbosity.VERBOSE,
                    "Skipping security auto configuration because enrollment is explicitly disabled.");
            throw new UserException(ExitCodes.OK, "Skipping security auto configuration: enrollment disabled");
        }

        final ZonedDateTime autoConfigDate = ZonedDateTime.now();
        final String instantAutoConfigName = "auto_generated_" + autoConfigDate.toInstant().getEpochSecond();
        final Path instantAutoConfigDir = env.configFile().resolve(instantAutoConfigName);
        if (false == instantAutoConfigDir.toFile().mkdir()) {
            throw new UserException(ExitCodes.CANT_CREATE, "Could not create auto configuration directory");
        }

        // TODO check if cannot become leader (if not master)

        // TODO enable ip filtering

        // TODO http bind to local and site

        // the transport key-pair is the same across the cluster and is trusted without hostname verification (it is self-signed),
        // do not populate the certificate's IP, DN, and CN certificate fields
        CertificateTool.Name transportCertificateName = CertificateTool.Name.fromUserProvidedName(TRANSPORT_AUTOGENERATED_KEYSTORE_NAME,
                TRANSPORT_AUTOGENERATED_KEYSTORE_NAME);
        if (transportCertificateName.error != null) {
            terminal.errorPrintln(transportCertificateName.error);
            throw new UserException(ExitCodes.DATA_ERROR, "Could not generate transport certificates");
        }
        KeyPair keyPair = CertGenUtils.generateKeyPair(TRANSPORT_KEY_SIZE);
        Certificate certificate = CertGenUtils.generateSignedCertificate(transportCertificateName.x500Principal,
                null, keyPair, null, null, false, TRANSPORT_CERTIFICATE_DAYS, null);

        final KeyStoreWrapper nodeKeystore;
        try (SecureString keystorePassword = new SecureString(terminal.readSecret("", KeyStoreWrapper.MAX_PASSPHRASE_LENGTH))) {
            nodeKeystore = KeyStoreWrapper.bootstrap(env.configFile(), () -> keystorePassword);
            Path transportKeystoreOutput = instantAutoConfigDir.resolve(TRANSPORT_AUTOGENERATED_KEYSTORE_NAME + ".p12");
            try (SecureString transportKeystorePassword = UUIDs.randomBase64UUIDSecureString()) {
                KeyStore transportKeystore = KeyStore.getInstance("PKCS12");
                transportKeystore.load(null);
                transportKeystore.setKeyEntry(transportCertificateName.originalName, keyPair.getPrivate(),
                        transportKeystorePassword.getChars(), new Certificate[]{certificate});
                fullyWriteFile(transportKeystoreOutput, stream -> transportKeystore.store(stream, transportKeystorePassword.getChars()));
                nodeKeystore.setString("xpack.security.transport.ssl.keystore.secure_password", transportKeystorePassword.getChars());
            } finally {
                nodeKeystore.save(env.configFile(), keystorePassword.getChars());
            }
        }

        Path transportTruststoreOutput = instantAutoConfigDir.resolve(TRANSPORT_AUTOGENERATED_TRUSTSTORE_NAME + ".p12");
        final KeyStore transportTruststore = KeyStore.getInstance("PKCS12");
        transportTruststore.load(null);
        transportTruststore.setCertificateEntry(transportCertificateName.originalName, certificate);
        fullyWriteFile(transportTruststoreOutput, stream -> transportTruststore.store(stream, new char[0]));

        Path path = env.configFile().resolve("elasticsearch.yml");
        FileWriter fw = new FileWriter(path.toFile(), true);
        BufferedWriter bw = new BufferedWriter(fw);
        bw.newLine();
        bw.newLine();
        bw.write("###################################################################################");
        bw.newLine();
        bw.write("# The following settings, and associated TLS certificates and keys configuration, #");
        bw.newLine();
        bw.write("# have been automatically generated in order to configure Security.               #");
        bw.newLine();
        bw.write("# These have been generated the first time that the new node was started without  #");
        bw.newLine();
        bw.write("# joining or enrolling to an existing cluster and only if Security had not been   #");
        bw.newLine();
        bw.write("# explicitly configured beforehand.                                               #");
        bw.newLine();
        bw.write(String.format(Locale.ROOT, "# %-82s #", ""));
        bw.newLine();
        bw.write(String.format(Locale.ROOT, "# %-82s #", autoConfigDate));
        bw.newLine();
        bw.write("###################################################################################");
        bw.newLine();
        bw.newLine();
        bw.write(XPackSettings.SECURITY_ENABLED.getKey() + ": true");
        bw.newLine();
        if (false == env.settings().hasValue(XPackSettings.ENROLLMENT_ENABLED.getKey())) {
            bw.write(XPackSettings.ENROLLMENT_ENABLED.getKey() + ": true");
            bw.newLine();
        }
        bw.newLine();
        // TODO check if realm order or realm enabled are set
        bw.write("xpack.security.authc.realms.file." + instantAutoConfigName + ".order: 0");
        bw.newLine();
        bw.newLine();
        bw.write("xpack.security.transport.ssl.enabled: true");
        bw.newLine();
        bw.write("xpack.security.transport.ssl.verification_mode: certificate");
        bw.newLine();
        bw.write("xpack.security.transport.ssl.client_authentication: required");
        bw.newLine();
        bw.write("xpack.security.transport.ssl.keystore.path: " + Path.of(instantAutoConfigName,
                TRANSPORT_AUTOGENERATED_KEYSTORE_NAME + ".p12"));
        bw.newLine();
        bw.write("xpack.security.transport.ssl.truststore.path: " + Path.of(instantAutoConfigName,
                TRANSPORT_AUTOGENERATED_TRUSTSTORE_NAME + ".p12"));
        bw.newLine();
        bw.close();
    }

}
