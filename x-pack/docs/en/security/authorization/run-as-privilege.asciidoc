[role="xpack"]
[[run-as-privilege]]
= Submitting requests on behalf of other users

The {es} {security-features} support a privilege that enables an authenticated
user to submit requests on behalf of other users. If your application already 
authenticates users, you can use the _run as_ mechanism to restrict data access
according to {es} permissions without having to re-authenticate each user.

To "run as" (impersonate) another user, that user must exist in a realm that
supports the _run as_ mechanism. The internal `native` and `file` realms
inherently support this capability, as does the JWT realm. To support `run_as`,
in the LDAP realm, you have to run in
<<ldap-realm-configuration,_user search_ mode>>. For Active Directory, you need
to <<ref-ad-settings,configure a `bind_dn` and `secure_bind_password`>>.

The Kerberos, OpenID Connect, PKI, and SAML realms do not support _run as_.

To submit requests on behalf of other users, you need to have the `run_as`
privilege in your <<defining-roles,roles>>. For example, the following request
creates a `my_director` role that grants permission to submit request on behalf
of `jacknich` or `redeniro`:

[source,console]
----
POST /_security/role/my_director?refresh=true
{
  "cluster": ["manage"],
  "indices": [
    {
      "names": [ "index1", "index2" ],
      "privileges": [ "manage" ]
    }
  ],
  "run_as": [ "jacknich", "rdeniro" ],
  "metadata" : {
    "version" : 1
  }
}
----

To submit a request as another user, you specify the user in the
`es-security-runas-user` request header. For example:

[source,sh]
----
curl -H "es-security-runas-user: jacknich"  -u es-admin -X GET http://localhost:9200/
----
// NOTCONSOLE

[[run-as-privilege-apply]]
== Apply the `run_as` privilege to roles
You can apply the `run_as` privilege when creating roles with the
<<security-api-put-role,create or update roles API>>. Users who are assigned
a role that contains the `run_as` privilege inherit all privileges from their
role, and can also submit requests on behalf of the indicated users.

The `run_as` privilege essentially operates like a secondary form of
<<authorization_realms,delegated authorization>>. After a user successfully
authenticates to {es}, an authorization process determines whether the user
behind an incoming request is allowed to run that request. If the authenticated
user has the `run_as` privilege in their list of permissions, {es} _discards_ the 
authenticated user and associated roles. It then looks in each of the configured
realms in the realm chain until it finds the username that's associated with the
`run_as` user, and uses those roles to submit any requests.

Consider an admin role and an analyst role. The admin role has higher privileges,
but might also want to submit requests as another user to test and verify their
permissions.

First, we'll create an admin role named `my_admin_role`. This role has `manage` 
<<security-privileges,privileges>> on the entire cluster, and on a subset of
indices. This role also contains the `run_as` privilege, which enables any user
with this role to submit requests on behalf of users with the `my_analyst_role`
role.

[source,console]
----
POST /_security/role/my_admin_role?refresh=true
{
  "cluster": ["manage"],
  "indices": [
    {
      "names": [ "index1", "index2" ],
      "privileges": [ "manage" ]
    }
  ],
  "applications": [
    {
      "application": "myapp",
      "privileges": [ "admin", "read" ],
      "resources": [ "*" ]
    }
  ],
  "run_as": [ "my_analyst_role" ],
  "metadata" : {
    "version" : 1
  }
}
----

Next, we'll create an analyst role named `my_analyst_role`, which has `monitor`
cluster privileges and `manage` privileges on a subset of indices.

[source,console]
----
POST /_security/role/my_analyst_role?refresh=true
{
  "cluster": [ "monitor"],
  "indices": [
    {
      "names": [ "index1", "index2" ],
      "privileges": ["manage"]
    }
  ],
  "applications": [
    {
      "application": "myapp",
      "privileges": [ "read" ],
      "resources": [ "*" ]
    }
  ],
  "metadata" : {
    "version" : 1
  }
}
----

We'll create an admin user and assign them the role named `my_admin_role`, which
allows this user to submit requests as a user with the `my_analyst_role` role.

[source,console]
----
POST /_security/user/admin_user?refresh=true
{
  "password": "l0ng-r4nd0m-p@ssw0rd",
  "roles": [ "my_admin_role" ],
  "full_name": "Eirian Zola",
  "metadata": { "intelligence" : 7}
}
----

We can also create an analyst user and assign them the role named
`my_analyst_role`.

[source,console]
----
POST /_security/user/analyst_user?refresh=true
{
  "password": "l0nger-r4nd0mer-p@ssw0rd",
  "roles": [ "my_analyst_role" ],
  "full_name": "Monday Jaffe",
  "metadata": { "innovation" : 8}
}
----

Let's say you have a bearer token that you created using the 
<<security-api-get-token,get token API>>. These tokens are created by the
{es} Token Service, but you can get a bearer token from another realm such as
the JWT realm. You include the bearer token in the `Authorization` header when
making requests to {es}. If you make a request to {es} and also include the
`es-security-runas-user` request header, you can specify the `run_as` user that
you want to submit requests on behalf of. 

The following request authenticates to {es} with a bearer token and submits the
request as the `analyst_user`

[source,sh]
----
curl -s -X GET -H "Authorization: Bearer g8HpAxZVcUY1X2taaVFhMkdMbzRnUGd0TjdnAAAAAAAAAAAA" -H "es-security-runas-user: analyst_user" https://localhost:9200/_security/_authenticate
----
// NOTCONSOLE

The response indicates that the `analyst_user` submitted this request:

[source,sh]
----
{"username":"analyst_user","roles":["my_analyst_role"],"full_name":"Monday Jaffe",
"email":null,"metadata":{"innovation":8},"enabled":true,"authentication_realm":
{"name":"native","type":"native"},"lookup_realm":{"name":"native","type":"native"},
"authentication_type":"token"}%   
----