[[update-lifecycle-policy]]
== Update lifecycle policy

Updating existing ILM policies is useful to fix mistakes or change
strategies for newly created indices. Existing indices that are being
managed by a policy that changes will be modified as well. So that
phases currently being executed are not interrupted at dangerous times, updates
to policies will not affect the current phase that is being executed.

There are three scenarios for examining the behavior updating policies and
their effects on policy execution on indices.

A. Effects of a policy update on an index that is not being managed by
   the modified policy
 - Nothing occurs on the index since it is unmanaged. If an index is assigned to
    the policy, it will be assigned the latest version of that policy
B. Effects of updating a specific phase's definition with an index currently executing the policy.
 - Indices preserve the phase definition from the latest policy version that existed
     at the time that it entered that phase. So if an index is in the `hot` phase, and the
     `hot` phase's definition is updated in the meantime, then the index will not experience
     any changes until it completes the previous version's hot phase and continues to the next
     defined phase (as defined by the latest version).
C. Effects of switching which policy is managing an index
 - This behaves much like a policy update, but instead of just switching to a different
     version, it switches to a different policy (the latest version of that policy).


=== A. Update Policy With No Indices

Let's start with creating a policy `my_policy`.

[source,js]
------------------------
PUT _ilm/my_policy
{
  "policy": {
    "phases": {
      "hot": {
        "actions": {
          "rollover": {
            "max_size": "25GB" <1>
          }
        }
      },
      "delete": {
        "minimum_age": "30d",
        "actions": {
          "delete": {} <2>
        }
      }
    }
  }
}
------------------------
// CONSOLE

This newly defined policy will be created and assigned to have a version equal
to 1. Since we haven't assigned any indices to this policy, any updates that
occur will be reflected completely on indices that are newly set to be managed
by this policy.

Updating the Delete phase's minimum age can be done in an update request.

[source,js]
------------------------
PUT _ilm/my_policy
{
  "policy": {
    "phases": {
      "hot": {
        "actions": {
          "rollover": {
            "max_size": "25GB"
          }
        }
      },
      "delete": {
        "minimum_age": "10d", <1>
        "actions": {
          "delete": {}
        }
      }
    }
  }
}
------------------------
// CONSOLE
// TEST[continued]
<1> update `minimum_age` to 10 days

//////////
[source,js]
--------------------------------------------------
GET _ilm
--------------------------------------------------
// CONSOLE
// TEST[continued]
//////////

When we get the policy, we will see it reflect our latest changes, but
with its version bumped to 2.

[source,js]
--------------------------------------------------
{
  "my_policy": {
    "version": 2, <1>
    "modified_date": 82392349, <2>
    "policy": {
      "phases": {
        "warm": {
          "minimum_age": "10d",
          "actions": {
            "forcemerge": {
              "max_num_segments": 1
            }
          }
        },
        "delete": {
          "minimum_age": "10d",
          "actions": {
            "delete": {}
          }
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE
// TESTRESPONSE[s/"modified_date": 82392349/"modified_date": $body.my_policy.modified_date/]
<1> The updated version value
<2> The timestamp when this policy was updated last.

Afterwords, any indices set to `my_policy` will execute against version 2 of
the policy.

=== B. Update policy with existing index in the warm phase

// TODO


=== C. Swapping policies on an index

After setting a policy for an index, we can switch out `my_policy` with
`my_other_policy` by just updating the index's `index.lifecycle.name`
setting to the new policy. After completing its currently executed phase,
it will move on to the next phase in `my_other_policy`. So if it was on the
`hot` phase before, it will move to the `delete` phase after the `hot` phase concluded.

////
[source,js]
------------------------
PUT _ilm/my_policy
{
  "policy": {
    "phases": {
      "hot": {
        "actions": {
          "rollover": {
            "max_size": "25GB"
          }
        }
      },
      "delete": {
        "minimum_age": "10d", <1>
        "actions": {
          "delete": {}
        }
      }
    }
  }
}
------------------------
// CONSOLE

////
[source,js]
--------------------------------------------------
POST my_index/_settings
{
  "index.lifecycle.name": "my_other_policy"
}
--------------------------------------------------
// CONSOLE
// TEST[continued]
