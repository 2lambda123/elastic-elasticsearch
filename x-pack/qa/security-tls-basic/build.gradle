import javax.net.ssl.HttpsURLConnection
import javax.net.ssl.KeyManager
import javax.net.ssl.SSLContext
import javax.net.ssl.TrustManagerFactory
import java.nio.charset.StandardCharsets
import java.security.KeyStore
import java.security.SecureRandom

apply plugin: 'elasticsearch.standalone-rest-test'
apply plugin: 'elasticsearch.rest-test'

dependencies {
  // "org.elasticsearch.plugin:x-pack-core:${version}" doesn't work with idea because the testArtifacts are also here
  testCompile project(path: xpackModule('core'), configuration: 'default')
  testCompile project(path: xpackModule('security'), configuration: 'testArtifacts')
  testCompile project(path: xpackModule('core'), configuration: 'testArtifacts')
  testCompile project(path: ':modules:reindex')
}

forbiddenPatterns {
    exclude '**/*.key'
    exclude '**/*.pem'
    exclude '**/*.p12'
    exclude '**/*.jks'
}

File caFile = project.file('src/test/resources/ssl/ca.p12')

integTestCluster {
  numNodes=3

  extraConfigFile 'http.key', project.projectDir.toPath().resolve('src/test/resources/ssl/http.key')
  extraConfigFile 'http.crt', project.projectDir.toPath().resolve('src/test/resources/ssl/http.crt')
  extraConfigFile 'transport.key', project.projectDir.toPath().resolve('src/test/resources/ssl/transport.key')
  extraConfigFile 'transport.crt', project.projectDir.toPath().resolve('src/test/resources/ssl/transport.crt')
  extraConfigFile 'ca.crt', project.projectDir.toPath().resolve('src/test/resources/ssl/ca.crt')
  extraConfigFile 'ca.p12', caFile

  setting 'xpack.ilm.enabled', 'false'
  setting 'xpack.ml.enabled', 'false'
  setting 'xpack.license.self_generated.type', 'basic'
  setting 'xpack.security.http.ssl.enabled', 'true'
  setting 'xpack.security.http.ssl.certificate', 'http.crt'
  setting 'xpack.security.http.ssl.key', 'http.key'
  setting 'xpack.security.http.ssl.key_passphrase', 'http-password'
  setting 'xpack.security.transport.ssl.enabled', 'true'
  setting 'xpack.security.transport.ssl.certificate', 'transport.crt'
  setting 'xpack.security.transport.ssl.key', 'transport.key'
  setting 'xpack.security.transport.ssl.key_passphrase', 'transport-password'
  setting 'xpack.security.transport.ssl.certificate_authorities', 'ca.crt'

  waitCondition = { node, ant ->
    // Load the CA PKCS#12 file as a truststore
    KeyStore ks = KeyStore.getInstance("PKCS12");
    ks.load(caFile.newInputStream(), 'password'.toCharArray());
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    tmf.init(ks);

    // Configre a SSL context for TLS1.2 using our CA trust manager
    SSLContext sslContext = SSLContext.getInstance("TLSv1.2");
    sslContext.init(new KeyManager[0], tmf.getTrustManagers(), new SecureRandom());

    // Check whether the cluster has started
    URL url = new URL("https://${node.httpUri()}/_cluster/health?wait_for_nodes=${numNodes}&wait_for_status=yellow");
    for (int i = 20; i >= 0; i--) {
      // we use custom wait logic here for HTTPS
      HttpsURLConnection httpURLConnection = null;
      try {
        logger.info("Trying ${url}");
        httpURLConnection = (HttpsURLConnection) url.openConnection();
        httpURLConnection.setSSLSocketFactory(sslContext.getSocketFactory());
        httpURLConnection.setRequestMethod("GET");
        httpURLConnection.connect();
        if (httpURLConnection.getResponseCode() == 200) {
          logger.info("Cluster has started");
          return true;
        } else {
          logger.debug("HTTP response was [{}]", httpURLConnection.getResponseCode());
        }
      } catch (IOException e) {
          if (i == 0) {
              logger.error("Failed to call cluster health - " + e)
          }
          logger.debug("Call to [{}] threw an exception", url, e)
      } finally {
        if (httpURLConnection != null) {
          httpURLConnection.disconnect();
        }
      }
      // did not start, so wait a bit before trying again
      Thread.sleep(750L);
    }
    return false;
  }
}

